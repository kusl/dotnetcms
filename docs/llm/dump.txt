===============================================================================
PROJECT EXPORT
Generated: Tue Jan 20 09:18:43 AM EST 2026
Project Path: /home/kushal/src/dotnet/MyBlog
===============================================================================

DIRECTORY STRUCTURE:
===================

.
├── .continue
│   └── agents
├── docs
│   └── llm
│       ├── output
│       │   ├── 0001.txt
│       │   ├── 0002.txt
│       │   ├── 0003.txt
│       │   ├── 0004.txt
│       │   ├── 0005.txt
│       │   ├── 0006.txt
│       │   ├── 0007.txt
│       │   ├── 0008.txt
│       │   ├── 0009.txt
│       │   ├── 0010.txt
│       │   ├── 0011.txt
│       │   ├── 0012.txt
│       │   ├── 0013.txt
│       │   ├── 0014.txt
│       │   ├── 0015.txt
│       │   ├── 0016.txt
│       │   ├── 0017.txt
│       │   ├── 0018.txt
│       │   ├── 0019.txt
│       │   ├── 0020.txt
│       │   ├── 0021.txt
│       │   ├── 0022.txt
│       │   └── 0023.txt
│       ├── claude.md
│       ├── command.md
│       ├── dump.txt
│       └── kush.runasp.net-WebDeploy.publishSettings
├── .github
│   └── workflows
│       └── build-deploy.yml
├── src
│   ├── .github
│   │   └── workflows
│   │       └── build-deploy.yml
│   ├── MyBlog.Core
│   │   ├── Constants
│   │   │   └── AppConstants.cs
│   │   ├── Interfaces
│   │   │   ├── IAuthService.cs
│   │   │   ├── IImageDimensionService.cs
│   │   │   ├── IImageRepository.cs
│   │   │   ├── IMarkdownService.cs
│   │   │   ├── IPasswordService.cs
│   │   │   ├── IPostRepository.cs
│   │   │   ├── IReaderTrackingService.cs
│   │   │   ├── ISlugService.cs
│   │   │   ├── ITelemetryLogRepository.cs
│   │   │   └── IUserRepository.cs
│   │   ├── Models
│   │   │   ├── Image.cs
│   │   │   ├── ImageDimensionCache.cs
│   │   │   ├── Post.cs
│   │   │   ├── PostDto.cs
│   │   │   ├── TelemetryLog.cs
│   │   │   └── User.cs
│   │   ├── Services
│   │   │   ├── MarkdownService.cs
│   │   │   └── SlugService.cs
│   │   └── MyBlog.Core.csproj
│   ├── MyBlog.Infrastructure
│   │   ├── Data
│   │   │   ├── BlogDbContext.cs
│   │   │   └── DatabasePathResolver.cs
│   │   ├── Repositories
│   │   │   ├── ImageRepository.cs
│   │   │   ├── PostRepository.cs
│   │   │   ├── TelemetryLogRepository.cs
│   │   │   └── UserRepository.cs
│   │   ├── Services
│   │   │   ├── AuthService.cs
│   │   │   ├── ImageCacheWarmerService.cs
│   │   │   ├── ImageDimensionService.cs
│   │   │   ├── PasswordService.cs
│   │   │   ├── ReaderTrackingService.cs
│   │   │   └── TelemetryCleanupService.cs
│   │   ├── Telemetry
│   │   │   ├── DatabaseLogExporter.cs
│   │   │   ├── FileLogExporter.cs
│   │   │   └── TelemetryPathResolver.cs
│   │   ├── MyBlog.Infrastructure.csproj
│   │   └── ServiceCollectionExtensions.cs
│   ├── MyBlog.Tests
│   │   ├── Integration
│   │   │   ├── AuthServiceLongPasswordTests.cs
│   │   │   ├── AuthServiceTests.cs
│   │   │   ├── PasswordChangeTests.cs
│   │   │   ├── PostRepositoryTests.cs
│   │   │   └── TelemetryCleanupTests.cs
│   │   ├── Unit
│   │   │   ├── LoginRateLimitMiddlewareTests.cs
│   │   │   ├── MarkdownServiceTests.cs
│   │   │   ├── PasswordServiceTests.cs
│   │   │   └── SlugServiceTests.cs
│   │   └── MyBlog.Tests.csproj
│   ├── MyBlog.Web
│   │   ├── Components
│   │   │   ├── Layout
│   │   │   │   └── MainLayout.razor
│   │   │   ├── Pages
│   │   │   │   ├── Admin
│   │   │   │   │   ├── ChangePassword.razor
│   │   │   │   │   ├── Dashboard.razor
│   │   │   │   │   ├── ImageManager.razor
│   │   │   │   │   ├── PostEditor.razor
│   │   │   │   │   ├── PostList.razor
│   │   │   │   │   ├── UserEditor.razor
│   │   │   │   │   ├── UserEditor.razor.css
│   │   │   │   │   ├── UserList.razor
│   │   │   │   │   └── UserList.razor.css
│   │   │   │   ├── About.razor
│   │   │   │   ├── About.razor.css
│   │   │   │   ├── AccessDenied.razor
│   │   │   │   ├── Home.razor
│   │   │   │   ├── Login.razor
│   │   │   │   ├── PostDetail.razor
│   │   │   │   └── PostDetail.razor.css
│   │   │   ├── Shared
│   │   │   │   ├── Footer.razor
│   │   │   │   ├── Footer.razor.css
│   │   │   │   ├── MarkdownRenderer.razor
│   │   │   │   ├── Pagination.razor
│   │   │   │   ├── PostCard.razor
│   │   │   │   ├── PostCard.razor.css
│   │   │   │   ├── ReaderBadge.razor
│   │   │   │   ├── ReaderBadge.razor.css
│   │   │   │   └── RedirectToLogin.razor
│   │   │   ├── App.razor
│   │   │   ├── _Imports.razor
│   │   │   └── Routes.razor
│   │   ├── Hubs
│   │   │   └── ReaderHub.cs
│   │   ├── Middleware
│   │   │   └── LoginRateLimitMiddleware.cs
│   │   ├── wwwroot
│   │   │   ├── css
│   │   │   │   └── site.css
│   │   │   └── js
│   │   │       └── site.js
│   │   ├── appsettings.Development.json
│   │   ├── appsettings.json
│   │   ├── MyBlog.Web.csproj
│   │   └── Program.cs
│   ├── Directory.Build.props
│   ├── Directory.Packages.props
│   ├── .editorconfig
│   ├── .gitkeep
│   ├── global.json
│   ├── MyBlog.sln.DotSettings.user
│   └── MyBlog.slnx
├── .editorconfig
├── export.sh
├── .gitignore
└── README.md


FILE CONTENTS:
==============

================================================================================
FILE: .editorconfig
SIZE: .89 KB
MODIFIED: 2026-01-11 12:42:44
================================================================================

root = true

[*]
indent_style = space
indent_size = 4
insert_final_newline = true
trim_trailing_whitespace = true
charset = utf-8

[*.{cs,razor}]
# Naming conventions
dotnet_naming_rule.private_fields_should_be_underscored.severity = suggestion
dotnet_naming_rule.private_fields_should_be_underscored.symbols = private_fields
dotnet_naming_rule.private_fields_should_be_underscored.style = prefix_underscore

dotnet_naming_symbols.private_fields.applicable_kinds = field
dotnet_naming_symbols.private_fields.applicable_accessibilities = private

dotnet_naming_style.prefix_underscore.capitalization = camel_case
dotnet_naming_style.prefix_underscore.required_prefix = _

# Code style rules
csharp_style_expression_bodied_properties = true:suggestion
csharp_style_expression_bodied_methods = true:suggestion
csharp_style_namespace_declarations = file_scoped:error
csharp_style_var_for_built_in_types = true:suggestion


================================================================================
FILE: export.sh
SIZE: 8.50 KB
MODIFIED: 2025-12-28 07:47:30
================================================================================

#!/bin/bash
# =============================================================================
# Complete Project Export for LLM Analysis
# =============================================================================
# Exports all relevant source files, configs, and documentation for AI review.
# Excludes: binaries, build outputs, IDE files, packages, git internals
# =============================================================================

set -e

OUTPUT_DIR="docs/llm"
OUTPUT_FILE="$OUTPUT_DIR/dump.txt"
PROJECT_PATH="$(pwd)"

# File extensions to include (comprehensive list for .NET/Avalonia projects)
# Source code
SOURCE_EXTS="cs|fs|vb"
# XAML/Avalonia UI
XAML_EXTS="axaml|xaml|paml"
# Project/Build files
PROJECT_EXTS="csproj|fsproj|vbproj|slnx|sln|props|targets|tasks"
# Config files
CONFIG_EXTS="json|yaml|yml|xml|config|settings"
# Documentation
DOC_EXTS="md|txt|rst|adoc"
# Scripts
SCRIPT_EXTS="sh|ps1|psm1|cmd|bat"
# Web/Style (in case of Avalonia web or styling)
STYLE_EXTS="css|scss|sass|less"
# Data/Templates
DATA_EXTS="sql|csv|resx|resources"
# Docker/CI
DEVOPS_EXTS="dockerfile|dockerignore|editorconfig|gitignore|gitattributes"

# Combine all extensions
ALL_EXTS="$SOURCE_EXTS|$XAML_EXTS|$PROJECT_EXTS|$CONFIG_EXTS|$DOC_EXTS|$SCRIPT_EXTS|$STYLE_EXTS|$DATA_EXTS"

# Directories to exclude
EXCLUDE_DIRS="bin|obj|.git|.vs|.idea|.vscode|node_modules|packages|TestResults|coverage|publish|artifacts|.nuget|wwwroot/lib"

# Files to exclude (patterns)
EXCLUDE_FILES="*.Designer.cs|*.g.cs|*.g.i.cs|AssemblyInfo.cs|*.min.js|*.min.css|package-lock.json|*.lock|*.bak"

echo "=============================================="
echo "  Project Export for LLM Analysis"
echo "=============================================="
echo ""
echo "Project Path: $PROJECT_PATH"
echo "Output File:  $OUTPUT_FILE"
echo ""

mkdir -p "$OUTPUT_DIR"

# Start output file
{
    echo "==============================================================================="
    echo "PROJECT EXPORT"
    echo "Generated: $(date)"
    echo "Project Path: $PROJECT_PATH"
    echo "==============================================================================="
    echo ""
} > "$OUTPUT_FILE"

# Directory structure
echo "Generating directory structure..."
{
    echo "DIRECTORY STRUCTURE:"
    echo "==================="
    echo ""
    # Try tree first, fall back to find
    if command -v tree &> /dev/null; then
        tree -a -I "$EXCLUDE_DIRS" --noreport --dirsfirst 2>/dev/null || echo "(tree command failed)"
    else
        find . -type d \( -name "bin" -o -name "obj" -o -name ".git" -o -name ".vs" -o -name ".idea" -o -name "node_modules" -o -name "packages" -o -name "TestResults" \) -prune -o -type f -print | sed 's|[^/]*/|  |g' | sort
    fi
    echo ""
    echo ""
} >> "$OUTPUT_FILE"

# Build the find command dynamically
echo "Collecting files..."

# Create a temporary file for the file list
TMPFILE=$(mktemp)

# Find all relevant files
find . -type f \( \
    -iname "*.cs" -o \
    -iname "*.fs" -o \
    -iname "*.vb" -o \
    -iname "*.axaml" -o \
    -iname "*.xaml" -o \
    -iname "*.paml" -o \
    -iname "*.csproj" -o \
    -iname "*.fsproj" -o \
    -iname "*.vbproj" -o \
    -iname "*.slnx" -o \
    -iname "*.sln" -o \
    -iname "*.props" -o \
    -iname "*.targets" -o \
    -iname "*.json" -o \
    -iname "*.yaml" -o \
    -iname "*.yml" -o \
    -iname "*.xml" -o \
    -iname "*.config" -o \
    -iname "*.md" -o \
    -iname "*.txt" -o \
    -iname "*.sh" -o \
    -iname "*.ps1" -o \
    -iname "*.cmd" -o \
    -iname "*.bat" -o \
    -iname "*.sql" -o \
    -iname "*.resx" -o \
    -iname "*.css" -o \
    -iname "*.scss" -o \
    -iname "*.manifest" -o \
    -iname "*.ico" -o \
    -iname "Dockerfile" -o \
    -iname "docker-compose*.yml" -o \
    -iname ".editorconfig" -o \
    -iname ".gitignore" -o \
    -iname ".gitattributes" -o \
    -iname "global.json" -o \
    -iname "nuget.config" -o \
    -iname "Directory.Build.props" -o \
    -iname "Directory.Build.targets" -o \
    -iname "Directory.Packages.props" \
    \) \
    ! -path "*/bin/*" \
    ! -path "*/obj/*" \
    ! -path "*/docs/*" \
    ! -path "*/.git/*" \
    ! -path "*/.vs/*" \
    ! -path "*/.idea/*" \
    ! -path "*/.vscode/*" \
    ! -path "*/node_modules/*" \
    ! -path "*/packages/*" \
    ! -path "*/TestResults/*" \
    ! -path "*/coverage/*" \
    ! -path "*/publish/*" \
    ! -path "*/artifacts/*" \
    ! -path "*/.nuget/*" \
    ! -name "*.Designer.cs" \
    ! -name "*.g.cs" \
    ! -name "*.g.i.cs" \
    ! -name "*.min.js" \
    ! -name "*.min.css" \
    ! -name "package-lock.json" \
    ! -name "*.bak" \
    2>/dev/null | sort > "$TMPFILE"

FILE_COUNT=$(wc -l < "$TMPFILE")
echo "Found $FILE_COUNT files to export"
echo ""

# Add file contents header
{
    echo "FILE CONTENTS:"
    echo "=============="
    echo ""
} >> "$OUTPUT_FILE"

# Process each file
COUNTER=0
SKIPPED=0

while IFS= read -r file; do
    COUNTER=$((COUNTER + 1))
    FILENAME="${file#./}"
    
    # Skip binary files (check if file is text)
    if file "$file" | grep -qE "binary|executable|data|image"; then
        # For some files we want to note they exist but not dump contents
        if [[ "$file" =~ \.(ico|png|jpg|jpeg|gif|bmp|svg|woff|woff2|ttf|eot)$ ]]; then
            SKIPPED=$((SKIPPED + 1))
            echo "Skipping binary ($COUNTER/$FILE_COUNT): $FILENAME"
            {
                echo "================================================================================"
                echo "FILE: $FILENAME"
                echo "TYPE: [BINARY FILE - Contents not exported]"
                echo "================================================================================"
                echo ""
            } >> "$OUTPUT_FILE"
            continue
        fi
    fi
    
    # Get file info
    FILESIZE=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")
    MODIFIED=$(stat -c%y "$file" 2>/dev/null | cut -d'.' -f1 || stat -f"%Sm" -t "%Y-%m-%d %H:%M:%S" "$file" 2>/dev/null || echo "unknown")
    
    # Skip very large files (>500KB) - they're probably not source code
    if [ "$FILESIZE" -gt 512000 ]; then
        SKIPPED=$((SKIPPED + 1))
        echo "Skipping large file ($COUNTER/$FILE_COUNT): $FILENAME ($(echo "scale=0; $FILESIZE/1024" | bc)KB)"
        {
            echo "================================================================================"
            echo "FILE: $FILENAME"
            echo "SIZE: $(echo "scale=2; $FILESIZE/1024" | bc) KB"
            echo "TYPE: [LARGE FILE - Contents not exported, exceeds 500KB limit]"
            echo "================================================================================"
            echo ""
        } >> "$OUTPUT_FILE"
        continue
    fi
    
    echo "Processing ($COUNTER/$FILE_COUNT): $FILENAME"
    
    {
        echo "================================================================================"
        echo "FILE: $FILENAME"
        echo "SIZE: $(echo "scale=2; $FILESIZE/1024" | bc 2>/dev/null || echo "0.00") KB"
        echo "MODIFIED: $MODIFIED"
        echo "================================================================================"
        echo ""
        cat "$file" 2>/dev/null || echo "[ERROR: Could not read file]"
        echo ""
        echo ""
    } >> "$OUTPUT_FILE"
    
done < "$TMPFILE"

# Cleanup
rm -f "$TMPFILE"

# Summary
EXPORTED=$((COUNTER - SKIPPED))
{
    echo "==============================================================================="
    echo "EXPORT COMPLETED: $(date)"
    echo "Total Files Found: $FILE_COUNT"
    echo "Files Exported: $EXPORTED"
    echo "Files Skipped: $SKIPPED (binary or large files)"
    echo "Output File: $PROJECT_PATH/$OUTPUT_FILE"
    echo "==============================================================================="
} >> "$OUTPUT_FILE"

# Final output
OUTPUT_SIZE=$(stat -c%s "$OUTPUT_FILE" 2>/dev/null || stat -f%z "$OUTPUT_FILE" 2>/dev/null || echo "0")

echo ""
echo "=============================================="
echo "  Export Complete!"
echo "=============================================="
echo ""
echo "Output file:    $OUTPUT_FILE"
echo "Files exported: $EXPORTED"
echo "Files skipped:  $SKIPPED"
echo "Output size:    $(echo "scale=2; $OUTPUT_SIZE/1024" | bc 2>/dev/null || echo "?") KB"
echo ""
echo "File types included:"
echo "  • Source code: .cs, .fs, .vb"
echo "  • UI/XAML: .axaml, .xaml, .paml"
echo "  • Projects: .csproj, .slnx, .sln, .props, .targets"
echo "  • Config: .json, .yaml, .yml, .xml, .config"
echo "  • Docs: .md, .txt"
echo "  • Scripts: .sh, .ps1, .cmd, .bat"
echo "  • Other: .sql, .resx, .css, .scss, Dockerfile, etc."
echo ""


================================================================================
FILE: .github/workflows/build-deploy.yml
SIZE: 2.87 KB
MODIFIED: 2026-01-01 21:59:50
================================================================================

name: Build, Test, and Deploy

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

jobs:
  build-test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore dependencies
        run: dotnet restore src/MyBlog.slnx

      - name: Build solution
        run: dotnet build src/MyBlog.slnx -c Release --no-restore

      - name: Run tests
        run: 
          dotnet run --project src/MyBlog.Tests/MyBlog.Tests.csproj

  deploy:
    needs: build-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Publish application
        run: dotnet publish src/MyBlog.Web/MyBlog.Web.csproj -c Release -o ./publish -r win-x86 --self-contained false

      - name: Deploy via WebDeploy
        shell: pwsh
        env:
          DEPLOY_SOURCE: ${{ github.workspace }}\publish
          DEPLOY_SITE: ${{ secrets.WEBSITE_NAME }}
          DEPLOY_HOST: ${{ secrets.SERVER_COMPUTER_NAME }}
          DEPLOY_USER: ${{ secrets.SERVER_USERNAME }}
          DEPLOY_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
        run: |
          $msdeployPath = "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe"
          
          if (-not (Test-Path $msdeployPath)) {
            Write-Host "Installing Web Deploy..."
            choco install webdeploy -y --no-progress
          }
          
          Write-Host "Deploying to $env:DEPLOY_HOST..."
          Write-Host "Note: Using AppOffline rule to prevent file-in-use errors"

          $sourceArg = "-source:contentPath=$env:DEPLOY_SOURCE"
          $destArg = "-dest:contentPath=$env:DEPLOY_SITE,computerName=https://$($env:DEPLOY_HOST):8172/MsDeploy.axd?site=$env:DEPLOY_SITE,userName=$env:DEPLOY_USER,password=$env:DEPLOY_PASSWORD,AuthType='Basic'"
          
          # Key fix: Added -enableRule:AppOffline to stop the app during deployment
          # This creates app_offline.htm, waits for app to stop, deploys, then removes the file
          & $msdeployPath -verb:sync $sourceArg $destArg `
            -allowUntrusted `
            -enableRule:DoNotDeleteRule `
            -enableRule:AppOffline `
            -retryAttempts:3 `
            -retryInterval:3000
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Deployment failed with exit code $LASTEXITCODE"
            exit 1
          }
          
          Write-Host "Deployment completed successfully!"


================================================================================
FILE: .gitignore
SIZE: 7.84 KB
MODIFIED: 2025-12-28 08:05:03
================================================================================

## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from `dotnet new gitignore`

# dotenv files
.env

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET
project.lock.json
project.fragment.lock.json
artifacts/

# Tye
.tye/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
# but not Directory.Build.rsp, as it configures directory-level build defaults
!Directory.Build.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.tlog
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio 6 auto-generated project file (contains which files were open etc.)
*.vbp

# Visual Studio 6 workspace and project file (working project files containing files to include in project)
*.dsw
*.dsp

# Visual Studio 6 technical files
*.ncb
*.aps

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# Visual Studio History (VSHistory) files
.vshistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

# VS Code files for those working on multiple tools
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# Windows Installer files from build outputs
*.cab
*.msi
*.msix
*.msm
*.msp

# JetBrains Rider
*.sln.iml
.idea/

##
## Visual studio for Mac
##


# globs
Makefile.in
*.userprefs
*.usertasks
config.make
config.status
aclocal.m4
install-sh
autom4te.cache/
*.tar.gz
tarballs/
test-results/

# content below from: https://github.com/github/gitignore/blob/main/Global/macOS.gitignore
# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# content below from: https://github.com/github/gitignore/blob/main/Global/Windows.gitignore
# Windows thumbnail cache files
Thumbs.db
ehthumbs.db
ehthumbs_vista.db

# Dump file
*.stackdump

# Folder config file
[Dd]esktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Windows Installer files
*.cab
*.msi
*.msix
*.msm
*.msp

# Windows shortcuts
*.lnk

# Vim temporary swap files
*.swp


*.publishSettings


================================================================================
FILE: README.md
SIZE: 7.72 KB
MODIFIED: 2026-01-14 19:57:11
================================================================================

Notice: This project contains code generated by Large Language Models such as Claude and Gemini. All code is experimental whether explicitly stated or not.

# MyBlog

A lightweight, self-hosted blogging platform built with .NET 10 and Blazor Server.

## Features

- [cite_start]**Markdown-based content**: Write posts in Markdown with live preview and support for ordered/unordered lists[cite: 1406, 1409].
- [cite_start]**User Management**: Create, edit, and delete multiple users with role-based access control[cite: 412, 423].
- [cite_start]**Social Sharing**: Built-in "Share" button on posts using the Web Share API (mobile) or Clipboard fallback (desktop)[cite: 1971].
- [cite_start]**Image management**: Upload and manage images stored in the database[cite: 1096].
- **Security**:
  - [cite_start]Login rate limiting to prevent brute-force attacks[cite: 1859].
  - [cite_start]Slug collision prevention[cite: 302].
- [cite_start]**OpenTelemetry**: Built-in observability with file-based and database telemetry export[cite: 1563, 1579].
- [cite_start]**Cross-platform**: Runs on Windows, Linux, and macOS[cite: 859].
- [cite_start]**CI/CD ready**: GitHub Actions workflow for automated testing and deployment[cite: 1286].

## Quick Start

### Prerequisites

- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0) or later

### Running Locally

```bash
# Clone the repository
git clone [https://github.com/yourusername/dotnetcms.git](https://github.com/yourusername/dotnetcms.git)
cd dotnetcms/src

# Restore and run
dotnet restore MyBlog.slnx
cd MyBlog.Web
dotnet run

```

The application will start at `http://localhost:5000` (or the next available port).

### Default Credentials

* **Username**: `admin`
*
**Password**: `ChangeMe123!` (or value of `MYBLOG_ADMIN_PASSWORD` environment variable).



> **Important**: The default password is only used when creating the initial admin user. Once the user exists, you must change the password through the website.

## Configuration

### Environment Variables

| Variable | Description | Default |
| --- | --- | --- |
| `MYBLOG_ADMIN_PASSWORD` | Initial admin password (only used on first run) | `ChangeMe123!` |
| `ASPNETCORE_ENVIRONMENT` | Runtime environment | `Production` |

### appsettings.json

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=myblog.db"
  },
  "Authentication": {
    "SessionTimeoutMinutes": 30,
    "DefaultAdminPassword": "ChangeMe123!"
  },
  "Application": {
    "Title": "MyBlog",
    "PostsPerPage": 10,
    "RequireHttps": false
  },
  "Telemetry": {
    "RetentionDays": 30,
    "EnableFileLogging": true,
    "EnableDatabaseLogging": true
  }
}

```

### Database Location

The SQLite database is stored in a platform-specific location following XDG conventions:

| Platform | Path |
| --- | --- |
| Linux | `~/.local/share/MyBlog/myblog.db` |
| macOS | `~/Library/Application Support/MyBlog/myblog.db` |
| Windows | `%LOCALAPPDATA%\MyBlog\myblog.db` |

## Admin Features

### Dashboard (`/admin`)

The admin dashboard provides an overview of your blog with quick access to all management features.

### Managing Posts

* **Create Post** (`/admin/posts/new`): Write a new blog post in Markdown.
* **Edit Post** (`/admin/posts/edit/{id}`): Modify existing posts. Slugs are automatically handled to prevent duplicates.


* **Post List** (`/admin/posts`): View and manage all posts.

### Managing Users

*
**User List** (`/admin/users`): View all registered users.


*
**Create User** (`/admin/users/new`): Add new authors or administrators.


* **Edit User**: Update email, display name, or reset passwords.

### Managing Images

* **Upload Images** (`/admin/images`): Upload images to use in posts.
* **Image Library**: Browse and delete uploaded images.
*
**Usage**: Reference images in Markdown using `/api/images/{id}`.



### Changing Your Password

Navigate to `/admin/change-password` to change your own password:

1. Enter your current password.
2. Enter your new password (minimum 8 characters).
3. Confirm the new password.
4. Click "Change Password".

> **Note**: The `MYBLOG_ADMIN_PASSWORD` environment variable only affects the initial password when the admin user is first created. It does not override existing passwords in the database.

## Deployment

### GitHub Actions (Automated)

The repository includes a GitHub Actions workflow that:

1. Builds and tests on Windows, Linux, and macOS.


2. Deploys to your server via WebDeploy (on main/master/develop branches).



#### Required Secrets

Set these in your repository settings under **Settings > Secrets and variables > Actions**:

| Secret | Description | Example |
| --- | --- | --- |
| `WEBSITE_NAME` | IIS site name | `MyBlog` |
| `SERVER_COMPUTER_NAME` | Server hostname | `myserver.example.com` |
| `SERVER_USERNAME` | WebDeploy username | `deploy-user` |
| `SERVER_PASSWORD` | WebDeploy password | (your password) |

#### Repository Variables

| Variable | Description | Example |
| --- | --- | --- |
| `MYBLOG_ADMIN_PASSWORD` | Initial admin password | (strong password) |

> **Note**: `MYBLOG_ADMIN_PASSWORD` should be set as a **secret**, not a variable, if you want it to remain hidden in logs.

### Manual Deployment

```bash
# Publish for Windows
dotnet publish src/MyBlog.Web/MyBlog.Web.csproj -c Release -o ./publish -r win-x64

# Publish for Linux
dotnet publish src/MyBlog.Web/MyBlog.Web.csproj -c Release -o ./publish -r linux-x64

```

Copy the contents of `./publish` to your server.

### IIS Configuration

1. Install the [.NET 10 Hosting Bundle](https://dotnet.microsoft.com/download/dotnet/10.0)
2. Create a new IIS site pointing to your publish folder
3. Set the Application Pool to "No Managed Code"
4. Ensure the Application Pool identity has write access to the database directory

## Troubleshooting

### ERROR_FILE_IN_USE During Deployment

This occurs when the application is running and DLLs are locked.

**Solution**: The workflow now includes `-enableRule:AppOffline`  which automatically:

1. Creates `app_offline.htm` to stop the application.
2. Waits for the app to release file locks.
3. Deploys the new files.
4. Removes `app_offline.htm` to restart the app.

### Password Not Changing After Setting MYBLOG_ADMIN_PASSWORD

The environment variable only works when **no users exist** in the database.

**To reset with a new password**:

1. Stop the application.
2. Delete the database file (see Database Location above).
3. Set `MYBLOG_ADMIN_PASSWORD` to your desired password.
4. Start the application.

Or, log in with the current password and use `/admin/change-password`.

### Database Locked Errors

SQLite can have locking issues with concurrent access.

**Solutions**:

* Ensure only one instance of the application is running.
* Check that no database tools have the file open.
* Verify file permissions on the database directory.

## Development

### Running Tests

```bash
cd src
dotnet test MyBlog.slnx

```

### Project Structure

```
src/
├── MyBlog.Core/           # Domain models and interfaces
├── MyBlog.Infrastructure/ # Data access, services
├── MyBlog.Web/           # Blazor Server application
└── MyBlog.Tests/         # xUnit test project

```

### Adding New Features

1. Define interfaces in `MyBlog.Core/Interfaces`
2. Implement in `MyBlog.Infrastructure/Services`
3. Add UI in `MyBlog.Web/Components/Pages`
4. Write tests in `MyBlog.Tests`

## API Endpoints

| Endpoint | Method | Description |
| --- | --- | --- |
| `/api/images/{id}` | GET | Retrieve an image by ID

|

## License

MIT License - see [LICENSE](https://www.google.com/search?q=LICENSE) for details.

## Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request


================================================================================
FILE: src/Directory.Build.props
SIZE: .56 KB
MODIFIED: 2026-01-01 22:21:17
================================================================================

<Project>
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
    <AnalysisLevel>latest</AnalysisLevel>
  </PropertyGroup>
  
  <PropertyGroup Condition="$(MSBuildProjectName.Contains('.Tests'))">
    <IsPackable>false</IsPackable>
    <OutputType>Exe</OutputType>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>
</Project>


================================================================================
FILE: src/Directory.Packages.props
SIZE: 1.60 KB
MODIFIED: 2026-01-20 09:10:15
================================================================================

<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
  </PropertyGroup>
  <ItemGroup>
    <!-- Core Framework (.NET 10) -->
    <PackageVersion Include="Microsoft.AspNetCore.SignalR.Client" Version="10.0.2" />
    <PackageVersion Include="Microsoft.EntityFrameworkCore.Sqlite" Version="10.0.2" />
    <PackageVersion Include="Microsoft.EntityFrameworkCore.Design" Version="10.0.1" />
    <PackageVersion Include="Microsoft.AspNetCore.Identity" Version="2.3.9" />
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.1" />
    <!-- OpenTelemetry (official packages only) -->
    <PackageVersion Include="Microsoft.Extensions.Http" Version="10.0.2" />
    <PackageVersion Include="Microsoft.Extensions.Logging" Version="10.0.2" />
    <PackageVersion Include="OpenTelemetry" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Exporter.Console" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Http" Version="1.14.0" />
    <!-- Testing (xUnit v3) -->
    <PackageVersion Include="xunit.v3" Version="3.2.2" />
    <PackageVersion Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
    <PackageVersion Include="xunit.runner.visualstudio" Version="3.1.5" />
    <PackageVersion Include="Microsoft.Testing.Extensions.TrxReport" Version="2.0.2" />
  </ItemGroup>
</Project>

================================================================================
FILE: src/.editorconfig
SIZE: .52 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

root = true

[*]
indent_style = space
indent_size = 4
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.{cs,csx}]
dotnet_sort_system_directives_first = true
csharp_using_directive_placement = outside_namespace
csharp_style_namespace_declarations = file_scoped:warning
csharp_style_var_for_built_in_types = true:suggestion
csharp_style_var_when_type_is_apparent = true:suggestion
csharp_prefer_braces = true:warning

[*.{json,yaml,yml}]
indent_size = 2

[*.md]
trim_trailing_whitespace = false


================================================================================
FILE: src/.github/workflows/build-deploy.yml
SIZE: 3.10 KB
MODIFIED: 2025-12-28 11:33:37
================================================================================

name: Build, Test, and Deploy

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

jobs:
  build-test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore dependencies
        run: dotnet restore src/MyBlog.slnx

      - name: Build solution
        run: dotnet build src/MyBlog.slnx -c Release --no-restore

      - name: Run tests
        run: dotnet test src/MyBlog.slnx -c Release --no-build --logger trx --results-directory TestResults

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.os }}
          path: TestResults
          retention-days: 7

  deploy:
    needs: build-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Publish application
        run: dotnet publish src/MyBlog.Web/MyBlog.Web.csproj -c Release -o ./publish -r win-x86 --self-contained false

      - name: Deploy via WebDeploy
        shell: pwsh
        env:
          DEPLOY_SOURCE: ${{ github.workspace }}\publish
          DEPLOY_SITE: ${{ secrets.WEBSITE_NAME }}
          DEPLOY_HOST: ${{ secrets.SERVER_COMPUTER_NAME }}
          DEPLOY_USER: ${{ secrets.SERVER_USERNAME }}
          DEPLOY_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
        run: |
          $msdeployPath = "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe"
          
          if (-not (Test-Path $msdeployPath)) {
            Write-Host "Installing Web Deploy..."
            choco install webdeploy -y --no-progress
          }
          
          Write-Host "Deploying to $env:DEPLOY_HOST..."
          Write-Host "Note: Using AppOffline rule to prevent file-in-use errors"

          $sourceArg = "-source:contentPath=$env:DEPLOY_SOURCE"
          $destArg = "-dest:contentPath=$env:DEPLOY_SITE,computerName=https://$($env:DEPLOY_HOST):8172/MsDeploy.axd?site=$env:DEPLOY_SITE,userName=$env:DEPLOY_USER,password=$env:DEPLOY_PASSWORD,AuthType='Basic'"
          
          # Key fix: Added -enableRule:AppOffline to stop the app during deployment
          # This creates app_offline.htm, waits for app to stop, deploys, then removes the file
          & $msdeployPath -verb:sync $sourceArg $destArg `
            -allowUntrusted `
            -enableRule:DoNotDeleteRule `
            -enableRule:AppOffline `
            -retryAttempts:3 `
            -retryInterval:3000
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Deployment failed with exit code $LASTEXITCODE"
            exit 1
          }
          
          Write-Host "Deployment completed successfully!"


================================================================================
FILE: src/global.json
SIZE: .13 KB
MODIFIED: 2026-01-01 21:47:36
================================================================================

{
  "sdk": {
    "version": "10.0.100",
    "rollForward": "latestFeature"
  },
  "test": {
    "runner": "Microsoft.Testing.Platform"
  }
}


================================================================================
FILE: src/MyBlog.Core/Constants/AppConstants.cs
SIZE: .73 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

namespace MyBlog.Core.Constants;

/// <summary>
/// Application-wide constants.
/// </summary>
public static class AppConstants
{
    /// <summary>The name of the authentication cookie.</summary>
    public const string AuthCookieName = "MyBlog.Auth";

    /// <summary>The admin role claim value.</summary>
    public const string AdminRole = "Admin";

    /// <summary>Default page size for listings.</summary>
    public const int DefaultPageSize = 10;

    /// <summary>Maximum image size in bytes (5MB).</summary>
    public const int MaxImageSizeBytes = 5 * 1024 * 1024;

    /// <summary>Allowed image content types.</summary>
    public static readonly string[] AllowedImageTypes =
        ["image/jpeg", "image/png", "image/gif", "image/webp"];
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IAuthService.cs
SIZE: 1.05 KB
MODIFIED: 2025-12-28 11:33:37
================================================================================

using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for authentication operations.
/// </summary>
public interface IAuthService
{
    /// <summary>Attempts to authenticate a user.</summary>
    Task<User?> AuthenticateAsync(
        string username, string password, CancellationToken cancellationToken = default);

    /// <summary>Ensures the default admin user exists.</summary>
    Task EnsureAdminUserAsync(CancellationToken cancellationToken = default);

    /// <summary>Changes a user's password.</summary>
    /// <returns>True if password was changed, false if current password was incorrect.</returns>
    Task<bool> ChangePasswordAsync(
        Guid userId,
        string currentPassword,
        string newPassword,
        CancellationToken cancellationToken = default);

    /// <summary>Resets a user's password without requiring the current password (admin function).</summary>
    Task ResetPasswordAsync(
        Guid userId,
        string newPassword,
        CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IImageDimensionService.cs
SIZE: .68 KB
MODIFIED: 2026-01-16 21:39:27
================================================================================

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service for resolving and caching the width and height of images from URLs.
/// </summary>
public interface IImageDimensionService
{
    /// <summary>
    /// Gets the dimensions (width, height) of an image from a URL.
    /// Checks the database cache first; fetches and caches if missing.
    /// </summary>
    /// <param name="url">The absolute URL of the image.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>A tuple containing Width and Height, or null if resolution fails.</returns>
    Task<(int Width, int Height)?> GetDimensionsAsync(string url, CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IImageRepository.cs
SIZE: .69 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for image operations.
/// </summary>
public interface IImageRepository
{
    /// <summary>Gets all images.</summary>
    Task<IReadOnlyList<Image>> GetAllAsync(CancellationToken cancellationToken = default);

    /// <summary>Gets an image by ID.</summary>
    Task<Image?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Creates a new image.</summary>
    Task<Image> CreateAsync(Image image, CancellationToken cancellationToken = default);

    /// <summary>Deletes an image by ID.</summary>
    Task DeleteAsync(Guid id, CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IMarkdownService.cs
SIZE: .25 KB
MODIFIED: 2026-01-16 21:46:20
================================================================================

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for rendering Markdown to HTML.
/// </summary>
public interface IMarkdownService
{
    /// <summary>Converts Markdown text to HTML.</summary>
    Task<string> ToHtmlAsync(string markdown);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IPasswordService.cs
SIZE: .38 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for password hashing and verification.
/// </summary>
public interface IPasswordService
{
    /// <summary>Hashes a plain text password.</summary>
    string HashPassword(string password);

    /// <summary>Verifies a password against a hash.</summary>
    bool VerifyPassword(string hashedPassword, string providedPassword);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IPostRepository.cs
SIZE: 1.75 KB
MODIFIED: 2026-01-14 19:57:11
================================================================================

using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for post operations.
/// </summary>
public interface IPostRepository
{
    /// <summary>Gets a paginated list of published posts.</summary>
    Task<(IReadOnlyList<PostListItemDto> Posts, int TotalCount)> GetPublishedPostsAsync(
        int page, int pageSize, CancellationToken cancellationToken = default);

    /// <summary>Gets all posts for admin view.</summary>
    Task<IReadOnlyList<PostListItemDto>> GetAllPostsAsync(
        CancellationToken cancellationToken = default);

    /// <summary>Gets a post by its slug.</summary>
    Task<PostDetailDto?> GetBySlugAsync(string slug, CancellationToken cancellationToken = default);

    /// <summary>Gets a post by its ID.</summary>
    Task<Post?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Creates a new post.</summary>
    Task<Post> CreateAsync(Post post, CancellationToken cancellationToken = default);

    /// <summary>Updates an existing post.</summary>
    Task UpdateAsync(Post post, CancellationToken cancellationToken = default);

    /// <summary>Deletes a post by ID.</summary>
    Task DeleteAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Gets the total count of posts.</summary>
    Task<int> GetCountAsync(CancellationToken cancellationToken = default);

    /// <summary>Gets recent posts for dashboard.</summary>
    Task<IReadOnlyList<PostListItemDto>> GetRecentPostsAsync(
        int count, CancellationToken cancellationToken = default);

    /// <summary>Checks if a slug is already in use by another post.</summary>
    Task<bool> IsSlugTakenAsync(string slug, Guid? excludePostId = null, CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IReaderTrackingService.cs
SIZE: .90 KB
MODIFIED: 2026-01-16 20:30:07
================================================================================

namespace MyBlog.Core.Interfaces;

public interface IReaderTrackingService
{
    /// <summary>
    /// Registers a connection viewing a specific post.
    /// </summary>
    /// <returns>The new reader count for this slug.</returns>
    int JoinPost(string slug, string connectionId);

    /// <summary>
    /// Unregisters a connection from a specific post.
    /// </summary>
    /// <returns>The new reader count for this slug.</returns>
    int LeavePost(string slug, string connectionId);

    /// <summary>
    /// Handles a disconnection event (e.g. tab closed) and determines which slug was being viewed.
    /// </summary>
    /// <returns>A tuple containing the Slug that was left (if any) and the new count.</returns>
    (string? Slug, int NewCount) Disconnect(string connectionId);

    /// <summary>
    /// Gets the current count for a specific post.
    /// </summary>
    int GetReaderCount(string slug);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/ISlugService.cs
SIZE: .25 KB
MODIFIED: 2026-01-19 18:32:54
================================================================================

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for generating URL-friendly slugs.
/// </summary>
public interface ISlugService
{
    /// <summary>Generates a slug from a title.</summary>
    string GenerateSlugOrUuid(string title);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/ITelemetryLogRepository.cs
SIZE: .67 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for telemetry log operations.
/// </summary>
public interface ITelemetryLogRepository
{
    /// <summary>Writes a log entry to the database.</summary>
    Task WriteAsync(TelemetryLog log, CancellationToken cancellationToken = default);

    /// <summary>Deletes logs older than the specified date.</summary>
    Task<int> DeleteOlderThanAsync(DateTime cutoffUtc, CancellationToken cancellationToken = default);

    /// <summary>Gets recent logs for viewing.</summary>
    Task<IReadOnlyList<TelemetryLog>> GetRecentAsync(
        int count, CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IUserRepository.cs
SIZE: 1.09 KB
MODIFIED: 2025-12-30 21:28:12
================================================================================

using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for user data access.
/// </summary>
public interface IUserRepository
{
    /// <summary>Gets a user by ID.</summary>
    Task<User?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Gets a user by username.</summary>
    Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default);

    /// <summary>Gets all users.</summary>
    Task<IReadOnlyList<User>> GetAllAsync(CancellationToken cancellationToken = default);

    /// <summary>Checks if any users exist.</summary>
    Task<bool> AnyUsersExistAsync(CancellationToken cancellationToken = default);

    /// <summary>Creates a new user.</summary>
    Task CreateAsync(User user, CancellationToken cancellationToken = default);

    /// <summary>Updates an existing user.</summary>
    Task UpdateAsync(User user, CancellationToken cancellationToken = default);

    /// <summary>Deletes a user by ID.</summary>
    Task DeleteAsync(Guid id, CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/MyBlog.Core/Models/Image.cs
SIZE: 1.15 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

namespace MyBlog.Core.Models;

/// <summary>
/// Represents an image stored as a BLOB in the database.
/// </summary>
public sealed class Image
{
    /// <summary>Gets or sets the unique identifier for the image.</summary>
    public Guid Id { get; set; }

    /// <summary>Gets or sets the original file name.</summary>
    public required string FileName { get; set; }

    /// <summary>Gets or sets the MIME content type.</summary>
    public required string ContentType { get; set; }

    /// <summary>Gets or sets the binary image data.</summary>
    public required byte[] Data { get; set; }

    /// <summary>Gets or sets the associated post ID (optional).</summary>
    public Guid? PostId { get; set; }

    /// <summary>Gets or sets when the image was uploaded.</summary>
    public DateTime UploadedAtUtc { get; set; }

    /// <summary>Gets or sets the ID of the user who uploaded the image.</summary>
    public Guid UploadedByUserId { get; set; }

    /// <summary>Navigation property for the associated post.</summary>
    public Post? Post { get; set; }

    /// <summary>Navigation property for the uploader.</summary>
    public User? UploadedBy { get; set; }
}


================================================================================
FILE: src/MyBlog.Core/Models/ImageDimensionCache.cs
SIZE: .58 KB
MODIFIED: 2026-01-16 21:38:23
================================================================================

namespace MyBlog.Core.Models;

/// <summary>
/// Caches dimensions for external images to prevent layout shifts.
/// </summary>
public sealed class ImageDimensionCache
{
    /// <summary>The absolute URL of the image (Primary Key).</summary>
    public required string Url { get; set; }

    /// <summary>The detected width of the image.</summary>
    public int Width { get; set; }

    /// <summary>The detected height of the image.</summary>
    public int Height { get; set; }

    /// <summary>When this record was last updated.</summary>
    public DateTime LastCheckedUtc { get; set; }
}


================================================================================
FILE: src/MyBlog.Core/Models/Post.cs
SIZE: 1.49 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

namespace MyBlog.Core.Models;

/// <summary>
/// Represents a blog post with Markdown content.
/// </summary>
public sealed class Post
{
    /// <summary>Gets or sets the unique identifier for the post.</summary>
    public Guid Id { get; set; }

    /// <summary>Gets or sets the post title.</summary>
    public required string Title { get; set; }

    /// <summary>Gets or sets the URL-friendly slug.</summary>
    public required string Slug { get; set; }

    /// <summary>Gets or sets the Markdown content of the post.</summary>
    public required string Content { get; set; }

    /// <summary>Gets or sets a brief summary for listings.</summary>
    public required string Summary { get; set; }

    /// <summary>Gets or sets the author's user ID.</summary>
    public Guid AuthorId { get; set; }

    /// <summary>Gets or sets when the post was created.</summary>
    public DateTime CreatedAtUtc { get; set; }

    /// <summary>Gets or sets when the post was last updated.</summary>
    public DateTime UpdatedAtUtc { get; set; }

    /// <summary>Gets or sets when the post was published (null if draft).</summary>
    public DateTime? PublishedAtUtc { get; set; }

    /// <summary>Gets or sets whether the post is publicly visible.</summary>
    public bool IsPublished { get; set; }

    /// <summary>Navigation property for the author.</summary>
    public User? Author { get; set; }

    /// <summary>Navigation property for attached images.</summary>
    public ICollection<Image> Images { get; set; } = [];
}


================================================================================
FILE: src/MyBlog.Core/Models/PostDto.cs
SIZE: .95 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

namespace MyBlog.Core.Models;

/// <summary>Data transfer object for post listings.</summary>
public sealed record PostListItemDto(
    Guid Id,
    string Title,
    string Slug,
    string Summary,
    string AuthorDisplayName,
    DateTime? PublishedAtUtc,
    bool IsPublished);

/// <summary>Data transfer object for creating a new post.</summary>
public sealed record CreatePostDto(
    string Title,
    string Content,
    string Summary,
    bool IsPublished);

/// <summary>Data transfer object for updating a post.</summary>
public sealed record UpdatePostDto(
    string Title,
    string Content,
    string Summary,
    bool IsPublished);

/// <summary>Data transfer object for post details.</summary>
public sealed record PostDetailDto(
    Guid Id,
    string Title,
    string Slug,
    string Content,
    string Summary,
    string AuthorDisplayName,
    DateTime CreatedAtUtc,
    DateTime UpdatedAtUtc,
    DateTime? PublishedAtUtc,
    bool IsPublished);


================================================================================
FILE: src/MyBlog.Core/Models/TelemetryLog.cs
SIZE: 1.17 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

namespace MyBlog.Core.Models;

/// <summary>
/// Represents a telemetry log entry stored in the database.
/// </summary>
public sealed class TelemetryLog
{
    /// <summary>Gets or sets the auto-increment primary key.</summary>
    public int Id { get; set; }

    /// <summary>Gets or sets the UTC timestamp of the log entry.</summary>
    public DateTime TimestampUtc { get; set; }

    /// <summary>Gets or sets the log level (Information, Warning, Error, etc.).</summary>
    public required string Level { get; set; }

    /// <summary>Gets or sets the category/source of the log.</summary>
    public required string Category { get; set; }

    /// <summary>Gets or sets the log message.</summary>
    public required string Message { get; set; }

    /// <summary>Gets or sets the exception details if any.</summary>
    public string? Exception { get; set; }

    /// <summary>Gets or sets the distributed trace ID.</summary>
    public string? TraceId { get; set; }

    /// <summary>Gets or sets the span ID within the trace.</summary>
    public string? SpanId { get; set; }

    /// <summary>Gets or sets additional properties as JSON.</summary>
    public string? Properties { get; set; }
}


================================================================================
FILE: src/MyBlog.Core/Models/User.cs
SIZE: 1.12 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

namespace MyBlog.Core.Models;

/// <summary>
/// Represents a user who can create and manage blog posts.
/// </summary>
public sealed class User
{
    /// <summary>Gets or sets the unique identifier for the user.</summary>
    public Guid Id { get; set; }

    /// <summary>Gets or sets the unique username for authentication.</summary>
    public required string Username { get; set; }

    /// <summary>Gets or sets the hashed password.</summary>
    public required string PasswordHash { get; set; }

    /// <summary>Gets or sets the user's email address.</summary>
    public required string Email { get; set; }

    /// <summary>Gets or sets the display name shown on posts.</summary>
    public required string DisplayName { get; set; }

    /// <summary>Gets or sets when the user account was created.</summary>
    public DateTime CreatedAtUtc { get; set; }

    /// <summary>Navigation property for posts authored by this user.</summary>
    public ICollection<Post> Posts { get; set; } = [];

    /// <summary>Navigation property for images uploaded by this user.</summary>
    public ICollection<Image> UploadedImages { get; set; } = [];
}


================================================================================
FILE: src/MyBlog.Core/MyBlog.Core.csproj
SIZE: .21 KB
MODIFIED: 2026-01-20 09:10:15
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>MyBlog.Core</RootNamespace>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Logging" />
  </ItemGroup>
</Project>


================================================================================
FILE: src/MyBlog.Core/Services/MarkdownService.cs
SIZE: 8.51 KB
MODIFIED: 2026-01-20 09:11:02
================================================================================

using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using Microsoft.Extensions.Logging;
using MyBlog.Core.Interfaces;

namespace MyBlog.Core.Services;

/// <summary>
/// Custom Markdown parser that converts Markdown text to HTML.
/// Supports: headings, bold, italic, links, images, code blocks, blockquotes, lists, horizontal rules.
/// </summary>
public sealed partial class MarkdownService(
    IImageDimensionService imageDimensionService,
    ILogger<MarkdownService>? logger = null)
    : IMarkdownService
{
    private enum ListType { None, Unordered, Ordered }

    /// <inheritdoc />
    public async Task<string> ToHtmlAsync(string markdown)
    {
        if (string.IsNullOrWhiteSpace(markdown))
        {
            return string.Empty;
        }

        var lines = markdown.Replace("\r\n", "\n").Split('\n');
        var result = new StringBuilder();
        var inCodeBlock = false;
        var currentListType = ListType.None;
        var codeBlockContent = new StringBuilder();

        foreach (var rawLine in lines)
        {
            var line = rawLine;

            // Handle fenced code blocks
            if (line.StartsWith("```"))
            {
                if (inCodeBlock)
                {
                    result.Append("<pre><code>");
                    result.Append(HttpUtility.HtmlEncode(codeBlockContent.ToString().TrimEnd()));
                    result.AppendLine("</code></pre>");
                    codeBlockContent.Clear();
                    inCodeBlock = false;
                }
                else
                {
                    result.Append(CloseList(ref currentListType));
                    inCodeBlock = true;
                }
                continue;
            }

            if (inCodeBlock)
            {
                codeBlockContent.AppendLine(line);
                continue;
            }

            // Handle horizontal rules
            if (HorizontalRulePattern().IsMatch(line))
            {
                result.Append(CloseList(ref currentListType));
                result.AppendLine("<hr />");
                continue;
            }

            // Handle headings
            var headingMatch = HeadingPattern().Match(line);
            if (headingMatch.Success)
            {
                result.Append(CloseList(ref currentListType));
                var level = headingMatch.Groups[1].Value.Length;
                var text = await ProcessInlineAsync(headingMatch.Groups[2].Value);
                result.AppendLine($"<h{level}>{text}</h{level}>");
                continue;
            }

            // Handle blockquotes
            if (line.StartsWith("> "))
            {
                result.Append(CloseList(ref currentListType));
                var quoteText = await ProcessInlineAsync(line[2..]);
                result.AppendLine($"<blockquote><p>{quoteText}</p></blockquote>");
                continue;
            }

            // Handle unordered lists
            var unorderedMatch = UnorderedListPattern().Match(line);
            if (unorderedMatch.Success)
            {
                if (currentListType != ListType.Unordered)
                {
                    result.Append(CloseList(ref currentListType));
                    result.AppendLine("<ul>");
                    currentListType = ListType.Unordered;
                }
                var itemText = await ProcessInlineAsync(unorderedMatch.Groups[1].Value);
                result.AppendLine($"<li>{itemText}</li>");
                continue;
            }

            // Handle ordered lists
            var orderedMatch = OrderedListPattern().Match(line);
            if (orderedMatch.Success)
            {
                if (currentListType != ListType.Ordered)
                {
                    result.Append(CloseList(ref currentListType));
                    result.AppendLine("<ol>");
                    currentListType = ListType.Ordered;
                }
                var itemText = await ProcessInlineAsync(orderedMatch.Groups[1].Value);
                result.AppendLine($"<li>{itemText}</li>");
                continue;
            }

            // Close list if no longer in list item
            if (currentListType != ListType.None && !string.IsNullOrWhiteSpace(line))
            {
                result.Append(CloseList(ref currentListType));
            }

            // Handle empty lines
            if (string.IsNullOrWhiteSpace(line))
            {
                result.Append(CloseList(ref currentListType));
                continue;
            }

            // Regular paragraph
            var paragraphText = await ProcessInlineAsync(line);
            result.AppendLine($"<p>{paragraphText}</p>");
        }

        // Close any open list
        result.Append(CloseList(ref currentListType));

        // Close any unclosed code block
        if (inCodeBlock)
        {
            result.Append("<pre><code>");
            result.Append(HttpUtility.HtmlEncode(codeBlockContent.ToString().TrimEnd()));
            result.AppendLine("</code></pre>");
        }

        return result.ToString();
    }

    private static string CloseList(ref ListType listType)
    {
        var result = listType switch
        {
            ListType.Unordered => "</ul>\n",
            ListType.Ordered => "</ol>\n",
            _ => ""
        };
        listType = ListType.None;
        return result;
    }

    private async Task<string> ProcessInlineAsync(string text)
    {
        // Escape HTML first
        text = HttpUtility.HtmlEncode(text);

        // Process inline code
        text = InlineCodePattern().Replace(text, "<code>$1</code>");

        // Process images ![alt](url) -> WITH AUTOMATED DIMENSION LOOKUP
        // Regex replacement doesn't support async, so we find matches, process them, and replace.
        var matches = ImagePattern().Matches(text);
        if (matches.Count > 0)
        {
            // Process matches in reverse to avoid index drift
            for (var i = matches.Count - 1; i >= 0; i--)
            {
                var match = matches[i];
                var alt = match.Groups[1].Value;
                var url = match.Groups[2].Value;

                string imgTag;
                try
                {
                    // Lookup dimensions (Fast DB check or background fetch)
                    // This is wrapped in try-catch to ensure we never fail rendering
                    var dimensions = await imageDimensionService.GetDimensionsAsync(url);

                    imgTag = dimensions.HasValue ? $"<img src=\"{url}\" alt=\"{alt}\" width=\"{dimensions.Value.Width}\" height=\"{dimensions.Value.Height}\" />" :
                        // No dimensions available - render without width/height
                        $"<img src=\"{url}\" alt=\"{alt}\" />";
                }
                catch (Exception ex)
                {
                    // If dimension lookup fails for any reason, still render the image
                    logger?.LogWarning(ex, "Failed to get dimensions for image {Url}. Rendering without dimensions.", url);
                    imgTag = $"<img src=\"{url}\" alt=\"{alt}\" />";
                }

                // Replace the Markdown syntax with the HTML tag
                text = text.Remove(match.Index, match.Length).Insert(match.Index, imgTag);
            }
        }

        // Process links
        text = LinkPattern().Replace(text, "<a href=\"$2\">$1</a>");

        // Process bold
        text = BoldPattern().Replace(text, "<strong>$1</strong>");

        // Process italic
        text = ItalicPattern().Replace(text, "<em>$1</em>");

        return text;
    }

    [GeneratedRegex(@"^(#{1,6})\s+(.+)$")]
    private static partial Regex HeadingPattern();

    [GeneratedRegex(@"^[-*]\s+(.+)$")]
    private static partial Regex UnorderedListPattern();

    [GeneratedRegex(@"^\d+\.\s+(.+)$")]
    private static partial Regex OrderedListPattern();

    [GeneratedRegex(@"^[-*_]{3,}\s*$")]
    private static partial Regex HorizontalRulePattern();

    [GeneratedRegex(@"`([^`]+)`")]
    private static partial Regex InlineCodePattern();

    // Standard Markdown image pattern: ![alt](url)
    [GeneratedRegex(@"!\[([^\]]*)\]\(([^)]+)\)")]
    private static partial Regex ImagePattern();

    [GeneratedRegex(@"\[([^\]]+)\]\(([^)]+)\)")]
    private static partial Regex LinkPattern();

    [GeneratedRegex(@"\*\*([^*]+)\*\*|__([^_]+)__")]
    private static partial Regex BoldPattern();

    [GeneratedRegex(@"(?<!\*)\*(?!\*)([^*]+)(?<!\*)\*(?!\*)|(?<!_)_(?!_)([^_]+)(?<!_)_(?!_)")]
    private static partial Regex ItalicPattern();
}


================================================================================
FILE: src/MyBlog.Core/Services/SlugService.cs
SIZE: 1.73 KB
MODIFIED: 2026-01-19 19:46:10
================================================================================

using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using MyBlog.Core.Interfaces;

namespace MyBlog.Core.Services;

/// <summary>
/// Generates URL-friendly slugs from text.
/// </summary>
public sealed partial class SlugService : ISlugService
{
    /// <inheritdoc />
    public string GenerateSlugOrUuid(string title)
    {
        var slug = GenerateSlug(title);

        return !string.IsNullOrWhiteSpace(slug) ? slug : $"post-{Guid.CreateVersion7().ToString()}";
    }

    private string GenerateSlug(string title)
    {
        // Normalize unicode and convert to lowercase
        var normalized = title.Normalize(NormalizationForm.FormD);
        var sb = new StringBuilder();

        foreach (var c in normalized)
        {
            var category = CharUnicodeInfo.GetUnicodeCategory(c);
            if (category != UnicodeCategory.NonSpacingMark)
            {
                sb.Append(c);
            }
        }

        var result = sb.ToString().Normalize(NormalizationForm.FormC).ToLowerInvariant();

        // Replace spaces and underscores with hyphens
        result = SpacePattern().Replace(result, "-");

        // Remove all non-alphanumeric characters except hyphens
        result = NonAlphanumericPattern().Replace(result, "");

        // Replace multiple hyphens with single hyphen
        result = MultipleHyphenPattern().Replace(result, "-");

        // Trim hyphens from ends
        result = result.Trim('-');

        return result;
    }

    [GeneratedRegex(@"[\s_]+")]
    private static partial Regex SpacePattern();

    [GeneratedRegex(@"[^a-z0-9\-]")]
    private static partial Regex NonAlphanumericPattern();

    [GeneratedRegex(@"-+")]
    private static partial Regex MultipleHyphenPattern();
}


================================================================================
FILE: src/MyBlog.Infrastructure/Data/BlogDbContext.cs
SIZE: 3.53 KB
MODIFIED: 2026-01-16 21:38:47
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Data;

/// <summary>
/// Entity Framework Core database context for the blog.
/// </summary>
public sealed class BlogDbContext : DbContext
{
    /// <summary>Initializes a new instance of the BlogDbContext.</summary>
    public BlogDbContext(DbContextOptions<BlogDbContext> options) : base(options)
    {
    }

    /// <summary>Gets or sets the Users table.</summary>
    public DbSet<User> Users => Set<User>();
    /// <summary>Gets or sets the Posts table.</summary>
    public DbSet<Post> Posts => Set<Post>();
    /// <summary>Gets or sets the Images table.</summary>
    public DbSet<Image> Images => Set<Image>();
    /// <summary>Gets or sets the TelemetryLogs table.</summary>
    public DbSet<TelemetryLog> TelemetryLogs => Set<TelemetryLog>();
    /// <summary>Gets or sets the Image Dimension Cache table.</summary>
    public DbSet<ImageDimensionCache> ImageDimensionCache => Set<ImageDimensionCache>();

    /// <inheritdoc />
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // User configuration
        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Username).HasMaxLength(50).IsRequired();
            entity.HasIndex(e => e.Username).IsUnique();
            entity.Property(e => e.PasswordHash).HasMaxLength(256).IsRequired();
            entity.Property(e => e.Email).HasMaxLength(256).IsRequired();
            entity.Property(e => e.DisplayName).HasMaxLength(100).IsRequired();
        });

        // Post configuration
        modelBuilder.Entity<Post>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Title).HasMaxLength(200).IsRequired();
            entity.Property(e => e.Slug).HasMaxLength(200).IsRequired();
            entity.HasIndex(e => e.Slug).IsUnique();
            entity.Property(e => e.Summary).HasMaxLength(500).IsRequired();
            entity.HasOne(e => e.Author)
                .WithMany(u => u.Posts)
                .HasForeignKey(e => e.AuthorId)
                .OnDelete(DeleteBehavior.Restrict);
        });

        // Image configuration
        modelBuilder.Entity<Image>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.FileName).HasMaxLength(256).IsRequired();
            entity.Property(e => e.ContentType).HasMaxLength(100).IsRequired();
            entity.HasOne(e => e.Post)
                .WithMany(p => p.Images)
                .HasForeignKey(e => e.PostId)
                .OnDelete(DeleteBehavior.SetNull);
            entity.HasOne(e => e.UploadedBy)
                .WithMany(u => u.UploadedImages)
                .HasForeignKey(e => e.UploadedByUserId)
                .OnDelete(DeleteBehavior.Restrict);
        });

        // TelemetryLog configuration
        modelBuilder.Entity<TelemetryLog>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Id).ValueGeneratedOnAdd();
            entity.Property(e => e.Level).HasMaxLength(20).IsRequired();
            entity.Property(e => e.Category).HasMaxLength(256).IsRequired();
            entity.HasIndex(e => e.TimestampUtc);
        });

        // ImageDimensionCache configuration
        modelBuilder.Entity<ImageDimensionCache>(entity =>
        {
            entity.HasKey(e => e.Url); // URL is the primary key
            entity.Property(e => e.Url).HasMaxLength(2048); // Support long URLs
        });
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Data/DatabasePathResolver.cs
SIZE: 1.90 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

namespace MyBlog.Infrastructure.Data;

/// <summary>
/// Resolves the database file path following XDG conventions.
/// </summary>
public static class DatabasePathResolver
{
    /// <summary>
    /// Gets the path for the SQLite database file.
    /// Priority: XDG_DATA_HOME > Platform-specific > Local fallback
    /// </summary>
    public static string GetDatabasePath()
    {
        var dataDir = GetDataDirectory();
        Directory.CreateDirectory(dataDir);
        return Path.Combine(dataDir, "myblog.db");
    }

    /// <summary>
    /// Gets the data directory following platform conventions.
    /// </summary>
    public static string GetDataDirectory()
    {
        string baseDir;

        if (OperatingSystem.IsWindows())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        }
        else if (OperatingSystem.IsMacOS())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        }
        else
        {
            // Linux/Unix: Use XDG_DATA_HOME or fallback
            var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
            baseDir = !string.IsNullOrEmpty(xdgDataHome)
                ? xdgDataHome
                : Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".local", "share");
        }

        // If we can't write to the preferred location, use local directory
        var preferredDir = Path.Combine(baseDir, "MyBlog");
        try
        {
            Directory.CreateDirectory(preferredDir);
            var testFile = Path.Combine(preferredDir, ".write-test");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return preferredDir;
        }
        catch
        {
            // Fallback to local directory
            return Path.Combine(AppContext.BaseDirectory, "data");
        }
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/MyBlog.Infrastructure.csproj
SIZE: .50 KB
MODIFIED: 2026-01-16 21:56:40
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>MyBlog.Infrastructure</RootNamespace>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" />
    <PackageReference Include="Microsoft.AspNetCore.Identity" />
    <PackageReference Include="Microsoft.Extensions.Http" />
    <PackageReference Include="OpenTelemetry" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\MyBlog.Core\MyBlog.Core.csproj" />
  </ItemGroup>
</Project>


================================================================================
FILE: src/MyBlog.Infrastructure/Repositories/ImageRepository.cs
SIZE: 1.61 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the image repository.
/// </summary>
public sealed class ImageRepository : IImageRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of ImageRepository.</summary>
    public ImageRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<Image>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _context.Images
            .AsNoTracking()
            .OrderByDescending(i => i.UploadedAtUtc)
            .ToListAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Image?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.Images.FindAsync([id], cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Image> CreateAsync(Image image, CancellationToken cancellationToken = default)
    {
        _context.Images.Add(image);
        await _context.SaveChangesAsync(cancellationToken);
        return image;
    }

    /// <inheritdoc />
    public async Task DeleteAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var image = await _context.Images.FindAsync([id], cancellationToken);
        if (image is not null)
        {
            _context.Images.Remove(image);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Repositories/PostRepository.cs
SIZE: 5.01 KB
MODIFIED: 2026-01-14 19:57:11
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the post repository.
/// </summary>
public sealed class PostRepository : IPostRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of PostRepository.</summary>
    public PostRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task<(IReadOnlyList<PostListItemDto> Posts, int TotalCount)> GetPublishedPostsAsync(
        int page, int pageSize, CancellationToken cancellationToken = default)
    {
        var query = _context.Posts
            .AsNoTracking()
            .Where(p => p.IsPublished)
            .OrderByDescending(p => p.PublishedAtUtc);

        var totalCount = await query.CountAsync(cancellationToken);

        var posts = await query
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .Include(p => p.Author)
            .Select(p => new PostListItemDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Summary,
                p.Author!.DisplayName,
                p.PublishedAtUtc,
                p.IsPublished))
            .ToListAsync(cancellationToken);

        return (posts, totalCount);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<PostListItemDto>> GetAllPostsAsync(
        CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .AsNoTracking()
            .OrderByDescending(p => p.UpdatedAtUtc)
            .Include(p => p.Author)
            .Select(p => new PostListItemDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Summary,
                p.Author!.DisplayName,
                p.PublishedAtUtc,
                p.IsPublished))
            .ToListAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<PostDetailDto?> GetBySlugAsync(
        string slug, CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .AsNoTracking()
            .Where(p => p.Slug == slug)
            .Include(p => p.Author)
            .Select(p => new PostDetailDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Content,
                p.Summary,
                p.Author!.DisplayName,
                p.CreatedAtUtc,
                p.UpdatedAtUtc,
                p.PublishedAtUtc,
                p.IsPublished))
            .FirstOrDefaultAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Post?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .Include(p => p.Author)
            .FirstOrDefaultAsync(p => p.Id == id, cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Post> CreateAsync(Post post, CancellationToken cancellationToken = default)
    {
        _context.Posts.Add(post);
        await _context.SaveChangesAsync(cancellationToken);
        return post;
    }

    /// <inheritdoc />
    public async Task UpdateAsync(Post post, CancellationToken cancellationToken = default)
    {
        _context.Posts.Update(post);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task DeleteAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var post = await _context.Posts.FindAsync([id], cancellationToken);
        if (post is not null)
        {
            _context.Posts.Remove(post);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }

    /// <inheritdoc />
    public async Task<int> GetCountAsync(CancellationToken cancellationToken = default)
    {
        return await _context.Posts.CountAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<PostListItemDto>> GetRecentPostsAsync(
        int count, CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .AsNoTracking()
            .OrderByDescending(p => p.UpdatedAtUtc)
            .Take(count)
            .Include(p => p.Author)
            .Select(p => new PostListItemDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Summary,
                p.Author!.DisplayName,
                p.PublishedAtUtc,
                p.IsPublished))
            .ToListAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<bool> IsSlugTakenAsync(string slug, Guid? excludePostId = null, CancellationToken cancellationToken = default)
    {
        if (excludePostId.HasValue)
        {
            return await _context.Posts
                .AnyAsync(p => p.Slug == slug && p.Id != excludePostId.Value, cancellationToken);
        }

        return await _context.Posts
            .AnyAsync(p => p.Slug == slug, cancellationToken);
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Repositories/TelemetryLogRepository.cs
SIZE: 1.43 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the telemetry log repository.
/// </summary>
public sealed class TelemetryLogRepository : ITelemetryLogRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of TelemetryLogRepository.</summary>
    public TelemetryLogRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task WriteAsync(TelemetryLog log, CancellationToken cancellationToken = default)
    {
        _context.TelemetryLogs.Add(log);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<int> DeleteOlderThanAsync(
        DateTime cutoffUtc, CancellationToken cancellationToken = default)
    {
        return await _context.TelemetryLogs
            .Where(l => l.TimestampUtc < cutoffUtc)
            .ExecuteDeleteAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<TelemetryLog>> GetRecentAsync(
        int count, CancellationToken cancellationToken = default)
    {
        return await _context.TelemetryLogs
            .AsNoTracking()
            .OrderByDescending(l => l.TimestampUtc)
            .Take(count)
            .ToListAsync(cancellationToken);
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Repositories/UserRepository.cs
SIZE: 2.05 KB
MODIFIED: 2025-12-30 21:28:12
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// SQLite implementation of the user repository.
/// </summary>
public sealed class UserRepository : IUserRepository
{
    private readonly BlogDbContext _context;

    public UserRepository(BlogDbContext context) => _context = context;

    /// <inheritdoc />
    public async Task<User?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
        => await _context.Users.FirstOrDefaultAsync(u => u.Id == id, cancellationToken);

    /// <inheritdoc />
    public async Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default)
        => await _context.Users.FirstOrDefaultAsync(
            u => u.Username.ToLower() == username.ToLower(), cancellationToken);

    /// <inheritdoc />
    public async Task<IReadOnlyList<User>> GetAllAsync(CancellationToken cancellationToken = default)
        => await _context.Users.OrderBy(u => u.Username).ToListAsync(cancellationToken);

    /// <inheritdoc />
    public async Task<bool> AnyUsersExistAsync(CancellationToken cancellationToken = default)
        => await _context.Users.AnyAsync(cancellationToken);

    /// <inheritdoc />
    public async Task CreateAsync(User user, CancellationToken cancellationToken = default)
    {
        _context.Users.Add(user);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task UpdateAsync(User user, CancellationToken cancellationToken = default)
    {
        _context.Users.Update(user);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task DeleteAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var user = await _context.Users.FindAsync([id], cancellationToken);
        if (user is not null)
        {
            _context.Users.Remove(user);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/ServiceCollectionExtensions.cs
SIZE: 2.32 KB
MODIFIED: 2026-01-20 09:14:25
================================================================================

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Services;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;

namespace MyBlog.Infrastructure;

/// <summary>
/// Extension methods for registering infrastructure services.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Adds infrastructure services to the DI container.
    /// </summary>
    public static IServiceCollection AddInfrastructure(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Database
        var connectionString = configuration.GetConnectionString("DefaultConnection");
        if (string.IsNullOrEmpty(connectionString) || connectionString == "Data Source=myblog.db")
        {
            // Use XDG-compliant path
            var dbPath = DatabasePathResolver.GetDatabasePath();
            connectionString = $"Data Source={dbPath}";
        }

        services.AddDbContext<BlogDbContext>(options =>
            options.UseSqlite(connectionString));

        // Repositories
        services.AddScoped<IPostRepository, PostRepository>();
        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IImageRepository, ImageRepository>();
        services.AddScoped<ITelemetryLogRepository, TelemetryLogRepository>();

        // Services
        services.AddSingleton<IPasswordService, PasswordService>();
        services.AddSingleton<ISlugService, SlugService>();

        // MarkdownService is Scoped because it depends on Scoped IImageDimensionService
        services.AddScoped<IMarkdownService, MarkdownService>();
        services.AddScoped<IAuthService, AuthService>();

        services.AddSingleton<IReaderTrackingService, ReaderTrackingService>();

        // Image Dimension Service (With HttpClient for fetching image headers)
        services.AddHttpClient<IImageDimensionService, ImageDimensionService>();

        // Background services
        services.AddHostedService<TelemetryCleanupService>();
        // Cache Warmer - runs on startup to pre-fetch dimensions for existing images
        services.AddHostedService<ImageCacheWarmerService>();

        return services;
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Services/AuthService.cs
SIZE: 3.21 KB
MODIFIED: 2025-12-28 11:33:37
================================================================================

using Microsoft.Extensions.Configuration;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Authentication service implementation.
/// </summary>
public sealed class AuthService : IAuthService
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordService _passwordService;
    private readonly IConfiguration _configuration;

    /// <summary>Initializes a new instance of AuthService.</summary>
    public AuthService(
        IUserRepository userRepository,
        IPasswordService passwordService,
        IConfiguration configuration)
    {
        _userRepository = userRepository;
        _passwordService = passwordService;
        _configuration = configuration;
    }

    /// <inheritdoc />
    public async Task<User?> AuthenticateAsync(
        string username, string password, CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByUsernameAsync(username, cancellationToken);
        if (user is null)
        {
            return null;
        }

        return _passwordService.VerifyPassword(user.PasswordHash, password) ? user : null;
    }

    /// <inheritdoc />
    public async Task EnsureAdminUserAsync(CancellationToken cancellationToken = default)
    {
        if (await _userRepository.AnyUsersExistAsync(cancellationToken))
        {
            return;
        }

        var defaultPassword = Environment.GetEnvironmentVariable("MYBLOG_ADMIN_PASSWORD")
            ?? _configuration["Authentication:DefaultAdminPassword"]
            ?? "ChangeMe123!";

        var admin = new User
        {
            Id = Guid.NewGuid(),
            Username = "admin",
            PasswordHash = _passwordService.HashPassword(defaultPassword),
            Email = "admin@localhost",
            DisplayName = "Administrator",
            CreatedAtUtc = DateTime.UtcNow
        };

        await _userRepository.CreateAsync(admin, cancellationToken);
    }

    /// <inheritdoc />
    public async Task<bool> ChangePasswordAsync(
        Guid userId,
        string currentPassword,
        string newPassword,
        CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
        if (user is null)
        {
            return false;
        }

        // Verify current password
        if (!_passwordService.VerifyPassword(user.PasswordHash, currentPassword))
        {
            return false;
        }

        // Update to new password
        user.PasswordHash = _passwordService.HashPassword(newPassword);
        await _userRepository.UpdateAsync(user, cancellationToken);

        return true;
    }

    /// <inheritdoc />
    public async Task ResetPasswordAsync(
        Guid userId,
        string newPassword,
        CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
        if (user is null)
        {
            throw new InvalidOperationException($"User with ID {userId} not found.");
        }

        user.PasswordHash = _passwordService.HashPassword(newPassword);
        await _userRepository.UpdateAsync(user, cancellationToken);
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Services/ImageCacheWarmerService.cs
SIZE: 5.99 KB
MODIFIED: 2026-01-20 09:14:25
================================================================================

using System.Text.RegularExpressions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using MyBlog.Core.Interfaces;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Background service that warms the image dimension cache on startup.
/// Scans all posts for images and pre-fetches their dimensions.
/// This automates the fix for "past" images.
/// </summary>
public sealed class ImageCacheWarmerService : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<ImageCacheWarmerService> _logger;

    public ImageCacheWarmerService(
        IServiceScopeFactory scopeFactory,
        ILogger<ImageCacheWarmerService> logger)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Give the app time to fully start up
        await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);

        _logger.LogInformation("Image Cache Warmer started. Scanning posts for uncached images...");

        try
        {
            using var scope = _scopeFactory.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<BlogDbContext>();
            var dimService = scope.ServiceProvider.GetRequiredService<IImageDimensionService>();

            // Check if the ImageDimensionCache table exists
            if (!await TableExistsAsync(db, stoppingToken))
            {
                _logger.LogWarning("Image Cache Warmer: ImageDimensionCache table does not exist. " +
                    "Please apply database migrations. Skipping cache warming.");
                return;
            }

            // Get all posts
            var posts = await db.Posts
                .Select(p => p.Content)
                .ToListAsync(stoppingToken);

            var regex = new Regex(@"!\[([^\]]*)\]\(([^)]+)\)");
            var distinctUrls = new HashSet<string>();

            // 1. Extract all URLs from all posts
            foreach (var content in posts)
            {
                if (string.IsNullOrEmpty(content))
                {
                    continue;
                }

                var matches = regex.Matches(content);
                foreach (Match match in matches)
                {
                    distinctUrls.Add(match.Groups[2].Value);
                }
            }

            // 2. Filter out ones we already have
            HashSet<string> existingSet;
            try
            {
                var existingCache = await db.ImageDimensionCache
                    .Select(x => x.Url)
                    .ToListAsync(stoppingToken);
                existingSet = new HashSet<string>(existingCache);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Image Cache Warmer: Could not read existing cache. Will attempt to cache all URLs.");
                existingSet = new HashSet<string>();
            }

            var missingUrls = distinctUrls.Where(u => !existingSet.Contains(u)).ToList();

            if (missingUrls.Count == 0)
            {
                _logger.LogInformation("Image Cache Warmer: All images are already cached.");
                return;
            }

            _logger.LogInformation("Image Cache Warmer: Found {Count} uncached images. Fetching dimensions...", missingUrls.Count);

            // 3. Process missing (in parallel but throttled)
            var successCount = 0;
            var failCount = 0;

            foreach (var url in missingUrls.TakeWhile(_ => !stoppingToken.IsCancellationRequested))
            {
                try
                {
                    // Calling GetDimensionsAsync triggers the logic to fetch and save to DB
                    var dimensions = await dimService.GetDimensionsAsync(url, stoppingToken);
                    if (dimensions.HasValue)
                    {
                        _logger.LogDebug("Cached dimensions for: {Url} ({Width}x{Height})",
                            url, dimensions.Value.Width, dimensions.Value.Height);
                        successCount++;
                    }
                    else
                    {
                        _logger.LogDebug("Could not resolve dimensions for: {Url}", url);
                        failCount++;
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogDebug(ex, "Error warming cache for {Url}", url);
                    failCount++;
                }

                // Be gentle on remote servers
                await Task.Delay(100, stoppingToken);
            }

            _logger.LogInformation("Image Cache Warmer completed. Cached: {Success}, Failed: {Failed}",
                successCount, failCount);
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Image Cache Warmer was cancelled.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in Image Cache Warmer. This is non-fatal - the blog will continue to work without cached dimensions.");
        }
    }

    /// <summary>
    /// Checks if the ImageDimensionCache table exists in the database.
    /// </summary>
    private static async Task<bool> TableExistsAsync(BlogDbContext db, CancellationToken ct)
    {
        try
        {
            var connection = db.Database.GetDbConnection();
            if (connection.State != System.Data.ConnectionState.Open)
            {
                await connection.OpenAsync(ct);
            }

            using var command = connection.CreateCommand();
            command.CommandText = "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='ImageDimensionCache'";
            var result = await command.ExecuteScalarAsync(ct);
            return Convert.ToInt64(result) > 0;
        }
        catch
        {
            return false;
        }
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Services/ImageDimensionService.cs
SIZE: 11.51 KB
MODIFIED: 2026-01-20 09:11:48
================================================================================

using System.Buffers.Binary;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Services;

public sealed class ImageDimensionService : IImageDimensionService
{
    private readonly HttpClient _httpClient;
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<ImageDimensionService> _logger;

    public ImageDimensionService(
        HttpClient httpClient,
        IServiceScopeFactory scopeFactory,
        ILogger<ImageDimensionService> logger)
    {
        _httpClient = httpClient;
        _scopeFactory = scopeFactory;
        _logger = logger;
        _httpClient.Timeout = TimeSpan.FromSeconds(5);
        _httpClient.DefaultRequestHeaders.UserAgent.ParseAdd("MyBlog/1.0");
    }

    public async Task<(int Width, int Height)?> GetDimensionsAsync(string url, CancellationToken cancellationToken = default)
    {
        // 1. Check Cache (with graceful error handling for missing table)
        try
        {
            using var scope = _scopeFactory.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<BlogDbContext>();

            // Check if table exists before querying
            if (await TableExistsAsync(db, cancellationToken))
            {
                var cached = await db.ImageDimensionCache.FindAsync([url], cancellationToken);
                if (cached != null)
                {
                    return (cached.Width, cached.Height);
                }
            }
        }
        catch (Exception ex)
        {
            // Log but don't fail - cache is optional
            _logger.LogWarning(ex, "Failed to check image dimension cache for {Url}. Continuing without cache.", url);
        }

        // 2. Fetch if missing
        try
        {
            var dimensions = await FetchDimensionsFromNetworkAsync(url, cancellationToken);

            if (dimensions.HasValue)
            {
                // 3. Update Cache (with graceful error handling)
                try
                {
                    using var scope = _scopeFactory.CreateScope();
                    var db = scope.ServiceProvider.GetRequiredService<BlogDbContext>();

                    if (await TableExistsAsync(db, cancellationToken))
                    {
                        // Double check to prevent race conditions
                        if (!await db.ImageDimensionCache.AnyAsync(x => x.Url == url, cancellationToken))
                        {
                            db.ImageDimensionCache.Add(new ImageDimensionCache
                            {
                                Url = url,
                                Width = dimensions.Value.Width,
                                Height = dimensions.Value.Height,
                                LastCheckedUtc = DateTime.UtcNow
                            });
                            await db.SaveChangesAsync(cancellationToken);
                        }
                    }
                }
                catch (Exception ex)
                {
                    // Log but don't fail - caching is optional
                    _logger.LogWarning(ex, "Failed to cache image dimensions for {Url}. Dimensions were resolved but not cached.", url);
                }

                return dimensions;
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to resolve dimensions for {Url}", url);
        }

        return null;
    }

    /// <summary>
    /// Checks if the ImageDimensionCache table exists in the database.
    /// </summary>
    private static async Task<bool> TableExistsAsync(BlogDbContext db, CancellationToken ct)
    {
        try
        {
            // For SQLite, check sqlite_master
            var connection = db.Database.GetDbConnection();
            if (connection.State != System.Data.ConnectionState.Open)
            {
                await connection.OpenAsync(ct);
            }

            using var command = connection.CreateCommand();
            command.CommandText = "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='ImageDimensionCache'";
            var result = await command.ExecuteScalarAsync(ct);
            return Convert.ToInt64(result) > 0;
        }
        catch
        {
            return false;
        }
    }

    private async Task<(int Width, int Height)?> FetchDimensionsFromNetworkAsync(string url, CancellationToken ct)
    {
        using var response = await _httpClient.GetAsync(url, HttpCompletionOption.ResponseHeadersRead, ct);
        response.EnsureSuccessStatusCode();

        using var stream = await response.Content.ReadAsStreamAsync(ct);
        var buffer = new byte[32];
        var bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length, ct);

        if (bytesRead < 8)
        {
            return null;
        }

        if (IsPng(buffer))
        {
            // PNG: Width at bytes 16-19, Height at bytes 20-23 (big-endian)
            if (bytesRead >= 24)
            {
                var width = BinaryPrimitives.ReadInt32BigEndian(buffer.AsSpan(16, 4));
                var height = BinaryPrimitives.ReadInt32BigEndian(buffer.AsSpan(20, 4));
                return (width, height);
            }
        }
        else if (IsGif(buffer))
        {
            // GIF: Width at bytes 6-7, Height at bytes 8-9 (little-endian)
            if (bytesRead >= 10)
            {
                var width = BinaryPrimitives.ReadInt16LittleEndian(buffer.AsSpan(6, 2));
                var height = BinaryPrimitives.ReadInt16LittleEndian(buffer.AsSpan(8, 2));
                return (width, height);
            }
        }
        else if (IsJpeg(buffer))
        {
            // JPEG requires scanning for SOF marker - more complex
            return await ParseJpegDimensionsAsync(stream, buffer, ct);
        }
        else if (IsWebP(buffer))
        {
            // WebP: Check for VP8 or VP8L chunk
            return await ParseWebPDimensionsAsync(stream, buffer, bytesRead, ct);
        }

        return null;
    }

    private static bool IsPng(ReadOnlySpan<byte> buffer) =>
        buffer.Length >= 8 &&
        buffer[0] == 0x89 && buffer[1] == 0x50 && buffer[2] == 0x4E && buffer[3] == 0x47 &&
        buffer[4] == 0x0D && buffer[5] == 0x0A && buffer[6] == 0x1A && buffer[7] == 0x0A;

    private static bool IsGif(ReadOnlySpan<byte> buffer) =>
        buffer.Length >= 6 &&
        buffer[0] == 0x47 && buffer[1] == 0x49 && buffer[2] == 0x46 && // GIF
        buffer[3] == 0x38 && (buffer[4] == 0x39 || buffer[4] == 0x37) && buffer[5] == 0x61; // 89a or 87a

    private static bool IsJpeg(ReadOnlySpan<byte> buffer) =>
        buffer.Length >= 2 &&
        buffer[0] == 0xFF && buffer[1] == 0xD8;

    private static bool IsWebP(ReadOnlySpan<byte> buffer) =>
        buffer.Length >= 12 &&
        buffer[0] == 0x52 && buffer[1] == 0x49 && buffer[2] == 0x46 && buffer[3] == 0x46 && // RIFF
        buffer[8] == 0x57 && buffer[9] == 0x45 && buffer[10] == 0x42 && buffer[11] == 0x50; // WEBP

    private async Task<(int Width, int Height)?> ParseJpegDimensionsAsync(Stream stream, byte[] initialBuffer, CancellationToken ct)
    {
        // JPEG parsing - look for SOF0/SOF2 marker
        var buffer = new byte[8];

        while (true)
        {
            // Read marker
            var read = await stream.ReadAsync(buffer.AsMemory(0, 2), ct);
            if (read < 2)
            {
                return null;
            }

            if (buffer[0] != 0xFF)
            {
                return null;
            }

            var marker = buffer[1];

            // Skip padding bytes
            while (marker == 0xFF)
            {
                read = await stream.ReadAsync(buffer.AsMemory(0, 1), ct);
                if (read < 1)
                {
                    return null;
                }

                marker = buffer[0];
            }

            // SOF markers (SOF0, SOF1, SOF2, etc.)
            if (marker >= 0xC0 && marker <= 0xCF && marker != 0xC4 && marker != 0xC8 && marker != 0xCC)
            {
                // Read length (2 bytes) + precision (1 byte) + height (2 bytes) + width (2 bytes)
                read = await stream.ReadAsync(buffer.AsMemory(0, 7), ct);
                if (read < 7)
                {
                    return null;
                }

                var height = BinaryPrimitives.ReadInt16BigEndian(buffer.AsSpan(3, 2));
                var width = BinaryPrimitives.ReadInt16BigEndian(buffer.AsSpan(5, 2));
                return (width, height);
            }

            // EOI marker - end of image
            if (marker == 0xD9)
            {
                return null;
            }

            // SOS marker - start of scan, no more metadata
            if (marker == 0xDA)
            {
                return null;
            }

            // Read segment length and skip
            read = await stream.ReadAsync(buffer.AsMemory(0, 2), ct);
            if (read < 2)
            {
                return null;
            }

            var length = BinaryPrimitives.ReadInt16BigEndian(buffer.AsSpan(0, 2)) - 2;
            if (length > 0)
            {
                // Skip the segment
                var skipBuffer = new byte[Math.Min(length, 4096)];
                var remaining = length;
                while (remaining > 0)
                {
                    var toRead = Math.Min(remaining, skipBuffer.Length);
                    read = await stream.ReadAsync(skipBuffer.AsMemory(0, toRead), ct);
                    if (read == 0)
                    {
                        return null;
                    }

                    remaining -= read;
                }
            }
        }
    }

    private async Task<(int Width, int Height)?> ParseWebPDimensionsAsync(Stream stream, byte[] initialBuffer, int initialBytesRead, CancellationToken ct)
    {
        // Need more bytes for WebP parsing
        var buffer = new byte[30];
        Array.Copy(initialBuffer, buffer, initialBytesRead);

        if (initialBytesRead < 30)
        {
            var additionalRead = await stream.ReadAsync(buffer.AsMemory(initialBytesRead, 30 - initialBytesRead), ct);
            if (initialBytesRead + additionalRead < 30)
            {
                return null;
            }
        }

        // Check chunk type at offset 12
        var chunkType = System.Text.Encoding.ASCII.GetString(buffer, 12, 4);

        if (chunkType == "VP8 ")
        {
            // Lossy WebP - dimensions at offset 26-29
            var width = BinaryPrimitives.ReadInt16LittleEndian(buffer.AsSpan(26, 2)) & 0x3FFF;
            var height = BinaryPrimitives.ReadInt16LittleEndian(buffer.AsSpan(28, 2)) & 0x3FFF;
            return (width, height);
        }
        else if (chunkType == "VP8L")
        {
            // Lossless WebP - dimensions encoded in first 4 bytes after signature
            var b0 = buffer[21];
            var b1 = buffer[22];
            var b2 = buffer[23];
            var b3 = buffer[24];

            var width = (b0 | ((b1 & 0x3F) << 8)) + 1;
            var height = (((b1 & 0xC0) >> 6) | (b2 << 2) | ((b3 & 0x0F) << 10)) + 1;
            return (width, height);
        }
        else if (chunkType == "VP8X")
        {
            // Extended WebP - dimensions at offset 24-29
            var width = (buffer[24] | (buffer[25] << 8) | (buffer[26] << 16)) + 1;
            var height = (buffer[27] | (buffer[28] << 8) | (buffer[29] << 16)) + 1;
            return (width, height);
        }

        return null;
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Services/PasswordService.cs
SIZE: .82 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

using Microsoft.AspNetCore.Identity;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Password hashing service using ASP.NET Core Identity's PasswordHasher.
/// </summary>
public sealed class PasswordService : IPasswordService
{
    private readonly PasswordHasher<User> _hasher = new();

    /// <inheritdoc />
    public string HashPassword(string password)
    {
        return _hasher.HashPassword(null!, password);
    }

    /// <inheritdoc />
    public bool VerifyPassword(string hashedPassword, string providedPassword)
    {
        var result = _hasher.VerifyHashedPassword(null!, hashedPassword, providedPassword);
        return result == PasswordVerificationResult.Success ||
               result == PasswordVerificationResult.SuccessRehashNeeded;
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Services/ReaderTrackingService.cs
SIZE: 1.57 KB
MODIFIED: 2026-01-16 20:30:23
================================================================================

using System.Collections.Concurrent;
using MyBlog.Core.Interfaces;

namespace MyBlog.Infrastructure.Services;

public class ReaderTrackingService : IReaderTrackingService
{
    // Maps Slug -> Count of active readers
    private readonly ConcurrentDictionary<string, int> _slugCounts = new();

    // Maps ConnectionId -> Slug (Reverse lookup to handle disconnects)
    private readonly ConcurrentDictionary<string, string> _connectionMap = new();

    public int JoinPost(string slug, string connectionId)
    {
        // Map the connection to the slug
        _connectionMap.AddOrUpdate(connectionId, slug, (_, _) => slug);

        // Increment the count for this slug
        return _slugCounts.AddOrUpdate(slug, 1, (_, count) => count + 1);
    }

    public int LeavePost(string slug, string connectionId)
    {
        // Remove the connection mapping
        _connectionMap.TryRemove(connectionId, out _);

        // Decrement the count
        return _slugCounts.AddOrUpdate(slug, 0, (_, count) => count > 0 ? count - 1 : 0);
    }

    public (string? Slug, int NewCount) Disconnect(string connectionId)
    {
        // Find which slug this connection was watching
        if (_connectionMap.TryRemove(connectionId, out var slug))
        {
            // Decrement that slug's count
            var newCount = _slugCounts.AddOrUpdate(slug, 0, (_, count) => count > 0 ? count - 1 : 0);
            return (slug, newCount);
        }

        return (null, 0);
    }

    public int GetReaderCount(string slug)
    {
        return _slugCounts.TryGetValue(slug, out var count) ? count : 0;
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Services/TelemetryCleanupService.cs
SIZE: 2.11 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using MyBlog.Core.Interfaces;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Background service that cleans up old telemetry logs.
/// </summary>
public sealed class TelemetryCleanupService : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<TelemetryCleanupService> _logger;
    private readonly int _retentionDays;

    /// <summary>Initializes a new instance of TelemetryCleanupService.</summary>
    public TelemetryCleanupService(
        IServiceScopeFactory scopeFactory,
        IConfiguration configuration,
        ILogger<TelemetryCleanupService> logger)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
        _retentionDays = configuration.GetValue("Telemetry:RetentionDays", 30);
    }

    /// <inheritdoc />
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Run cleanup immediately on startup
        await CleanupAsync(stoppingToken);

        // Then run daily
        using var timer = new PeriodicTimer(TimeSpan.FromDays(1));
        while (await timer.WaitForNextTickAsync(stoppingToken))
        {
            await CleanupAsync(stoppingToken);
        }
    }

    private async Task CleanupAsync(CancellationToken cancellationToken)
    {
        try
        {
            using var scope = _scopeFactory.CreateScope();
            var repository = scope.ServiceProvider.GetRequiredService<ITelemetryLogRepository>();

            var cutoff = DateTime.UtcNow.AddDays(-_retentionDays);
            var deleted = await repository.DeleteOlderThanAsync(cutoff, cancellationToken);

            if (deleted > 0)
            {
                _logger.LogInformation(
                    "Telemetry cleanup: deleted {Count} logs older than {Days} days",
                    deleted, _retentionDays);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during telemetry cleanup");
        }
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Telemetry/DatabaseLogExporter.cs
SIZE: 2.11 KB
MODIFIED: 2025-12-28 08:55:11
================================================================================

using System.Text.Json;
using Microsoft.Extensions.DependencyInjection;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyBlog.Infrastructure.Telemetry;

/// <summary>
/// OpenTelemetry log exporter that writes to SQLite database.
/// </summary>
public sealed class DatabaseLogExporter : BaseExporter<LogRecord>
{
    private readonly IServiceScopeFactory _scopeFactory;

    /// <summary>Initializes a new instance of DatabaseLogExporter.</summary>
    public DatabaseLogExporter(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }

    /// <inheritdoc />
    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        try
        {
            using var scope = _scopeFactory.CreateScope();
            var context = scope.ServiceProvider.GetRequiredService<BlogDbContext>();

            foreach (var record in batch)
            {
                var log = new TelemetryLog
                {
                    TimestampUtc = record.Timestamp.ToUniversalTime(),
                    Level = record.LogLevel.ToString(),
                    Category = record.CategoryName ?? "Unknown",
                    Message = record.FormattedMessage ?? record.Body ?? "",
                    Exception = record.Exception?.ToString(),
                    TraceId = record.TraceId.ToString(),
                    SpanId = record.SpanId.ToString(),
                    Properties = SerializeAttributes(record)
                };

                context.TelemetryLogs.Add(log);
            }

            context.SaveChanges();
            return ExportResult.Success;
        }
        catch
        {
            return ExportResult.Failure;
        }
    }

    private static string? SerializeAttributes(LogRecord record)
    {
        if (record.Attributes is null)
        {
            return null;
        }

        var dict = new Dictionary<string, object?>();
        foreach (var attr in record.Attributes)
        {
            dict[attr.Key] = attr.Value;
        }

        return dict.Count > 0 ? JsonSerializer.Serialize(dict) : null;
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Telemetry/FileLogExporter.cs
SIZE: 3.61 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

using System.Text;
using System.Text.Json;
using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyBlog.Infrastructure.Telemetry;

/// <summary>
/// OpenTelemetry log exporter that writes to JSON files.
/// </summary>
public sealed class FileLogExporter : BaseExporter<LogRecord>
{
    private readonly string _directory;
    private readonly string _runId;
    private readonly long _maxFileSizeBytes;
    private readonly object _lock = new();
    private StreamWriter? _writer;
    private long _currentFileSize;
    private int _fileNumber;
    private bool _isFirstRecord = true;
    private readonly JsonSerializerOptions _jsonOptions = new() { WriteIndented = true };

    /// <summary>Initializes a new instance of FileLogExporter.</summary>
    public FileLogExporter(string directory, long maxFileSizeBytes = 25 * 1024 * 1024)
    {
        _directory = directory;
        _maxFileSizeBytes = maxFileSizeBytes;
        _runId = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
        Directory.CreateDirectory(_directory);
    }

    /// <inheritdoc />
    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        try
        {
            lock (_lock)
            {
                EnsureWriter();

                foreach (var record in batch)
                {
                    var obj = new
                    {
                        Timestamp = record.Timestamp.ToString("O"),
                        Level = record.LogLevel.ToString(),
                        Category = record.CategoryName,
                        Message = record.FormattedMessage ?? record.Body,
                        TraceId = record.TraceId.ToString(),
                        SpanId = record.SpanId.ToString(),
                        Exception = record.Exception?.ToString()
                    };

                    var json = JsonSerializer.Serialize(obj, _jsonOptions);
                    var bytes = Encoding.UTF8.GetByteCount(json) + 2;

                    if (_currentFileSize + bytes > _maxFileSizeBytes)
                    {
                        RotateFile();
                    }

                    if (!_isFirstRecord)
                    {
                        _writer!.WriteLine(",");
                    }
                    else
                    {
                        _isFirstRecord = false;
                    }

                    _writer!.Write(json);
                    _currentFileSize += bytes;
                }

                _writer!.Flush();
            }

            return ExportResult.Success;
        }
        catch
        {
            return ExportResult.Failure;
        }
    }

    private void EnsureWriter()
    {
        if (_writer is null)
        {
            OpenNewFile();
        }
    }

    private void OpenNewFile()
    {
        var fileName = _fileNumber == 0
            ? $"logs_{_runId}.json"
            : $"logs_{_runId}_{_fileNumber:D3}.json";

        _writer = new StreamWriter(Path.Combine(_directory, fileName), false, Encoding.UTF8);
        _writer.WriteLine("[");
        _currentFileSize = 2;
        _isFirstRecord = true;
    }

    private void RotateFile()
    {
        CloseWriter();
        _fileNumber++;
        OpenNewFile();
    }

    private void CloseWriter()
    {
        if (_writer is not null)
        {
            _writer.WriteLine();
            _writer.WriteLine("]");
            _writer.Flush();
            _writer.Dispose();
            _writer = null;
        }
    }

    /// <inheritdoc />
    protected override bool OnShutdown(int timeoutMilliseconds)
    {
        lock (_lock)
        {
            CloseWriter();
        }
        return true;
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Telemetry/TelemetryPathResolver.cs
SIZE: 2.00 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

namespace MyBlog.Infrastructure.Telemetry;

/// <summary>
/// Resolves the telemetry directory path following XDG conventions.
/// </summary>
public static class TelemetryPathResolver
{
    /// <summary>
    /// Attempts to get a writable telemetry directory.
    /// Returns null if no writable directory can be found.
    /// </summary>
    public static string? GetTelemetryDirectory()
    {
        // Try XDG/platform-specific location first
        var preferredDir = GetPreferredDirectory();
        if (TryCreateAndVerify(preferredDir))
        {
            return preferredDir;
        }

        // Fallback to local directory
        var localDir = Path.Combine(AppContext.BaseDirectory, "telemetry");
        if (TryCreateAndVerify(localDir))
        {
            return localDir;
        }

        // No writable directory available
        return null;
    }

    private static string GetPreferredDirectory()
    {
        string baseDir;

        if (OperatingSystem.IsWindows())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        }
        else if (OperatingSystem.IsMacOS())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        }
        else
        {
            var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
            baseDir = !string.IsNullOrEmpty(xdgDataHome)
                ? xdgDataHome
                : Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".local", "share");
        }

        return Path.Combine(baseDir, "MyBlog", "telemetry");
    }

    private static bool TryCreateAndVerify(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid()}");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return true;
        }
        catch
        {
            return false;
        }
    }
}


================================================================================
FILE: src/MyBlog.slnx
SIZE: .24 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

<Solution>
  <Project Path="MyBlog.Core/MyBlog.Core.csproj" />
  <Project Path="MyBlog.Infrastructure/MyBlog.Infrastructure.csproj" />
  <Project Path="MyBlog.Web/MyBlog.Web.csproj" />
  <Project Path="MyBlog.Tests/MyBlog.Tests.csproj" />
</Solution>


================================================================================
FILE: src/MyBlog.Tests/Integration/AuthServiceLongPasswordTests.cs
SIZE: 11.18 KB
MODIFIED: 2026-01-11 12:56:49
================================================================================

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Integration;

/// <summary>
/// Tests for long password support and account lockout behavior.
/// Uses in-memory SQLite for cross-platform compatibility (Windows/Linux/macOS).
/// </summary>
public sealed class AuthServiceLongPasswordTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly AuthService _sut;
    private readonly PasswordService _passwordService;

    public AuthServiceLongPasswordTests()
    {
        // Use in-memory SQLite - works on all platforms without file locking issues
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _passwordService = new PasswordService();
        var userRepository = new UserRepository(_context);
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Authentication:DefaultAdminPassword"] = "TestAdmin123!"
            })
            .Build();

        _sut = new AuthService(userRepository, _passwordService, configuration);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    // =========================================================================
    // Long Password Tests (128+ characters)
    // =========================================================================

    [Fact]
    public async Task AuthenticateAsync_With128CharacterPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var longPassword = new string('a', 128);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "long-pass-user",
            PasswordHash = _passwordService.HashPassword(longPassword),
            Email = "longpass@example.com",
            DisplayName = "Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("long-pass-user", longPassword, ct);

        Assert.NotNull(result);
        Assert.Equal("long-pass-user", result.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_With256CharacterPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var longPassword = new string('x', 256);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "very-long-pass-user",
            PasswordHash = _passwordService.HashPassword(longPassword),
            Email = "very-long@example.com",
            DisplayName = "Very Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("very-long-pass-user", longPassword, ct);

        Assert.NotNull(result);
        Assert.Equal("very-long-pass-user", result.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_With512CharacterPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var longPassword = new string('P', 512);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "extralong-pass-user",
            PasswordHash = _passwordService.HashPassword(longPassword),
            Email = "extralong@example.com",
            DisplayName = "Extra Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("extralong-pass-user", longPassword, ct);

        Assert.NotNull(result);
        Assert.Equal("extralong-pass-user", result.Username);
    }

    [Fact]
    public async Task ChangePasswordAsync_With128CharacterNewPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "ShortPass123!";
        var newLongPassword = new string('N', 128);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "change-pass-long-user",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "changelong@example.com",
            DisplayName = "Change Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.ChangePasswordAsync(user.Id, originalPassword, newLongPassword, ct);

        Assert.True(result);

        // Verify new password works
        var authenticated = await _sut.AuthenticateAsync("change-pass-long-user", newLongPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task AuthenticateAsync_WithComplexLongPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        // Mix of characters, 200 chars long
        var complexPassword = string.Concat(
            new string('A', 50),
            new string('1', 50),
            new string('!', 50),
            new string('z', 50)
        );

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "complex-pass-user",
            PasswordHash = _passwordService.HashPassword(complexPassword),
            Email = "complex@example.com",
            DisplayName = "Complex Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("complex-pass-user", complexPassword, ct);

        Assert.NotNull(result);
    }

    // =========================================================================
    // No Account Lockout Tests
    // =========================================================================

    [Fact]
    public async Task AuthenticateAsync_After100FailedAttempts_StillAllowsLogin()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPassword123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "no-lockout-user",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "no-lockout@example.com",
            DisplayName = "No Lockout User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Attempt 100 failed logins
        for (var i = 0; i < 100; i++)
        {
            var failedResult = await _sut.AuthenticateAsync("no-lockout-user", "WrongPassword", ct);
            Assert.Null(failedResult);
        }

        // User should still be able to log in with correct password
        var successResult = await _sut.AuthenticateAsync("no-lockout-user", correctPassword, ct);
        Assert.NotNull(successResult);
        Assert.Equal("no-lockout-user", successResult.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_After1000FailedAttempts_StillAllowsLogin()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPassword123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "no-lockout1000user",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "no-lockout1000@example.com",
            DisplayName = "No Lockout 1000 User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Attempt 1000 failed logins
        for (var i = 0; i < 1000; i++)
        {
            var failedResult = await _sut.AuthenticateAsync("no-lockout1000user", $"WrongPassword{i}", ct);
            Assert.Null(failedResult);
        }

        // User should still be able to log in with correct password
        var successResult = await _sut.AuthenticateAsync("no-lockout1000user", correctPassword, ct);
        Assert.NotNull(successResult);
        Assert.Equal("no-lockout1000user", successResult.Username);
    }

    [Fact]
    public async Task ChangePasswordAsync_AfterManyFailedAttempts_StillWorks()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "NewPassword456!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "change-pass-no-lockout",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "change-pass-no-lockout@example.com",
            DisplayName = "Change Password No Lockout",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Attempt 50 failed password changes
        for (var i = 0; i < 50; i++)
        {
            var failedResult = await _sut.ChangePasswordAsync(user.Id, "WrongOldPassword", "NewPass", ct);
            Assert.False(failedResult);
        }

        // Should still be able to change password with correct current password
        var successResult = await _sut.ChangePasswordAsync(user.Id, originalPassword, newPassword, ct);
        Assert.True(successResult);

        // Verify new password works
        var authenticated = await _sut.AuthenticateAsync("change-pass-no-lockout", newPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task AuthenticateAsync_InterleavedFailuresAndSuccesses_NeverLocks()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPassword123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "interleaved-user",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "interleaved@example.com",
            DisplayName = "Interleaved User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Interleave failed and successful attempts
        for (var i = 0; i < 20; i++)
        {
            // 5 failed attempts
            for (var j = 0; j < 5; j++)
            {
                var failedResult = await _sut.AuthenticateAsync("interleaved-user", "WrongPassword", ct);
                Assert.Null(failedResult);
            }

            // 1 successful attempt
            var successResult = await _sut.AuthenticateAsync("interleaved-user", correctPassword, ct);
            Assert.NotNull(successResult);
        }

        // Final successful login after 100 failed attempts total
        var finalResult = await _sut.AuthenticateAsync("interleaved-user", correctPassword, ct);
        Assert.NotNull(finalResult);
        Assert.Equal("interleaved-user", finalResult.Username);
    }
}


================================================================================
FILE: src/MyBlog.Tests/Integration/AuthServiceTests.cs
SIZE: 3.85 KB
MODIFIED: 2025-12-28 09:39:37
================================================================================

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Integration;

public class AuthServiceTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly AuthService _sut;
    private readonly PasswordService _passwordService = new();

    public AuthServiceTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        var userRepository = new UserRepository(_context);
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Authentication:DefaultAdminPassword"] = "TestAdmin123!"
            })
            .Build();

        _sut = new AuthService(userRepository, _passwordService, configuration);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task AuthenticateAsync_WithValidCredentials_ReturnsUser()
    {
        var ct = TestContext.Current.CancellationToken;
        var password = "TestPassword123";
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(password),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("testuser", password, ct);

        Assert.NotNull(result);
        Assert.Equal("testuser", result.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_WithInvalidPassword_ReturnsNull()
    {
        var ct = TestContext.Current.CancellationToken;
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword("CorrectPassword"),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("testuser", "WrongPassword", ct);

        Assert.Null(result);
    }

    [Fact]
    public async Task AuthenticateAsync_WithNonExistentUser_ReturnsNull()
    {
        var ct = TestContext.Current.CancellationToken;
        var result = await _sut.AuthenticateAsync("nonexistent", "password", ct);
        Assert.Null(result);
    }

    [Fact]
    public async Task EnsureAdminUserAsync_WhenNoUsersExist_CreatesAdmin()
    {
        var ct = TestContext.Current.CancellationToken;
        await _sut.EnsureAdminUserAsync(ct);

        var admin = await _context.Users.FirstOrDefaultAsync(u => u.Username == "admin", ct);
        Assert.NotNull(admin);
    }

    [Fact]
    public async Task EnsureAdminUserAsync_WhenUsersExist_DoesNotCreateAnother()
    {
        var ct = TestContext.Current.CancellationToken;
        var existingUser = new User
        {
            Id = Guid.NewGuid(),
            Username = "existing",
            PasswordHash = "hash",
            Email = "existing@example.com",
            DisplayName = "Existing",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(existingUser);
        await _context.SaveChangesAsync(ct);

        await _sut.EnsureAdminUserAsync(ct);

        var userCount = await _context.Users.CountAsync(ct);
        Assert.Equal(1, userCount);
    }
}


================================================================================
FILE: src/MyBlog.Tests/Integration/PasswordChangeTests.cs
SIZE: 6.10 KB
MODIFIED: 2025-12-28 11:34:32
================================================================================

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Integration;

public class PasswordChangeTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly AuthService _sut;
    private readonly PasswordService _passwordService = new();
    private readonly UserRepository _userRepository;

    public PasswordChangeTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _userRepository = new UserRepository(_context);
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Authentication:DefaultAdminPassword"] = "TestAdmin123!"
            })
            .Build();

        _sut = new AuthService(_userRepository, _passwordService, configuration);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task ChangePasswordAsync_WithCorrectCurrentPassword_ReturnsTrue()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "NewPassword456!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.ChangePasswordAsync(user.Id, originalPassword, newPassword, ct);

        Assert.True(result);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithCorrectPassword_AllowsLoginWithNewPassword()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "NewPassword456!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        await _sut.ChangePasswordAsync(user.Id, originalPassword, newPassword, ct);

        // Should authenticate with new password
        var authenticated = await _sut.AuthenticateAsync("testuser", newPassword, ct);
        Assert.NotNull(authenticated);

        // Should NOT authenticate with old password
        var oldAuth = await _sut.AuthenticateAsync("testuser", originalPassword, ct);
        Assert.Null(oldAuth);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithWrongCurrentPassword_ReturnsFalse()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPass123!";
        var wrongPassword = "WrongPassword!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.ChangePasswordAsync(user.Id, wrongPassword, "NewPass123!", ct);

        Assert.False(result);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithWrongPassword_DoesNotChangePassword()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPass123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        await _sut.ChangePasswordAsync(user.Id, "WrongPassword!", "NewPass123!", ct);

        // Original password should still work
        var authenticated = await _sut.AuthenticateAsync("testuser", correctPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithNonExistentUser_ReturnsFalse()
    {
        var ct = TestContext.Current.CancellationToken;
        var result = await _sut.ChangePasswordAsync(Guid.NewGuid(), "any", "password", ct);
        Assert.False(result);
    }

    [Fact]
    public async Task ResetPasswordAsync_SetsNewPassword()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "ResetPassword789!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        await _sut.ResetPasswordAsync(user.Id, newPassword, ct);

        var authenticated = await _sut.AuthenticateAsync("testuser", newPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task ResetPasswordAsync_WithNonExistentUser_ThrowsException()
    {
        var ct = TestContext.Current.CancellationToken;
        await Assert.ThrowsAsync<InvalidOperationException>(
            () => _sut.ResetPasswordAsync(Guid.NewGuid(), "password", ct));
    }
}


================================================================================
FILE: src/MyBlog.Tests/Integration/PostRepositoryTests.cs
SIZE: 4.88 KB
MODIFIED: 2025-12-28 09:39:37
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using Xunit;

namespace MyBlog.Tests.Integration;

public class PostRepositoryTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly PostRepository _sut;
    private readonly User _testUser;

    public PostRepositoryTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _testUser = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = "hash",
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(_testUser);
        _context.SaveChanges();

        _sut = new PostRepository(_context);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task CreateAsync_AddsPostToDatabase()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("Test Post");

        var result = await _sut.CreateAsync(post, ct);

        Assert.NotEqual(Guid.Empty, result.Id);
        var saved = await _context.Posts.FindAsync([result.Id], ct);
        Assert.NotNull(saved);
        Assert.Equal("Test Post", saved.Title);
    }

    [Fact]
    public async Task GetByIdAsync_WithExistingId_ReturnsPost()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("Test Post");
        await _sut.CreateAsync(post, ct);

        var result = await _sut.GetByIdAsync(post.Id, ct);

        Assert.NotNull(result);
        Assert.Equal("Test Post", result.Title);
    }

    [Fact]
    public async Task GetByIdAsync_WithNonExistingId_ReturnsNull()
    {
        var ct = TestContext.Current.CancellationToken;
        var result = await _sut.GetByIdAsync(Guid.NewGuid(), ct);
        Assert.Null(result);
    }

    [Fact]
    public async Task GetBySlugAsync_WithExistingSlug_ReturnsPost()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("Test Post", "test-post");
        await _sut.CreateAsync(post, ct);

        var result = await _sut.GetBySlugAsync("test-post", ct);

        Assert.NotNull(result);
        Assert.Equal("Test Post", result.Title);
    }

    [Fact]
    public async Task GetPublishedPostsAsync_ReturnsOnlyPublishedPosts()
    {
        var ct = TestContext.Current.CancellationToken;
        await _sut.CreateAsync(CreateTestPost("Published", isPublished: true), ct);
        await _sut.CreateAsync(CreateTestPost("Draft", isPublished: false), ct);

        var (posts, totalCount) = await _sut.GetPublishedPostsAsync(1, 10, ct);

        Assert.Single(posts);
        Assert.Equal("Published", posts.First().Title);
        Assert.Equal(1, totalCount);
    }

    [Fact]
    public async Task UpdateAsync_ModifiesPost()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("Original Title");
        await _sut.CreateAsync(post, ct);

        post.Title = "Updated Title";
        await _sut.UpdateAsync(post, ct);

        var result = await _sut.GetByIdAsync(post.Id, ct);
        Assert.Equal("Updated Title", result!.Title);
    }

    [Fact]
    public async Task DeleteAsync_RemovesPost()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("To Delete");
        await _sut.CreateAsync(post, ct);

        await _sut.DeleteAsync(post.Id, ct);

        var result = await _sut.GetByIdAsync(post.Id, ct);
        Assert.Null(result);
    }

    [Fact]
    public async Task GetPublishedPostsAsync_ReturnsCorrectCount()
    {
        var ct = TestContext.Current.CancellationToken;
        await _sut.CreateAsync(CreateTestPost("Post 1", isPublished: true), ct);
        await _sut.CreateAsync(CreateTestPost("Post 2", isPublished: true), ct);
        await _sut.CreateAsync(CreateTestPost("Draft", isPublished: false), ct);

        var (_, totalCount) = await _sut.GetPublishedPostsAsync(1, 10, ct);

        Assert.Equal(2, totalCount);
    }

    private Post CreateTestPost(string title, string? slug = null, bool isPublished = true)
    {
        return new Post
        {
            Id = Guid.NewGuid(),
            Title = title,
            Slug = slug ?? title.ToLower().Replace(" ", "-"),
            Content = "Test content",
            Summary = "Test summary",
            AuthorId = _testUser.Id,
            CreatedAtUtc = DateTime.UtcNow,
            UpdatedAtUtc = DateTime.UtcNow,
            IsPublished = isPublished,
            PublishedAtUtc = isPublished ? DateTime.UtcNow : null
        };
    }
}


================================================================================
FILE: src/MyBlog.Tests/Integration/TelemetryCleanupTests.cs
SIZE: 2.68 KB
MODIFIED: 2025-12-28 09:27:55
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using Xunit;

namespace MyBlog.Tests.Integration;

public class TelemetryCleanupTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly TelemetryLogRepository _sut;

    public TelemetryCleanupTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _sut = new TelemetryLogRepository(_context);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task DeleteOlderThanAsync_RemovesOldLogs()
    {
        var ct = TestContext.Current.CancellationToken;

        // Add old logs
        var oldLog = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow.AddDays(-60),
            Level = "Information",
            Category = "Test",
            Message = "Old log"
        };
        _context.TelemetryLogs.Add(oldLog);

        // Add recent log
        var recentLog = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow.AddDays(-5),
            Level = "Information",
            Category = "Test",
            Message = "Recent log"
        };
        _context.TelemetryLogs.Add(recentLog);
        await _context.SaveChangesAsync(ct);

        var cutoff = DateTime.UtcNow.AddDays(-30);
        var deleted = await _sut.DeleteOlderThanAsync(cutoff, ct);

        Assert.Equal(1, deleted);
        var remaining = await _context.TelemetryLogs.CountAsync(ct);
        Assert.Equal(1, remaining);
    }

    [Fact]
    public async Task DeleteOlderThanAsync_WithNoOldLogs_ReturnsZero()
    {
        var ct = TestContext.Current.CancellationToken;

        var recentLog = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow.AddDays(-5),
            Level = "Information",
            Category = "Test",
            Message = "Recent log"
        };
        _context.TelemetryLogs.Add(recentLog);
        await _context.SaveChangesAsync(ct);

        var cutoff = DateTime.UtcNow.AddDays(-30);
        var deleted = await _sut.DeleteOlderThanAsync(cutoff, ct);

        Assert.Equal(0, deleted);
    }

    [Fact]
    public async Task DeleteOlderThanAsync_WithEmptyTable_ReturnsZero()
    {
        var ct = TestContext.Current.CancellationToken;
        var cutoff = DateTime.UtcNow.AddDays(-30);
        var deleted = await _sut.DeleteOlderThanAsync(cutoff, ct);
        Assert.Equal(0, deleted);
    }
}


================================================================================
FILE: src/MyBlog.Tests/MyBlog.Tests.csproj
SIZE: .69 KB
MODIFIED: 2026-01-11 12:52:12
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>MyBlog.Tests</RootNamespace>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="xunit.v3" />
    <PackageReference Include="Microsoft.Testing.Extensions.TrxReport" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\MyBlog.Core\MyBlog.Core.csproj" />
    <ProjectReference Include="..\MyBlog.Web\MyBlog.Web.csproj" />
    <ProjectReference Include="..\MyBlog.Infrastructure\MyBlog.Infrastructure.csproj" />
  </ItemGroup>
</Project>


================================================================================
FILE: src/MyBlog.Tests/Unit/LoginRateLimitMiddlewareTests.cs
SIZE: 6.75 KB
MODIFIED: 2026-01-11 13:04:49
================================================================================

using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging.Abstractions;
using MyBlog.Web.Middleware;
using Xunit;

namespace MyBlog.Tests.Unit;

/// <summary>
/// Tests for LoginRateLimitMiddleware.
/// Verifies that the middleware slows down but never blocks requests.
/// </summary>
public sealed class LoginRateLimitMiddlewareTests : IDisposable
{
    private readonly LoginRateLimitMiddleware _sut;
    private int _nextCallCount;
    private readonly List<TimeSpan> _recordedDelays = [];

    public LoginRateLimitMiddlewareTests()
    {
        // Clear any state from previous tests
        LoginRateLimitMiddleware.ClearAttempts();

        _nextCallCount = 0;
        RequestDelegate next = _ =>
        {
            _nextCallCount++;
            return Task.CompletedTask;
        };

        // Use a no-op delay function that just records the delay
        // This makes tests fast while still verifying delay logic
        Task NoOpDelay(TimeSpan delay, CancellationToken ct)
        {
            _recordedDelays.Add(delay);
            return Task.CompletedTask;
        }

        _sut = new LoginRateLimitMiddleware(
            next,
            NullLogger<LoginRateLimitMiddleware>.Instance,
            NoOpDelay);
    }

    public void Dispose()
    {
        // Clean up after each test
        LoginRateLimitMiddleware.ClearAttempts();
    }

    [Fact]
    public async Task InvokeAsync_NonLoginRequest_PassesThroughImmediately()
    {
        var context = CreateHttpContext("/api/posts", "GET");

        await _sut.InvokeAsync(context);

        Assert.Equal(1, _nextCallCount);
        Assert.Empty(_recordedDelays);
    }

    [Fact]
    public async Task InvokeAsync_GetLoginRequest_PassesThroughImmediately()
    {
        var context = CreateHttpContext("/login", "GET");

        await _sut.InvokeAsync(context);

        Assert.Equal(1, _nextCallCount);
        Assert.Empty(_recordedDelays);
    }

    [Fact]
    public async Task InvokeAsync_FirstFiveAttempts_NoDelay()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // First 5 attempts should have no delay
        for (var i = 0; i < 5; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(5, _nextCallCount);
        Assert.Empty(_recordedDelays); // No delays for first 5 attempts
    }

    [Fact]
    public async Task InvokeAsync_SixthAttempt_HasOneSecondDelay()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make 6 attempts
        for (var i = 0; i < 6; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(6, _nextCallCount);
        Assert.Single(_recordedDelays);
        Assert.Equal(TimeSpan.FromSeconds(1), _recordedDelays[0]);
    }

    [Fact]
    public async Task InvokeAsync_ProgressiveDelays_IncreaseExponentially()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make 10 attempts: 5 no-delay + 5 with delays
        for (var i = 0; i < 10; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(10, _nextCallCount);
        Assert.Equal(5, _recordedDelays.Count); // Delays start after attempt 5

        // Verify exponential progression: 1s, 2s, 4s, 8s, 16s
        Assert.Equal(TimeSpan.FromSeconds(1), _recordedDelays[0]);
        Assert.Equal(TimeSpan.FromSeconds(2), _recordedDelays[1]);
        Assert.Equal(TimeSpan.FromSeconds(4), _recordedDelays[2]);
        Assert.Equal(TimeSpan.FromSeconds(8), _recordedDelays[3]);
        Assert.Equal(TimeSpan.FromSeconds(16), _recordedDelays[4]);
    }

    [Fact]
    public async Task InvokeAsync_DelayCappedAt30Seconds()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make enough attempts to hit the cap (5 no-delay + enough to exceed 30s)
        // After attempt 5: 1, 2, 4, 8, 16, 30, 30, 30...
        for (var i = 0; i < 15; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(15, _nextCallCount);

        // Verify cap at 30 seconds (attempts 11+ should all be 30s)
        var maxDelays = _recordedDelays.Where(d => d == TimeSpan.FromSeconds(30)).ToList();
        Assert.True(maxDelays.Count >= 4, "Should have multiple 30-second delays");
        Assert.True(_recordedDelays.All(d => d <= TimeSpan.FromSeconds(30)), "No delay should exceed 30 seconds");
    }

    [Fact]
    public async Task InvokeAsync_AfterManyAttempts_NeverBlocks()
    {
        var uniqueIp = $"10.0.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make 100 attempts - should all pass through (with delays, but never blocked)
        for (var i = 0; i < 100; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        // Key assertion: ALL requests passed through, none were blocked
        Assert.Equal(100, _nextCallCount);
    }

    [Fact]
    public async Task InvokeAsync_DifferentIPs_IndependentTracking()
    {
        var ip1 = $"10.1.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";
        var ip2 = $"10.2.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // 6 attempts from IP1 (should trigger delay on 6th)
        for (var i = 0; i < 6; i++)
        {
            var context = CreateHttpContext("/login", "POST", ip1);
            await _sut.InvokeAsync(context);
        }

        var ip1Delays = _recordedDelays.Count;
        Assert.Equal(1, ip1Delays); // One delay after 5th attempt

        // First attempt from IP2 should have no delay
        var context2 = CreateHttpContext("/login", "POST", ip2);
        await _sut.InvokeAsync(context2);

        // No new delays should have been added for IP2
        Assert.Equal(ip1Delays, _recordedDelays.Count);
    }

    [Fact]
    public void CalculateDelay_UnknownIP_ReturnsZero()
    {
        var delay = LoginRateLimitMiddleware.CalculateDelay("unknown-ip-never-seen");
        Assert.Equal(TimeSpan.Zero, delay);
    }

    private static DefaultHttpContext CreateHttpContext(string path, string method, string? remoteIp = null)
    {
        var context = new DefaultHttpContext();
        context.Request.Path = path;
        context.Request.Method = method;

        if (remoteIp != null)
        {
            context.Connection.RemoteIpAddress = System.Net.IPAddress.Parse(remoteIp);
        }

        return context;
    }
}


================================================================================
FILE: src/MyBlog.Tests/Unit/MarkdownServiceTests.cs
SIZE: 7.09 KB
MODIFIED: 2026-01-20 09:14:25
================================================================================

using System.Threading;
using System.Threading.Tasks;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Services;
using Xunit;

namespace MyBlog.Tests.Unit;

/// <summary>
/// Mock implementation for testing that simulates dimension lookup.
/// </summary>
internal sealed class MockImageDimensionService : IImageDimensionService
{
    public Task<(int Width, int Height)?> GetDimensionsAsync(string url, CancellationToken cancellationToken = default)
    {
        // Return dimensions for URLs containing "image.png"
        if (url.Contains("image.png"))
        {
            return Task.FromResult<(int, int)?>((100, 200));
        }

        // Return null for unknown images
        return Task.FromResult<(int, int)?>(null);
    }
}

/// <summary>
/// Mock implementation that throws exceptions to test error handling.
/// </summary>
internal sealed class ThrowingImageDimensionService : IImageDimensionService
{
    public Task<(int Width, int Height)?> GetDimensionsAsync(string url, CancellationToken cancellationToken = default)
    {
        throw new InvalidOperationException("Simulated database error");
    }
}

public class MarkdownServiceTests
{
    private readonly MarkdownService _sut = new(new MockImageDimensionService());

    // Helper to normalize newlines for cross-platform comparison
    private static string NormalizeNewlines(string s) => s.Replace("\r\n", "\n");

    [Fact]
    public async Task ToHtml_WithHeading1_ReturnsH1Tag()
    {
        var result = await _sut.ToHtmlAsync("# Hello");
        Assert.Contains("<h1>Hello</h1>", result);
    }

    [Fact]
    public async Task ToHtml_WithHeading2_ReturnsH2Tag()
    {
        var result = await _sut.ToHtmlAsync("## Hello");
        Assert.Contains("<h2>Hello</h2>", result);
    }

    [Fact]
    public async Task ToHtml_WithHeading6_ReturnsH6Tag()
    {
        var result = await _sut.ToHtmlAsync("###### Hello");
        Assert.Contains("<h6>Hello</h6>", result);
    }

    [Fact]
    public async Task ToHtml_WithBoldText_ReturnsStrongTag()
    {
        var result = await _sut.ToHtmlAsync("This is **bold** text");
        Assert.Contains("<strong>bold</strong>", result);
    }

    [Fact]
    public async Task ToHtml_WithItalicText_ReturnsEmTag()
    {
        var result = await _sut.ToHtmlAsync("This is *italic* text");
        Assert.Contains("<em>italic</em>", result);
    }

    [Fact]
    public async Task ToHtml_WithLink_ReturnsAnchorTag()
    {
        var result = await _sut.ToHtmlAsync("Check [this link](https://example.com)");
        Assert.Contains("<p>Check <a href=\"https://example.com\">this link</a></p>", result);
    }

    [Fact]
    public async Task ToHtml_WithImage_InjectsDimensions_IfResolvable()
    {
        // Mock returns 100x200 for 'image.png'
        var result = NormalizeNewlines(await _sut.ToHtmlAsync("![alt text](https://example.com/image.png)"));
        Assert.Contains("<p><img src=\"https://example.com/image.png\" alt=\"alt text\" width=\"100\" height=\"200\" /></p>\n", result);
    }

    [Fact]
    public async Task ToHtml_WithImage_InjectsParagraphs_IfResolvable()
    {
        // Mock returns 100x200 for 'image.png'
        var result = NormalizeNewlines(await _sut.ToHtmlAsync("Check out this photo of when I was younger. ![high school graduation photo](https://example.com/image.png)"));
        Assert.Contains("<p>Check out this photo of when I was younger. <img src=\"https://example.com/image.png\" alt=\"high school graduation photo\" width=\"100\" height=\"200\" /></p>\n", result);
    }

    [Fact]
    public async Task ToHtml_WithImage_NoDimensions_IfUnresolvable()
    {
        var result = NormalizeNewlines(await _sut.ToHtmlAsync("![alt text](https://example.com/unknown.jpg)"));
        Assert.Contains("<p><img src=\"https://example.com/unknown.jpg\" alt=\"alt text\" /></p>\n", result);
    }

    [Fact]
    public async Task ToHtml_WithImage_WhenServiceThrows_StillRendersImage()
    {
        // Use the throwing service to test error handling
        var throwingService = new ThrowingImageDimensionService();
        var sut = new MarkdownService(throwingService);

        // Should NOT throw - should gracefully degrade to image without dimensions
        var result = NormalizeNewlines(await sut.ToHtmlAsync("![alt text](https://example.com/image.png)"));
        Assert.Contains("<p><img src=\"https://example.com/image.png\" alt=\"alt text\" /></p>\n", result);
    }

    [Fact]
    public async Task ToHtml_WithInlineCode_ReturnsCodeTag()
    {
        var result = await _sut.ToHtmlAsync("Use `code` here");
        Assert.Contains("<code>code</code>", result);
    }

    [Fact]
    public async Task ToHtml_WithCodeBlock_ReturnsPreCodeTags()
    {
        var markdown = "```\nvar x = 1;\n```";
        var result = await _sut.ToHtmlAsync(markdown);
        Assert.Contains("<pre><code>", result);
        Assert.Contains("var x = 1;", result);
        Assert.Contains("</code></pre>", result);
    }

    [Fact]
    public async Task ToHtml_WithBlockquote_ReturnsBlockquoteTag()
    {
        var result = await _sut.ToHtmlAsync("> This is a quote");
        Assert.Contains("<blockquote><p>This is a quote</p></blockquote>", result);
    }

    [Fact]
    public async Task ToHtml_WithUnorderedList_ReturnsUlLiTags()
    {
        var markdown = "- Item 1\n- Item 2";
        var result = await _sut.ToHtmlAsync(markdown);
        Assert.Contains("<ul>", result);
        Assert.Contains("<li>Item 1</li>", result);
        Assert.Contains("<li>Item 2</li>", result);
        Assert.Contains("</ul>", result);
    }

    [Fact]
    public async Task ToHtml_WithHorizontalRule_ReturnsHrTag()
    {
        var result = await _sut.ToHtmlAsync("---");
        Assert.Contains("<hr />", result);
    }

    [Fact]
    public async Task ToHtml_WithOrderedList_ReturnsOlLiTags()
    {
        var markdown = "1. First\n2. Second";
        var result = await _sut.ToHtmlAsync(markdown);
        Assert.Contains("<ol>", result);
        Assert.Contains("<li>First</li>", result);
        Assert.Contains("<li>Second</li>", result);
        Assert.Contains("</ol>", result);
    }

    [Fact]
    public async Task ToHtml_WithEmptyString_ReturnsEmpty()
    {
        var result = await _sut.ToHtmlAsync("");
        Assert.Equal(string.Empty, result);
    }

    [Fact]
    public async Task ToHtml_WithNull_ReturnsEmpty()
    {
        var result = await _sut.ToHtmlAsync(null!);
        Assert.Equal(string.Empty, result);
    }

    [Fact]
    public async Task ToHtml_WithWhitespace_ReturnsEmpty()
    {
        var result = await _sut.ToHtmlAsync("   ");
        Assert.Equal(string.Empty, result);
    }

    [Fact]
    public async Task ToHtml_WithMultipleImages_ProcessesAll()
    {
        var markdown = "![img1](https://example.com/image.png) and ![img2](https://example.com/other.jpg)";
        var result = NormalizeNewlines(await _sut.ToHtmlAsync(markdown));

        // First image should have dimensions (contains 'image.png')
        Assert.Contains("width=\"100\" height=\"200\"", result);
        // Second image should not have dimensions (doesn't match mock)
        Assert.Contains("<img src=\"https://example.com/other.jpg\" alt=\"img2\" />", result);
    }
}


================================================================================
FILE: src/MyBlog.Tests/Unit/PasswordServiceTests.cs
SIZE: 1.30 KB
MODIFIED: 2025-12-28 09:05:13
================================================================================

using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Unit;

public class PasswordServiceTests
{
    private readonly PasswordService _sut = new();

    [Fact]
    public void HashPassword_ReturnsNonEmptyHash()
    {
        var hash = _sut.HashPassword("TestPassword123");
        Assert.False(string.IsNullOrEmpty(hash));
    }

    [Fact]
    public void HashPassword_ReturnsDifferentHashForSamePassword()
    {
        var hash1 = _sut.HashPassword("TestPassword123");
        var hash2 = _sut.HashPassword("TestPassword123");
        Assert.NotEqual(hash1, hash2);
    }

    [Fact]
    public void VerifyPassword_WithCorrectPassword_ReturnsTrue()
    {
        var password = "TestPassword123";
        var hash = _sut.HashPassword(password);

        var result = _sut.VerifyPassword(hash, password);

        Assert.True(result);
    }

    [Fact]
    public void VerifyPassword_WithWrongPassword_ReturnsFalse()
    {
        var hash = _sut.HashPassword("TestPassword123");

        var result = _sut.VerifyPassword(hash, "WrongPassword");

        Assert.False(result);
    }

    [Fact]
    public void VerifyPassword_WithEmptyPassword_ReturnsFalse()
    {
        var hash = _sut.HashPassword("TestPassword123");

        var result = _sut.VerifyPassword(hash, "");

        Assert.False(result);
    }
}


================================================================================
FILE: src/MyBlog.Tests/Unit/SlugServiceTests.cs
SIZE: 2.18 KB
MODIFIED: 2026-01-19 19:52:01
================================================================================

using MyBlog.Core.Services;
using Xunit;

namespace MyBlog.Tests.Unit;

public class SlugServiceTests
{
    private readonly SlugService _sut = new();

    [Fact]
    public void GenerateSlug_WithSimpleTitle_ReturnsLowercaseWithHyphens()
    {
        var result = _sut.GenerateSlugOrUuid("Hello World");
        Assert.Equal("hello-world", result);
    }

    [Fact]
    public void GenerateSlug_WithSpecialCharacters_RemovesThem()
    {
        var result = _sut.GenerateSlugOrUuid("Hello, World! How's it going?");
        Assert.Equal("hello-world-hows-it-going", result);
    }

    [Fact]
    public void GenerateSlug_WithMultipleSpaces_CollapsesToSingleHyphen()
    {
        var result = _sut.GenerateSlugOrUuid("Hello    World");
        Assert.Equal("hello-world", result);
    }

    [Fact]
    public void GenerateSlug_WithUnicode_RemovesDiacritics()
    {
        var result = _sut.GenerateSlugOrUuid("Café résumé");
        Assert.Equal("cafe-resume", result);
    }

    [Fact]
    public void GenerateSlug_WithLeadingTrailingSpaces_TrimsHyphens()
    {
        var result = _sut.GenerateSlugOrUuid("  Hello World  ");
        Assert.Equal("hello-world", result);
    }

    [Fact]
    public void GenerateSlug_WithNumbers_PreservesNumbers()
    {
        var result = _sut.GenerateSlugOrUuid("Top 10 Tips for 2024");
        Assert.Equal("top-10-tips-for-2024", result);
    }

    [Fact]
    public void GenerateSlug_WithUnderscores_ConvertsToHyphens()
    {
        var result = _sut.GenerateSlugOrUuid("hello_world_test");
        Assert.Equal("hello-world-test", result);
    }

    [Theory]
    [InlineData("")]
    [InlineData(" ")]
    [InlineData("   ")]
    [InlineData("       ")]
    public void GenerateSlug_WithEmptyStringOrWhitespace_ReturnsGuidWithPrefix(string input)
    {
        // Act
        var result = _sut.GenerateSlugOrUuid(input);

        // Assert
        Assert.StartsWith("post-", result);

        // Extract the GUID part (the part after "post-")
        var guidPart = result.Replace("post-", "");

        // Assert it is a valid GUID
        var isValidGuid = Guid.TryParse(guidPart, out _);
        Assert.True(isValidGuid, $"Expected a valid GUID but got {guidPart}");
    }
}


================================================================================
FILE: src/MyBlog.Web/appsettings.Development.json
SIZE: .11 KB
MODIFIED: 2025-12-28 08:44:06
================================================================================

{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Information"
    }
  }
}


================================================================================
FILE: src/MyBlog.Web/appsettings.json
SIZE: .60 KB
MODIFIED: 2026-01-14 19:57:11
================================================================================

{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=myblog.db"
  },
  "Authentication": {
    "SessionTimeoutMinutes": 30,
    "DefaultAdminPassword": "ChangeMe123!"
  },
  "Telemetry": {
    "RetentionDays": 30,
    "EnableFileLogging": true,
    "EnableDatabaseLogging": true
  },
  "Application": {
    "Title": "MyBlog",
    "PostsPerPage": 10,
    "RequireHttps": false,
    "GitForgeUrl": "https://github.com/kusl/dotnetcms"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  }
}


================================================================================
FILE: src/MyBlog.Web/Components/Pages/About.razor.css
SIZE: 10.55 KB
MODIFIED: 2026-01-14 19:31:11
================================================================================

/* About Page Styles */
.about-page {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 var(--spacing);
}

/* Header */
.about-header {
    text-align: center;
    padding: calc(var(--spacing) * 2) 0;
    border-bottom: 1px solid var(--color-border);
    margin-bottom: calc(var(--spacing) * 2);
}

.about-header h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    color: var(--color-primary);
}

.about-tagline {
    font-size: 1.25rem;
    color: var(--color-text-muted);
    margin-bottom: 1rem;
}

.reader-info {
    display: flex;
    justify-content: center;
    margin-top: 1rem;
}

/* Sections */
.about-section {
    margin-bottom: calc(var(--spacing) * 3);
    padding-bottom: calc(var(--spacing) * 2);
    border-bottom: 1px solid var(--color-border);
}

.about-section:last-of-type {
    border-bottom: none;
}

.about-section h2 {
    font-size: 1.75rem;
    margin-bottom: 1rem;
    color: var(--color-text);
    position: relative;
    padding-bottom: 0.5rem;
}

.about-section h2::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 60px;
    height: 3px;
    background: var(--color-primary);
    border-radius: 2px;
}

.about-section p {
    line-height: 1.8;
    margin-bottom: 1rem;
}

/* Architecture Grid */
.architecture-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    margin-top: 1.5rem;
}

.arch-card {
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    padding: 1.5rem;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.arch-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.arch-card h3 {
    color: var(--color-primary);
    margin-bottom: 0.25rem;
    font-size: 1.25rem;
}

.arch-subtitle {
    font-size: 0.875rem;
    color: var(--color-text-muted);
    margin-bottom: 1rem;
    font-weight: 500;
}

.arch-contents {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--color-border);
    font-size: 0.9rem;
}

.arch-contents ul {
    margin: 0.5rem 0 0 1.25rem;
    padding: 0;
}

.arch-contents li {
    margin-bottom: 0.25rem;
}

.arch-contents code {
    background: var(--color-bg);
    padding: 0.125rem 0.375rem;
    border-radius: 3px;
    font-size: 0.85em;
}

/* Technology Grid */
.tech-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin-top: 1.5rem;
}

.tech-category {
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    padding: 1.25rem;
}

.tech-category h3 {
    font-size: 1.1rem;
    margin-bottom: 0.75rem;
    color: var(--color-primary);
    border-bottom: 2px solid var(--color-primary);
    padding-bottom: 0.5rem;
}

.tech-category ul {
    margin: 0;
    padding: 0;
    list-style: none;
}

.tech-category li {
    padding: 0.5rem 0;
    border-bottom: 1px solid var(--color-border);
    font-size: 0.95rem;
}

.tech-category li:last-child {
    border-bottom: none;
}

/* Feature Grid */
.feature-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 1.5rem;
    margin-top: 1.5rem;
}

.feature-card {
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    padding: 1.5rem;
    transition: transform 0.2s ease;
}

.feature-card:hover {
    transform: translateY(-2px);
}

.feature-icon {
    font-size: 2.5rem;
    margin-bottom: 0.75rem;
}

.feature-card h3 {
    font-size: 1.15rem;
    margin-bottom: 0.75rem;
    color: var(--color-text);
}

.feature-details {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--color-border);
    font-size: 0.875rem;
    color: var(--color-text-muted);
}

.feature-details code {
    background: var(--color-bg);
    padding: 0.125rem 0.25rem;
    border-radius: 3px;
    font-size: 0.9em;
}

/* Admin Features */
.admin-features {
    display: grid;
    gap: 1rem;
    margin-top: 1.5rem;
}

.admin-feature {
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    padding: 1.25rem;
}

.admin-feature h3 {
    font-size: 1.1rem;
    margin-bottom: 0.5rem;
    color: var(--color-text);
}

.admin-feature code {
    background: var(--color-bg);
    padding: 0.125rem 0.375rem;
    border-radius: 3px;
    font-size: 0.85em;
    color: var(--color-primary);
}

/* Configuration Tables */
.config-section {
    margin-top: 1.5rem;
}

.config-section h3 {
    font-size: 1.15rem;
    margin-bottom: 1rem;
    color: var(--color-text);
}

.config-table {
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    overflow: hidden;
}

.config-row {
    display: grid;
    grid-template-columns: minmax(200px, 1fr) 2fr auto;
    gap: 1rem;
    padding: 1rem;
    border-bottom: 1px solid var(--color-border);
    align-items: center;
}

.config-row:last-child {
    border-bottom: none;
}

.config-row code {
    background: var(--color-bg);
    padding: 0.25rem 0.5rem;
    border-radius: 3px;
    font-size: 0.85rem;
    color: var(--color-primary);
    word-break: break-all;
}

.config-row em {
    font-size: 0.85rem;
    color: var(--color-text-muted);
    white-space: nowrap;
}

/* Deployment Section */
.deployment-section {
    margin-top: 1.5rem;
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    padding: 1.5rem;
}

.deployment-section h3 {
    font-size: 1.15rem;
    margin-bottom: 1rem;
    color: var(--color-primary);
}

.deployment-section ol {
    margin: 0;
    padding-left: 1.5rem;
}

.deployment-section li {
    margin-bottom: 0.5rem;
}

.deployment-section ul {
    margin: 0.5rem 0 0 0;
    padding-left: 1.5rem;
}

/* Principles Grid */
.principles-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    margin-top: 1.5rem;
}

.principle {
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    padding: 1.5rem;
}

.principle h3 {
    font-size: 1.1rem;
    margin-bottom: 0.75rem;
    color: var(--color-text);
}

.principle p {
    font-size: 0.95rem;
    margin: 0;
}

/* Model Grid */
.model-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    margin-top: 1.5rem;
}

.model-card {
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    padding: 1.5rem;
}

.model-card h3 {
    color: var(--color-primary);
    margin-bottom: 0.5rem;
    font-size: 1.2rem;
}

.model-fields {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--color-border);
    font-size: 0.875rem;
    color: var(--color-text-muted);
}

.model-fields code {
    background: var(--color-bg);
    padding: 0.125rem 0.25rem;
    border-radius: 3px;
    margin-right: 0.25rem;
}

/* API Table */
.api-table {
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    overflow: hidden;
    margin-top: 1rem;
}

.api-row {
    display: grid;
    grid-template-columns: minmax(200px, auto) 1fr;
    gap: 1rem;
    padding: 1rem;
    border-bottom: 1px solid var(--color-border);
    align-items: center;
}

.api-row:last-child {
    border-bottom: none;
}

.api-row code {
    background: var(--color-bg);
    padding: 0.375rem 0.625rem;
    border-radius: 3px;
    font-size: 0.9rem;
    color: var(--color-primary);
    font-weight: 500;
}

/* Quick Start */
.quickstart {
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    padding: 1.5rem;
    margin-top: 1rem;
}

.quickstart h3 {
    font-size: 1.1rem;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
    color: var(--color-primary);
}

.quickstart h3:first-child {
    margin-top: 0;
}

.quickstart pre {
    background: var(--color-bg);
    padding: 1rem;
    border-radius: var(--radius);
    overflow-x: auto;
    margin: 0.5rem 0;
}

.quickstart code {
    font-size: 0.9rem;
    line-height: 1.6;
}

.warning-box {
    background: #fef3cd;
    border: 1px solid #ffc107;
    border-radius: var(--radius);
    padding: 1rem;
    margin-top: 1rem;
    color: #856404;
}

/* Stats Section */
.stats-section {
    text-align: center;
}

.stats-grid {
    display: flex;
    justify-content: center;
    gap: 2rem;
    flex-wrap: wrap;
    margin-top: 1.5rem;
}

.stat-card {
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    padding: 1.5rem 2.5rem;
    min-width: 140px;
}

.stat-value {
    font-size: 2.5rem;
    font-weight: bold;
    color: var(--color-primary);
}

.stat-label {
    font-size: 0.95rem;
    color: var(--color-text-muted);
    margin-top: 0.25rem;
}

/* GitHub Link */
.github-link {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: var(--color-primary);
    color: white;
    padding: 0.75rem 1.5rem;
    border-radius: var(--radius);
    text-decoration: none;
    font-weight: 500;
    transition: background 0.2s ease, transform 0.2s ease;
}

.github-link:hover {
    background: var(--color-primary-dark, #1a5490);
    transform: translateY(-1px);
    color: white;
    text-decoration: none;
}

/* Footer */
.about-footer {
    text-align: center;
    padding: calc(var(--spacing) * 2) 0;
    margin-top: calc(var(--spacing) * 2);
    border-top: 1px solid var(--color-border);
}

.about-footer p {
    margin: 0.5rem 0;
}

.version-info {
    color: var(--color-text-muted);
}

/* Responsive Adjustments */
@media (max-width: 768px) {
    .about-header h1 {
        font-size: 2rem;
    }

    .about-tagline {
        font-size: 1.1rem;
    }

    .about-section h2 {
        font-size: 1.5rem;
    }

    .config-row {
        grid-template-columns: 1fr;
        gap: 0.5rem;
    }

    .config-row em {
        white-space: normal;
    }

    .api-row {
        grid-template-columns: 1fr;
        gap: 0.5rem;
    }

    .stats-grid {
        gap: 1rem;
    }

    .stat-card {
        padding: 1rem 1.5rem;
        min-width: 100px;
    }

    .stat-value {
        font-size: 2rem;
    }
}

@media (max-width: 480px) {
    .about-page {
        padding: 0 0.75rem;
    }

    .arch-card,
    .feature-card,
    .principle,
    .model-card {
        padding: 1rem;
    }

    .quickstart {
        padding: 1rem;
    }

    .quickstart pre {
        padding: 0.75rem;
        font-size: 0.8rem;
    }
}


================================================================================
FILE: src/MyBlog.Web/Components/Pages/Admin/UserEditor.razor.css
SIZE: 1.32 KB
MODIFIED: 2026-01-01 21:17:11
================================================================================

/* Container styling */
.user-editor {
    width: 100%;
    /* margin: 0 auto; if you want it centered */
    padding: 1rem;
    box-sizing: border-box; /* Ensures padding doesn't add to width */
}

/* Form group layout */
.form-group {
    display: flex;
    flex-direction: column; /* Stack label above input by default (mobile first) */
    margin-bottom: 1.25rem;
}

.form-group label {
    font-weight: bold;
    margin-bottom: 0.5rem;
}

.form-group input {
    width: 100%; /* Forces input to stay within container bounds */
    padding: 0.75rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-sizing: border-box; 
}

/* Error Message */
.error-message {
    background-color: #fee2e2;
    color: #dc2626;
    padding: 1rem;
    border-radius: 4px;
    margin-bottom: 1.5rem;
    border: 1px solid #fca5a5;
}

/* Actions area */
.form-actions {
    display: flex;
    gap: 1rem;
    align-items: center;
}

/* Desktop optimization: Switch to side-by-side if screen is wide enough */
@media (min-width: 768px) {
    .form-group {
        flex-direction: row; /* Label and Input side-by-side */
        align-items: center;
    }

    .form-group label {
        flex: 0 0 150px; /* Label takes fixed width on desktop */
        margin-bottom: 0;
    }

    .form-group input {
        flex: 1; /* Input fills remaining space */
    }
}


================================================================================
FILE: src/MyBlog.Web/Components/Pages/Admin/UserList.razor.css
SIZE: 1.41 KB
MODIFIED: 2026-01-01 22:33:51
================================================================================

/* Responsive Table Alternative */
.responsive-user-list {
    display: flex;
    flex-direction: column;
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    overflow: hidden;
}

.list-header {
    display: flex;
    background-color: var(--color-bg-alt);
    font-weight: bold;
    padding: 1rem;
    border-bottom: 2px solid var(--color-border);
}

.list-row {
    display: flex;
    padding: 1rem;
    border-bottom: 1px solid var(--color-border);
    background-color: var(--color-bg);
}

.list-row:last-child { border-bottom: none; }
.col, .list-item { flex: 1; min-width: 0; }
.actions { text-align: right; flex: 0 0 180px; }

.mobile-label { display: none; font-weight: bold; margin-right: 0.5rem; }
.current-user-badge { color: var(--color-text-muted); font-size: 0.85rem; }

/* Mobile view: Stack columns into rows */
@media (max-width: 768px) {
    .d-none-mobile { display: none; }
    
    .list-row {
        flex-direction: column;
        gap: 0.5rem;
        padding: 1.5rem 1rem;
    }

    .list-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        text-align: left;
    }

    .mobile-label { display: inline-block; }
    .actions { 
        flex: 1; 
        margin-top: 1rem; 
        padding-top: 1rem; 
        border-top: 1px dashed var(--color-border);
        text-align: left;
        justify-content: flex-start;
        gap: 10px;
    }
}


================================================================================
FILE: src/MyBlog.Web/Components/Pages/PostDetail.razor.css
SIZE: .55 KB
MODIFIED: 2026-01-19 20:24:14
================================================================================

/* PostDetail.razor.css */

.share-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.875rem;
    color: var(--color-text-muted);
    /* Reset button styles if not already handled by btn-link */
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
}

.share-btn:hover {
    color: var(--color-primary);
    text-decoration: underline;
}

.share-btn svg {
    margin-top: -2px; /* Fine-tune icon alignment */
}

.share-btn.success {
    color: var(--color-success);
}

article {
    word-break: break-word;
}


================================================================================
FILE: src/MyBlog.Web/Components/Shared/Footer.razor.css
SIZE: .61 KB
MODIFIED: 2026-01-13 20:55:51
================================================================================

/* Note: You can still use the variables defined in site.css :root here! */

.footer {
    background-color: var(--color-bg-alt);
    border-top: 1px solid var(--color-border);
    padding: var(--spacing) 0;
    text-align: center;
    color: var(--color-text-muted);
}

.footer-link {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin-top: 0.5rem;
    color: var(--color-text-muted);
    text-decoration: none;
    transition: color 0.2s ease;
}

.footer-link:hover {
    color: var(--color-primary);
    text-decoration: underline;
}

.footer-link svg {
    flex-shrink: 0;
}


================================================================================
FILE: src/MyBlog.Web/Components/Shared/PostCard.razor.css
SIZE: .03 KB
MODIFIED: 2026-01-19 20:24:56
================================================================================

article {
    word-break: break-word;
}


================================================================================
FILE: src/MyBlog.Web/Components/Shared/ReaderBadge.razor.css
SIZE: .52 KB
MODIFIED: 2026-01-13 21:06:07
================================================================================

/* Reader Badge */
.reader-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    color: var(--color-text-muted);
    background-color: var(--color-bg-alt);
    padding: 0.25rem 0.5rem;
    border-radius: var(--radius);
    border: 1px solid var(--color-border);
}

.reader-dot {
    color: var(--color-success);
    font-size: 1.2em;
    line-height: 0.5;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.4; }
    100% { opacity: 1; }
}


================================================================================
FILE: src/MyBlog.Web/Hubs/ReaderHub.cs
SIZE: 1.39 KB
MODIFIED: 2026-01-16 20:30:48
================================================================================

using Microsoft.AspNetCore.SignalR;
using MyBlog.Core.Interfaces;

namespace MyBlog.Web.Hubs;

public class ReaderHub : Hub
{
    private readonly IReaderTrackingService _trackingService;

    public ReaderHub(IReaderTrackingService trackingService)
    {
        _trackingService = trackingService;
    }

    public async Task JoinPage(string slug)
    {
        // Add this connection to the SignalR group for this slug
        await Groups.AddToGroupAsync(Context.ConnectionId, slug);

        // Update state
        var newCount = _trackingService.JoinPost(slug, Context.ConnectionId);

        // Broadcast new count to everyone in this group
        await Clients.Group(slug).SendAsync("UpdateCount", newCount);
    }

    public async Task LeavePage(string slug)
    {
        await Groups.RemoveFromGroupAsync(Context.ConnectionId, slug);

        var newCount = _trackingService.LeavePost(slug, Context.ConnectionId);

        await Clients.Group(slug).SendAsync("UpdateCount", newCount);
    }

    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        // Handle abrupt disconnects (tab closed, network lost)
        var (slug, newCount) = _trackingService.Disconnect(Context.ConnectionId);

        if (!string.IsNullOrEmpty(slug))
        {
            await Clients.Group(slug).SendAsync("UpdateCount", newCount);
        }

        await base.OnDisconnectedAsync(exception);
    }
}


================================================================================
FILE: src/MyBlog.Web/Middleware/LoginRateLimitMiddleware.cs
SIZE: 5.64 KB
MODIFIED: 2026-01-11 12:43:24
================================================================================

using System.Collections.Concurrent;

namespace MyBlog.Web.Middleware;

/// <summary>
/// Rate limiting middleware for login attempts.
/// Slows down requests but NEVER blocks users completely.
/// </summary>
public sealed class LoginRateLimitMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<LoginRateLimitMiddleware> _logger;
    private readonly Func<TimeSpan, CancellationToken, Task>? _delayFunc;

    // Track attempts per IP: IP -> (attempt count, window start)
    private static readonly ConcurrentDictionary<string, (int Count, DateTime WindowStart)> Attempts = new();

    // Configuration
    private const int WindowMinutes = 15;
    private const int AttemptsBeforeDelay = 5;
    private const int MaxDelaySeconds = 30;

    // Use this for the standard DI activation
    [ActivatorUtilitiesConstructor]
    public LoginRateLimitMiddleware(RequestDelegate next, ILogger<LoginRateLimitMiddleware> logger)
        : this(next, logger, null)
    {
    }

    /// <summary>
    /// Constructor with injectable delay function for testing.
    /// </summary>
    public LoginRateLimitMiddleware(
        RequestDelegate next,
        ILogger<LoginRateLimitMiddleware> logger,
        Func<TimeSpan, CancellationToken, Task>? delayFunc)
    {
        _next = next;
        _logger = logger;
        _delayFunc = delayFunc;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Only rate limit POST requests to login endpoint
        if (!IsLoginPostRequest(context))
        {
            await _next(context);
            return;
        }

        var ip = GetClientIp(context);
        var delay = CalculateDelay(ip);

        if (delay > TimeSpan.Zero)
        {
            _logger.LogInformation(
                "Rate limiting login attempt from {IP}, delaying {Seconds}s",
                ip, delay.TotalSeconds);

            // Use injected delay function if available (for testing), otherwise real delay
            if (_delayFunc != null)
            {
                await _delayFunc(delay, context.RequestAborted);
            }
            else
            {
                await Task.Delay(delay, context.RequestAborted);
            }
        }

        // Always proceed - never block
        await _next(context);

        // Record the attempt after processing
        RecordAttempt(ip);
    }

    private static bool IsLoginPostRequest(HttpContext context)
    {
        return context.Request.Method == HttpMethods.Post &&
               context.Request.Path.StartsWithSegments("/login", StringComparison.OrdinalIgnoreCase);
    }

    private static string GetClientIp(HttpContext context)
    {
        // Check for forwarded IP (behind proxy/load balancer)
        var forwardedFor = context.Request.Headers["X-Forwarded-For"].FirstOrDefault();
        if (!string.IsNullOrEmpty(forwardedFor))
        {
            var ip = forwardedFor.Split(',')[0].Trim();
            if (!string.IsNullOrEmpty(ip))
            {
                return ip;
            }
        }

        return context.Connection.RemoteIpAddress?.ToString() ?? "unknown";
    }

    /// <summary>
    /// Calculates the delay for a given IP. Exposed for testing.
    /// </summary>
    public static TimeSpan CalculateDelay(string ip)
    {
        if (!Attempts.TryGetValue(ip, out var record))
        {
            return TimeSpan.Zero;
        }

        // Reset if window expired
        if (DateTime.UtcNow - record.WindowStart > TimeSpan.FromMinutes(WindowMinutes))
        {
            Attempts.TryRemove(ip, out _);
            return TimeSpan.Zero;
        }

        // No delay for first few attempts
        if (record.Count < AttemptsBeforeDelay)
        {
            return TimeSpan.Zero;
        }

        // Progressive delay: 1s, 2s, 4s, 8s, ... capped at MaxDelaySeconds
        var delayMultiplier = record.Count - AttemptsBeforeDelay;
        var delaySeconds = Math.Min(Math.Pow(2, delayMultiplier), MaxDelaySeconds);
        return TimeSpan.FromSeconds(delaySeconds);
    }

    /// <summary>
    /// Records a login attempt for the given IP. Exposed for testing.
    /// </summary>
    internal static void RecordAttempt(string ip)
    {
        var now = DateTime.UtcNow;

        Attempts.AddOrUpdate(
            ip,
            _ => (1, now),
            (_, existing) =>
            {
                // Reset window if expired
                if (now - existing.WindowStart > TimeSpan.FromMinutes(WindowMinutes))
                {
                    return (1, now);
                }
                return (existing.Count + 1, existing.WindowStart);
            });

        // Cleanup old entries periodically (every 100th request)
        if (Random.Shared.Next(100) == 0)
        {
            CleanupOldEntries();
        }
    }

    /// <summary>
    /// Clears all tracked attempts. For testing only.
    /// </summary>
    public static void ClearAttempts()
    {
        Attempts.Clear();
    }

    private static void CleanupOldEntries()
    {
        var cutoff = DateTime.UtcNow.AddMinutes(-WindowMinutes * 2);
        foreach (var kvp in Attempts)
        {
            if (kvp.Value.WindowStart < cutoff)
            {
                Attempts.TryRemove(kvp.Key, out _);
            }
        }
    }
}

/// <summary>
/// Extension methods for LoginRateLimitMiddleware.
/// </summary>
public static class LoginRateLimitMiddlewareExtensions
{
    /// <summary>
    /// Adds login rate limiting middleware that slows down repeated attempts
    /// but never completely blocks users.
    /// </summary>
    public static IApplicationBuilder UseLoginRateLimit(this IApplicationBuilder app)
    {
        return app.UseMiddleware<LoginRateLimitMiddleware>();
    }
}


================================================================================
FILE: src/MyBlog.Web/MyBlog.Web.csproj
SIZE: .62 KB
MODIFIED: 2026-01-16 20:29:40
================================================================================

<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <RootNamespace>MyBlog.Web</RootNamespace>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.SignalR.Client" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\MyBlog.Infrastructure\MyBlog.Infrastructure.csproj" />
  </ItemGroup>
</Project>

================================================================================
FILE: src/MyBlog.Web/Program.cs
SIZE: 3.82 KB
MODIFIED: 2026-01-20 09:17:33
================================================================================

using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.Cookies;
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Constants;
using MyBlog.Core.Interfaces;
using MyBlog.Infrastructure;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Telemetry;
using MyBlog.Web.Components;
using MyBlog.Web.Hubs;
using MyBlog.Web.Middleware;
using OpenTelemetry;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

// Register SignalR
builder.Services.AddSignalR();

builder.Services.AddInfrastructure(builder.Configuration);

// Configure authentication
var sessionTimeout = builder.Configuration.GetValue("Authentication:SessionTimeoutMinutes", 30);
builder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie(options =>
    {
        options.Cookie.Name = AppConstants.AuthCookieName;
        options.LoginPath = "/login";
        options.LogoutPath = "/logout";
        options.AccessDeniedPath = "/access-denied";
        options.ExpireTimeSpan = TimeSpan.FromMinutes(sessionTimeout);
        options.SlidingExpiration = true;
        options.Cookie.HttpOnly = true;
        options.Cookie.SecurePolicy = builder.Configuration.GetValue("Application:RequireHttps", false)
            ? CookieSecurePolicy.Always
            : CookieSecurePolicy.SameAsRequest;
    });

builder.Services.AddAuthorization();
builder.Services.AddCascadingAuthenticationState();
builder.Services.AddHttpContextAccessor();
builder.Services.AddAntiforgery();

// OpenTelemetry configuration
var serviceName = "MyBlog.Web";
var serviceVersion = typeof(Program).Assembly.GetName().Version?.ToString() ?? "1.0.0";

builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService(serviceName: serviceName, serviceVersion: serviceVersion))
    .WithTracing(tracing => tracing
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddSource(serviceName)
        .AddConsoleExporter())
    .WithMetrics(metrics => metrics
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter());

// Configure logging with OpenTelemetry
// Note: We only add the FileLogExporter here since it doesn't require DI.
// Database logging is handled by the TelemetryCleanupService which has access to the DI container.
var telemetryDir = TelemetryPathResolver.GetTelemetryDirectory();
builder.Logging.AddOpenTelemetry(logging =>
{
    logging.IncludeFormattedMessage = true;
    logging.IncludeScopes = true;
    logging.AddConsoleExporter();

    if (telemetryDir is not null)
    {
        var logsPath = Path.Combine(telemetryDir, "logs");
        Directory.CreateDirectory(logsPath);
        logging.AddProcessor(new BatchLogRecordExportProcessor(new FileLogExporter(logsPath)));
    }
});

var app = builder.Build();

// Initialize database
using (var scope = app.Services.CreateScope())
{
    var db = scope.ServiceProvider.GetRequiredService<BlogDbContext>();
    await db.Database.MigrateAsync();

    var authService = scope.ServiceProvider.GetRequiredService<IAuthService>();
    await authService.EnsureAdminUserAsync();
}

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}

app.UseStaticFiles();
app.UseAntiforgery();

app.UseAuthentication();
app.UseAuthorization();

app.UseLoginRateLimit();

app.MapPost("/logout", async (HttpContext context) =>
{
    await context.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);
    return Results.Redirect("/");
}).RequireAuthorization();

app.MapHub<ReaderHub>("/readerHub");

app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();

app.Run();


================================================================================
FILE: src/MyBlog.Web/wwwroot/css/site.css
SIZE: 9.13 KB
MODIFIED: 2026-01-13 21:08:53
================================================================================

/* =============================================================================
   MyBlog CSS - Custom styles without any framework
   ============================================================================= */

/* CSS Variables for theming */
:root {
    --color-bg: #ffffff;
    --color-bg-alt: #f8f9fa;
    --color-text: #212529;
    --color-text-muted: #6c757d;
    --color-primary: #0d6efd;
    --color-primary-hover: #0b5ed7;
    --color-border: #dee2e6;
    --color-danger: #dc3545;
    --color-success: #198754;
    --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    --font-mono: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    --max-width: 1200px;
    --spacing: 1rem;
    --radius: 0.375rem;
}

/* Reset and base styles */
*, *::before, *::after {
    box-sizing: border-box;
}

html {
    font-size: 16px;
    line-height: 1.5;
}

body {
    margin: 0;
    font-family: var(--font-sans);
    color: var(--color-text);
    background-color: var(--color-bg);
}

h1, h2, h3, h4, h5, h6 {
    margin-top: 0;
    margin-bottom: 0.5em;
    font-weight: 600;
    line-height: 1.2;
}

h1 { font-size: 2.5rem; }
h2 { font-size: 2rem; }
h3 { font-size: 1.5rem; }

p {
    margin-top: 0;
    margin-bottom: 1rem;
}

a {
    color: var(--color-primary);
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

/* Container */
.container {
    max-width: var(--max-width);
    margin: 0 auto;
    padding: 0 var(--spacing);
}

/* Layout */
.layout {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Header */
.header {
    background-color: var(--color-bg-alt);
    border-bottom: 1px solid var(--color-border);
    padding: var(--spacing) 0;
}

.header .container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--spacing);
}

.logo {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-text);
}

.logo:hover {
    text-decoration: none;
}

.nav {
    display: flex;
    gap: var(--spacing);
    align-items: center;
}

.nav a {
    color: var(--color-text);
}

.logout-form {
    display: inline;
}

.logout-form button {
    background: none;
    border: none;
    color: var(--color-primary);
    cursor: pointer;
    font: inherit;
    padding: 0;
}

.logout-form button:hover {
    text-decoration: underline;
}

/* Main content */
.main {
    flex: 1;
    padding: calc(var(--spacing) * 2) 0;
}



/* Buttons */
.btn {
    display: inline-block;
    padding: 0.5rem 1rem;
    background-color: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    color: var(--color-text);
    cursor: pointer;
    font: inherit;
    text-decoration: none;
    transition: background-color 0.2s;
}

.btn:hover {
    background-color: var(--color-border);
    text-decoration: none;
}

.btn-primary {
    background-color: var(--color-primary);
    border-color: var(--color-primary);
    color: white;
}

.btn-primary:hover {
    background-color: var(--color-primary-hover);
}

.btn-link {
    background: none;
    border: none;
    color: var(--color-primary);
    cursor: pointer;
    padding: 0;
    font: inherit;
}

.btn-link:hover {
    text-decoration: underline;
}

.btn-link.danger {
    color: var(--color-danger);
}

/* Forms */
.form-group {
    margin-bottom: var(--spacing);
}

.form-group label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: 500;
}

.form-group input[type="text"],
.form-group input[type="password"],
.form-group input[type="email"],
.form-group textarea {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    font: inherit;
}

.form-group textarea {
    resize: vertical;
}

.form-group.checkbox label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.form-group.checkbox input {
    width: auto;
}

.form-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: var(--spacing);
}

/* Post cards */
.post-list {
    display: flex;
    flex-direction: column;
    gap: calc(var(--spacing) * 2);
}

.post-card {
    padding: var(--spacing);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
}

.post-card-title {
    margin-bottom: 0.5rem;
}

.post-card-title a {
    color: var(--color-text);
}

.post-card-meta {
    color: var(--color-text-muted);
    font-size: 0.875rem;
    margin-bottom: 0.5rem;
}

.post-card-meta span {
    margin-right: 1rem;
}

.draft-badge {
    background-color: var(--color-text-muted);
    color: white;
    padding: 0.125rem 0.5rem;
    border-radius: var(--radius);
    font-size: 0.75rem;
}

.read-more {
    font-weight: 500;
}

/* Pagination */
.pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: var(--spacing);
    margin-top: calc(var(--spacing) * 2);
}

.page-info {
    color: var(--color-text-muted);
}

/* Post detail */
.post-detail {
    max-width: 800px;
}

.post-header {
    margin-bottom: calc(var(--spacing) * 2);
}

.post-meta {
    color: var(--color-text-muted);
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
}

.post-meta .date,
.post-meta .author {
    margin-right: 0;
}

.back-link {
    display: inline-block;
    margin-top: calc(var(--spacing) * 2);
}

/* Markdown content */
.markdown-content {
    line-height: 1.7;
}

.markdown-content h1,
.markdown-content h2,
.markdown-content h3,
.markdown-content h4,
.markdown-content h5,
.markdown-content h6 {
    margin-top: 1.5em;
}

.markdown-content pre {
    background-color: var(--color-bg-alt);
    padding: var(--spacing);
    border-radius: var(--radius);
    overflow-x: auto;
}

.markdown-content code {
    font-family: var(--font-mono), source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;
    font-size: 0.875em;
}

.markdown-content :not(pre) > code {
    background-color: var(--color-bg-alt);
    padding: 0.125rem 0.25rem;
    border-radius: 0.25rem;
}

.markdown-content blockquote {
    border-left: 4px solid var(--color-border);
    margin: 0;
    padding-left: var(--spacing);
    color: var(--color-text-muted);
}

.markdown-content img {
    max-width: 100%;
    height: auto;
}

.markdown-content hr {
    border: none;
    border-top: 1px solid var(--color-border);
    margin: calc(var(--spacing) * 2) 0;
}

/* Login page */
.login-page {
    max-width: 400px;
    margin: 0 auto;
}

.error-message {
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
    color: #842029;
    padding: var(--spacing);
    border-radius: var(--radius);
    margin-bottom: var(--spacing);
}

/* Admin styles */
.dashboard-stats {
    display: flex;
    gap: var(--spacing);
    margin-bottom: calc(var(--spacing) * 2);
}

.stat-card {
    padding: var(--spacing);
    background-color: var(--color-bg-alt);
    border-radius: var(--radius);
    text-align: center;
}

.stat-value {
    font-size: 2rem;
    font-weight: 700;
    margin: 0;
}

.admin-nav {
    display: flex;
    gap: 0.5rem;
    margin-bottom: calc(var(--spacing) * 2);
}

.admin-table {
    width: 100%;
    border-collapse: collapse;
}

.admin-table th,
.admin-table td {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 1px solid var(--color-border);
}

.admin-table th {
    background-color: var(--color-bg-alt);
    font-weight: 600;
}

/* Post editor */
.post-editor {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: calc(var(--spacing) * 2);
}

.editor-preview {
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    padding: var(--spacing);
    max-height: 80vh;
    overflow-y: auto;
}

.editor-preview h3 {
    margin-bottom: var(--spacing);
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--color-border);
}

/* Image manager */
.image-upload {
    margin-bottom: calc(var(--spacing) * 2);
    padding: var(--spacing);
    background-color: var(--color-bg-alt);
    border-radius: var(--radius);
}

.image-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: var(--spacing);
}

.image-card {
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    overflow: hidden;
}

.image-card img {
    width: 100%;
    height: 150px;
    object-fit: cover;
}

.image-info {
    padding: 0.5rem;
}

.image-info p {
    margin: 0 0 0.25rem;
    font-size: 0.875rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.image-info code {
    display: block;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    margin-bottom: 0.25rem;
}

.success {
    color: var(--color-success);
}

.error {
    color: var(--color-danger);
}

/* Responsive */
@media (max-width: 768px) {
    h1 { font-size: 2rem; }
    h2 { font-size: 1.5rem; }

    .header .container {
        flex-direction: column;
        text-align: center;
    }

    .nav {
        flex-wrap: wrap;
        justify-content: center;
    }

    .post-editor {
        grid-template-columns: 1fr;
    }

    .editor-preview {
        order: -1;
        max-height: 300px;
    }

    .dashboard-stats {
        flex-direction: column;
    }

    .admin-nav {
        flex-wrap: wrap;
    }
}


===============================================================================
EXPORT COMPLETED: Tue Jan 20 09:18:44 AM EST 2026
Total Files Found: 72
Files Exported: 72
Files Skipped: 0 (binary or large files)
Output File: /home/kushal/src/dotnet/MyBlog/docs/llm/dump.txt
===============================================================================
