===============================================================================
PROJECT EXPORT
Generated: Sun Dec 28 01:12:19 PM CST 2025
Project Path: /home/kushal/src/dotnet/MyBlog
===============================================================================

DIRECTORY STRUCTURE:
===================

.
├── docs
│   └── llm
│       ├── output
│       │   ├── 0001.txt
│       │   ├── 0002.txt
│       │   ├── 0003.txt
│       │   ├── 0004.txt
│       │   └── 0005.txt
│       ├── chatgpt.md
│       ├── claude.md
│       ├── dump.txt
│       ├── gemini.md
│       ├── kush.runasp.net-WebDeploy.publishSettings
│       ├── login-har.json
│       └── open-telemetry-hello-world.txt
├── .github
│   └── workflows
│       └── build-deploy.yml
├── src
│   ├── .github
│   │   └── workflows
│   │       └── build-deploy.yml
│   ├── MyBlog.Core
│   │   ├── Constants
│   │   │   └── AppConstants.cs
│   │   ├── Interfaces
│   │   │   ├── IAuthService.cs
│   │   │   ├── IImageRepository.cs
│   │   │   ├── IMarkdownService.cs
│   │   │   ├── IPasswordService.cs
│   │   │   ├── IPostRepository.cs
│   │   │   ├── ISlugService.cs
│   │   │   ├── ITelemetryLogRepository.cs
│   │   │   └── IUserRepository.cs
│   │   ├── Models
│   │   │   ├── Image.cs
│   │   │   ├── Post.cs
│   │   │   ├── PostDto.cs
│   │   │   ├── TelemetryLog.cs
│   │   │   └── User.cs
│   │   ├── Services
│   │   │   ├── MarkdownService.cs
│   │   │   └── SlugService.cs
│   │   └── MyBlog.Core.csproj
│   ├── MyBlog.Infrastructure
│   │   ├── Data
│   │   │   ├── BlogDbContext.cs
│   │   │   └── DatabasePathResolver.cs
│   │   ├── Repositories
│   │   │   ├── ImageRepository.cs
│   │   │   ├── PostRepository.cs
│   │   │   ├── TelemetryLogRepository.cs
│   │   │   └── UserRepository.cs
│   │   ├── Services
│   │   │   ├── AuthService.cs
│   │   │   ├── PasswordService.cs
│   │   │   └── TelemetryCleanupService.cs
│   │   ├── Telemetry
│   │   │   ├── DatabaseLogExporter.cs
│   │   │   ├── FileLogExporter.cs
│   │   │   └── TelemetryPathResolver.cs
│   │   ├── MyBlog.Infrastructure.csproj
│   │   └── ServiceCollectionExtensions.cs
│   ├── MyBlog.Tests
│   │   ├── Integration
│   │   │   ├── AuthServiceLongPasswordTests.cs
│   │   │   ├── AuthServiceTests.cs
│   │   │   ├── PasswordChangeTests.cs
│   │   │   ├── PostRepositoryTests.cs
│   │   │   └── TelemetryCleanupTests.cs
│   │   ├── Unit
│   │   │   ├── LoginRateLimitMiddlewareTests.cs
│   │   │   ├── MarkdownServiceTests.cs
│   │   │   ├── PasswordServiceTests.cs
│   │   │   └── SlugServiceTests.cs
│   │   └── MyBlog.Tests.csproj
│   ├── MyBlog.Web
│   │   ├── Components
│   │   │   ├── Layout
│   │   │   │   └── MainLayout.razor
│   │   │   ├── Pages
│   │   │   │   ├── Admin
│   │   │   │   │   ├── ChangePassword.razor
│   │   │   │   │   ├── Dashboard.razor
│   │   │   │   │   ├── ImageManager.razor
│   │   │   │   │   ├── PostEditor.razor
│   │   │   │   │   └── PostList.razor
│   │   │   │   ├── About.razor
│   │   │   │   ├── Home.razor
│   │   │   │   ├── Login.razor
│   │   │   │   ├── Logout.razor
│   │   │   │   └── PostDetail.razor
│   │   │   ├── Shared
│   │   │   │   ├── MarkdownRenderer.razor
│   │   │   │   ├── Pagination.razor
│   │   │   │   ├── PostCard.razor
│   │   │   │   └── RedirectToLogin.razor
│   │   │   ├── App.razor
│   │   │   ├── _Imports.razor
│   │   │   └── Routes.razor
│   │   ├── Middleware
│   │   │   └── LoginRateLimitMiddleware.cs
│   │   ├── wwwroot
│   │   │   └── css
│   │   │       └── site.css
│   │   ├── appsettings.Development.json
│   │   ├── appsettings.json
│   │   ├── MyBlog.Web.csproj
│   │   └── Program.cs
│   ├── Directory.Build.props
│   ├── Directory.Packages.props
│   ├── .editorconfig
│   ├── fix-changepassword-and-tests.sh
│   ├── fix-rate-limit.sh
│   ├── generate-myblog.sh
│   ├── .gitkeep
│   ├── global.json
│   ├── MyBlog.slnx
│   ├── run.sh
│   ├── test.sh
│   └── upgrade-myblog.sh
├── export.sh
├── .gitignore
└── README.md


FILE CONTENTS:
==============

================================================================================
FILE: export.sh
SIZE: 8.50 KB
MODIFIED: 2025-12-28 06:47:30
================================================================================

#!/bin/bash
# =============================================================================
# Complete Project Export for LLM Analysis
# =============================================================================
# Exports all relevant source files, configs, and documentation for AI review.
# Excludes: binaries, build outputs, IDE files, packages, git internals
# =============================================================================

set -e

OUTPUT_DIR="docs/llm"
OUTPUT_FILE="$OUTPUT_DIR/dump.txt"
PROJECT_PATH="$(pwd)"

# File extensions to include (comprehensive list for .NET/Avalonia projects)
# Source code
SOURCE_EXTS="cs|fs|vb"
# XAML/Avalonia UI
XAML_EXTS="axaml|xaml|paml"
# Project/Build files
PROJECT_EXTS="csproj|fsproj|vbproj|slnx|sln|props|targets|tasks"
# Config files
CONFIG_EXTS="json|yaml|yml|xml|config|settings"
# Documentation
DOC_EXTS="md|txt|rst|adoc"
# Scripts
SCRIPT_EXTS="sh|ps1|psm1|cmd|bat"
# Web/Style (in case of Avalonia web or styling)
STYLE_EXTS="css|scss|sass|less"
# Data/Templates
DATA_EXTS="sql|csv|resx|resources"
# Docker/CI
DEVOPS_EXTS="dockerfile|dockerignore|editorconfig|gitignore|gitattributes"

# Combine all extensions
ALL_EXTS="$SOURCE_EXTS|$XAML_EXTS|$PROJECT_EXTS|$CONFIG_EXTS|$DOC_EXTS|$SCRIPT_EXTS|$STYLE_EXTS|$DATA_EXTS"

# Directories to exclude
EXCLUDE_DIRS="bin|obj|.git|.vs|.idea|.vscode|node_modules|packages|TestResults|coverage|publish|artifacts|.nuget|wwwroot/lib"

# Files to exclude (patterns)
EXCLUDE_FILES="*.Designer.cs|*.g.cs|*.g.i.cs|AssemblyInfo.cs|*.min.js|*.min.css|package-lock.json|*.lock|*.bak"

echo "=============================================="
echo "  Project Export for LLM Analysis"
echo "=============================================="
echo ""
echo "Project Path: $PROJECT_PATH"
echo "Output File:  $OUTPUT_FILE"
echo ""

mkdir -p "$OUTPUT_DIR"

# Start output file
{
    echo "==============================================================================="
    echo "PROJECT EXPORT"
    echo "Generated: $(date)"
    echo "Project Path: $PROJECT_PATH"
    echo "==============================================================================="
    echo ""
} > "$OUTPUT_FILE"

# Directory structure
echo "Generating directory structure..."
{
    echo "DIRECTORY STRUCTURE:"
    echo "==================="
    echo ""
    # Try tree first, fall back to find
    if command -v tree &> /dev/null; then
        tree -a -I "$EXCLUDE_DIRS" --noreport --dirsfirst 2>/dev/null || echo "(tree command failed)"
    else
        find . -type d \( -name "bin" -o -name "obj" -o -name ".git" -o -name ".vs" -o -name ".idea" -o -name "node_modules" -o -name "packages" -o -name "TestResults" \) -prune -o -type f -print | sed 's|[^/]*/|  |g' | sort
    fi
    echo ""
    echo ""
} >> "$OUTPUT_FILE"

# Build the find command dynamically
echo "Collecting files..."

# Create a temporary file for the file list
TMPFILE=$(mktemp)

# Find all relevant files
find . -type f \( \
    -iname "*.cs" -o \
    -iname "*.fs" -o \
    -iname "*.vb" -o \
    -iname "*.axaml" -o \
    -iname "*.xaml" -o \
    -iname "*.paml" -o \
    -iname "*.csproj" -o \
    -iname "*.fsproj" -o \
    -iname "*.vbproj" -o \
    -iname "*.slnx" -o \
    -iname "*.sln" -o \
    -iname "*.props" -o \
    -iname "*.targets" -o \
    -iname "*.json" -o \
    -iname "*.yaml" -o \
    -iname "*.yml" -o \
    -iname "*.xml" -o \
    -iname "*.config" -o \
    -iname "*.md" -o \
    -iname "*.txt" -o \
    -iname "*.sh" -o \
    -iname "*.ps1" -o \
    -iname "*.cmd" -o \
    -iname "*.bat" -o \
    -iname "*.sql" -o \
    -iname "*.resx" -o \
    -iname "*.css" -o \
    -iname "*.scss" -o \
    -iname "*.manifest" -o \
    -iname "*.ico" -o \
    -iname "Dockerfile" -o \
    -iname "docker-compose*.yml" -o \
    -iname ".editorconfig" -o \
    -iname ".gitignore" -o \
    -iname ".gitattributes" -o \
    -iname "global.json" -o \
    -iname "nuget.config" -o \
    -iname "Directory.Build.props" -o \
    -iname "Directory.Build.targets" -o \
    -iname "Directory.Packages.props" \
    \) \
    ! -path "*/bin/*" \
    ! -path "*/obj/*" \
    ! -path "*/docs/*" \
    ! -path "*/.git/*" \
    ! -path "*/.vs/*" \
    ! -path "*/.idea/*" \
    ! -path "*/.vscode/*" \
    ! -path "*/node_modules/*" \
    ! -path "*/packages/*" \
    ! -path "*/TestResults/*" \
    ! -path "*/coverage/*" \
    ! -path "*/publish/*" \
    ! -path "*/artifacts/*" \
    ! -path "*/.nuget/*" \
    ! -name "*.Designer.cs" \
    ! -name "*.g.cs" \
    ! -name "*.g.i.cs" \
    ! -name "*.min.js" \
    ! -name "*.min.css" \
    ! -name "package-lock.json" \
    ! -name "*.bak" \
    2>/dev/null | sort > "$TMPFILE"

FILE_COUNT=$(wc -l < "$TMPFILE")
echo "Found $FILE_COUNT files to export"
echo ""

# Add file contents header
{
    echo "FILE CONTENTS:"
    echo "=============="
    echo ""
} >> "$OUTPUT_FILE"

# Process each file
COUNTER=0
SKIPPED=0

while IFS= read -r file; do
    COUNTER=$((COUNTER + 1))
    FILENAME="${file#./}"
    
    # Skip binary files (check if file is text)
    if file "$file" | grep -qE "binary|executable|data|image"; then
        # For some files we want to note they exist but not dump contents
        if [[ "$file" =~ \.(ico|png|jpg|jpeg|gif|bmp|svg|woff|woff2|ttf|eot)$ ]]; then
            SKIPPED=$((SKIPPED + 1))
            echo "Skipping binary ($COUNTER/$FILE_COUNT): $FILENAME"
            {
                echo "================================================================================"
                echo "FILE: $FILENAME"
                echo "TYPE: [BINARY FILE - Contents not exported]"
                echo "================================================================================"
                echo ""
            } >> "$OUTPUT_FILE"
            continue
        fi
    fi
    
    # Get file info
    FILESIZE=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")
    MODIFIED=$(stat -c%y "$file" 2>/dev/null | cut -d'.' -f1 || stat -f"%Sm" -t "%Y-%m-%d %H:%M:%S" "$file" 2>/dev/null || echo "unknown")
    
    # Skip very large files (>500KB) - they're probably not source code
    if [ "$FILESIZE" -gt 512000 ]; then
        SKIPPED=$((SKIPPED + 1))
        echo "Skipping large file ($COUNTER/$FILE_COUNT): $FILENAME ($(echo "scale=0; $FILESIZE/1024" | bc)KB)"
        {
            echo "================================================================================"
            echo "FILE: $FILENAME"
            echo "SIZE: $(echo "scale=2; $FILESIZE/1024" | bc) KB"
            echo "TYPE: [LARGE FILE - Contents not exported, exceeds 500KB limit]"
            echo "================================================================================"
            echo ""
        } >> "$OUTPUT_FILE"
        continue
    fi
    
    echo "Processing ($COUNTER/$FILE_COUNT): $FILENAME"
    
    {
        echo "================================================================================"
        echo "FILE: $FILENAME"
        echo "SIZE: $(echo "scale=2; $FILESIZE/1024" | bc 2>/dev/null || echo "0.00") KB"
        echo "MODIFIED: $MODIFIED"
        echo "================================================================================"
        echo ""
        cat "$file" 2>/dev/null || echo "[ERROR: Could not read file]"
        echo ""
        echo ""
    } >> "$OUTPUT_FILE"
    
done < "$TMPFILE"

# Cleanup
rm -f "$TMPFILE"

# Summary
EXPORTED=$((COUNTER - SKIPPED))
{
    echo "==============================================================================="
    echo "EXPORT COMPLETED: $(date)"
    echo "Total Files Found: $FILE_COUNT"
    echo "Files Exported: $EXPORTED"
    echo "Files Skipped: $SKIPPED (binary or large files)"
    echo "Output File: $PROJECT_PATH/$OUTPUT_FILE"
    echo "==============================================================================="
} >> "$OUTPUT_FILE"

# Final output
OUTPUT_SIZE=$(stat -c%s "$OUTPUT_FILE" 2>/dev/null || stat -f%z "$OUTPUT_FILE" 2>/dev/null || echo "0")

echo ""
echo "=============================================="
echo "  Export Complete!"
echo "=============================================="
echo ""
echo "Output file:    $OUTPUT_FILE"
echo "Files exported: $EXPORTED"
echo "Files skipped:  $SKIPPED"
echo "Output size:    $(echo "scale=2; $OUTPUT_SIZE/1024" | bc 2>/dev/null || echo "?") KB"
echo ""
echo "File types included:"
echo "  • Source code: .cs, .fs, .vb"
echo "  • UI/XAML: .axaml, .xaml, .paml"
echo "  • Projects: .csproj, .slnx, .sln, .props, .targets"
echo "  • Config: .json, .yaml, .yml, .xml, .config"
echo "  • Docs: .md, .txt"
echo "  • Scripts: .sh, .ps1, .cmd, .bat"
echo "  • Other: .sql, .resx, .css, .scss, Dockerfile, etc."
echo ""


================================================================================
FILE: .github/workflows/build-deploy.yml
SIZE: 3.10 KB
MODIFIED: 2025-12-28 10:34:13
================================================================================

name: Build, Test, and Deploy

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

jobs:
  build-test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore dependencies
        run: dotnet restore src/MyBlog.slnx

      - name: Build solution
        run: dotnet build src/MyBlog.slnx -c Release --no-restore

      - name: Run tests
        run: dotnet test src/MyBlog.slnx -c Release --no-build --logger trx --results-directory TestResults

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.os }}
          path: TestResults
          retention-days: 7

  deploy:
    needs: build-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Publish application
        run: dotnet publish src/MyBlog.Web/MyBlog.Web.csproj -c Release -o ./publish -r win-x86 --self-contained false

      - name: Deploy via WebDeploy
        shell: pwsh
        env:
          DEPLOY_SOURCE: ${{ github.workspace }}\publish
          DEPLOY_SITE: ${{ secrets.WEBSITE_NAME }}
          DEPLOY_HOST: ${{ secrets.SERVER_COMPUTER_NAME }}
          DEPLOY_USER: ${{ secrets.SERVER_USERNAME }}
          DEPLOY_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
        run: |
          $msdeployPath = "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe"
          
          if (-not (Test-Path $msdeployPath)) {
            Write-Host "Installing Web Deploy..."
            choco install webdeploy -y --no-progress
          }
          
          Write-Host "Deploying to $env:DEPLOY_HOST..."
          Write-Host "Note: Using AppOffline rule to prevent file-in-use errors"

          $sourceArg = "-source:contentPath=$env:DEPLOY_SOURCE"
          $destArg = "-dest:contentPath=$env:DEPLOY_SITE,computerName=https://$($env:DEPLOY_HOST):8172/MsDeploy.axd?site=$env:DEPLOY_SITE,userName=$env:DEPLOY_USER,password=$env:DEPLOY_PASSWORD,AuthType='Basic'"
          
          # Key fix: Added -enableRule:AppOffline to stop the app during deployment
          # This creates app_offline.htm, waits for app to stop, deploys, then removes the file
          & $msdeployPath -verb:sync $sourceArg $destArg `
            -allowUntrusted `
            -enableRule:DoNotDeleteRule `
            -enableRule:AppOffline `
            -retryAttempts:3 `
            -retryInterval:3000
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Deployment failed with exit code $LASTEXITCODE"
            exit 1
          }
          
          Write-Host "Deployment completed successfully!"


================================================================================
FILE: .gitignore
SIZE: 7.84 KB
MODIFIED: 2025-12-28 07:05:03
================================================================================

## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from `dotnet new gitignore`

# dotenv files
.env

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET
project.lock.json
project.fragment.lock.json
artifacts/

# Tye
.tye/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
# but not Directory.Build.rsp, as it configures directory-level build defaults
!Directory.Build.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.tlog
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio 6 auto-generated project file (contains which files were open etc.)
*.vbp

# Visual Studio 6 workspace and project file (working project files containing files to include in project)
*.dsw
*.dsp

# Visual Studio 6 technical files
*.ncb
*.aps

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# Visual Studio History (VSHistory) files
.vshistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

# VS Code files for those working on multiple tools
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# Windows Installer files from build outputs
*.cab
*.msi
*.msix
*.msm
*.msp

# JetBrains Rider
*.sln.iml
.idea/

##
## Visual studio for Mac
##


# globs
Makefile.in
*.userprefs
*.usertasks
config.make
config.status
aclocal.m4
install-sh
autom4te.cache/
*.tar.gz
tarballs/
test-results/

# content below from: https://github.com/github/gitignore/blob/main/Global/macOS.gitignore
# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# content below from: https://github.com/github/gitignore/blob/main/Global/Windows.gitignore
# Windows thumbnail cache files
Thumbs.db
ehthumbs.db
ehthumbs_vista.db

# Dump file
*.stackdump

# Folder config file
[Dd]esktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Windows Installer files
*.cab
*.msi
*.msix
*.msm
*.msp

# Windows shortcuts
*.lnk

# Vim temporary swap files
*.swp


*.publishSettings


================================================================================
FILE: README.md
SIZE: 6.51 KB
MODIFIED: 2025-12-28 10:45:04
================================================================================

# MyBlog

A lightweight, self-hosted blogging platform built with .NET 10 and Blazor Server.

## Features

- **Markdown-based content**: Write posts in Markdown with live preview
- **Image management**: Upload and manage images stored in the database
- **Admin dashboard**: Manage posts, images, and settings
- **OpenTelemetry**: Built-in observability with file-based telemetry export
- **Cross-platform**: Runs on Windows, Linux, and macOS
- **CI/CD ready**: GitHub Actions workflow for automated testing and deployment

## Quick Start

### Prerequisites

- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0) or later

### Running Locally

```bash
# Clone the repository
git clone https://github.com/yourusername/dotnetcms.git
cd dotnetcms/src

# Restore and run
dotnet restore MyBlog.slnx
cd MyBlog.Web
dotnet run
```

The application will start at `http://localhost:5000` (or the next available port).

### Default Credentials

- **Username**: `admin`
- **Password**: `ChangeMe123!` (or value of `MYBLOG_ADMIN_PASSWORD` environment variable)

> **Important**: The default password is only used when creating the initial admin user. Once the user exists, you must change the password through the website.

## Configuration

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `MYBLOG_ADMIN_PASSWORD` | Initial admin password (only used on first run) | `ChangeMe123!` |
| `ASPNETCORE_ENVIRONMENT` | Runtime environment | `Production` |

### appsettings.json

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=myblog.db"
  },
  "Authentication": {
    "SessionTimeoutMinutes": 30,
    "DefaultAdminPassword": "ChangeMe123!"
  },
  "Application": {
    "Title": "MyBlog"
  }
}
```

### Database Location

The SQLite database is stored in a platform-specific location:

| Platform | Path |
|----------|------|
| Linux | `~/.local/share/MyBlog/myblog.db` |
| macOS | `~/Library/Application Support/MyBlog/myblog.db` |
| Windows | `%LOCALAPPDATA%\MyBlog\myblog.db` |

## Admin Features

### Dashboard (`/admin`)

The admin dashboard provides an overview of your blog with quick access to all management features.

### Managing Posts

- **Create Post** (`/admin/posts/new`): Write a new blog post in Markdown
- **Edit Post** (`/admin/posts/edit/{id}`): Modify existing posts
- **Post List** (`/admin/posts`): View and manage all posts

### Managing Images

- **Upload Images** (`/admin/images`): Upload images to use in posts
- **Image Library**: Browse and delete uploaded images
- **Usage**: Reference images in Markdown using `/api/images/{id}`

### Changing Your Password

Navigate to `/admin/change-password` to change your admin password:

1. Enter your current password
2. Enter your new password (minimum 8 characters)
3. Confirm the new password
4. Click "Change Password"

> **Note**: The `MYBLOG_ADMIN_PASSWORD` environment variable only affects the initial password when the admin user is first created. It does not override existing passwords.

## Deployment

### GitHub Actions (Automated)

The repository includes a GitHub Actions workflow that:

1. Builds and tests on Windows, Linux, and macOS
2. Deploys to your server via WebDeploy (on main/master/develop branches)

#### Required Secrets

Set these in your repository settings under **Settings > Secrets and variables > Actions**:

| Secret | Description | Example |
|--------|-------------|---------|
| `WEBSITE_NAME` | IIS site name | `MyBlog` |
| `SERVER_COMPUTER_NAME` | Server hostname | `myserver.example.com` |
| `SERVER_USERNAME` | WebDeploy username | `deploy-user` |
| `SERVER_PASSWORD` | WebDeploy password | (your password) |

#### Repository Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `MYBLOG_ADMIN_PASSWORD` | Initial admin password | (strong password) |

> **Note**: `MYBLOG_ADMIN_PASSWORD` should be set as a **secret**, not a variable, if you want it to remain hidden in logs.

### Manual Deployment

```bash
# Publish for Windows
dotnet publish src/MyBlog.Web/MyBlog.Web.csproj -c Release -o ./publish -r win-x64

# Publish for Linux
dotnet publish src/MyBlog.Web/MyBlog.Web.csproj -c Release -o ./publish -r linux-x64
```

Copy the contents of `./publish` to your server.

### IIS Configuration

1. Install the [.NET 10 Hosting Bundle](https://dotnet.microsoft.com/download/dotnet/10.0)
2. Create a new IIS site pointing to your publish folder
3. Set the Application Pool to "No Managed Code"
4. Ensure the Application Pool identity has write access to the database directory

## Troubleshooting

### ERROR_FILE_IN_USE During Deployment

This occurs when the application is running and DLLs are locked.

**Solution**: The workflow now includes `-enableRule:AppOffline` which automatically:
1. Creates `app_offline.htm` to stop the application
2. Waits for the app to release file locks
3. Deploys the new files
4. Removes `app_offline.htm` to restart the app

### Password Not Changing After Setting MYBLOG_ADMIN_PASSWORD

The environment variable only works when **no users exist** in the database.

**To reset with a new password**:

1. Stop the application
2. Delete the database file (see Database Location above)
3. Set `MYBLOG_ADMIN_PASSWORD` to your desired password
4. Start the application

Or, log in with the current password and use `/admin/change-password`.

### Database Locked Errors

SQLite can have locking issues with concurrent access.

**Solutions**:
- Ensure only one instance of the application is running
- Check that no database tools have the file open
- Verify file permissions on the database directory

## Development

### Running Tests

```bash
cd src
dotnet test MyBlog.slnx
```

### Project Structure

```
src/
├── MyBlog.Core/           # Domain models and interfaces
├── MyBlog.Infrastructure/ # Data access, services
├── MyBlog.Web/           # Blazor Server application
└── MyBlog.Tests/         # xUnit test project
```

### Adding New Features

1. Define interfaces in `MyBlog.Core/Interfaces`
2. Implement in `MyBlog.Infrastructure/Services`
3. Add UI in `MyBlog.Web/Components/Pages`
4. Write tests in `MyBlog.Tests`

## API Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/images/{id}` | GET | Retrieve an image by ID |

## License

MIT License - see [LICENSE](LICENSE) for details.

## Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request


================================================================================
FILE: src/Directory.Build.props
SIZE: .54 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

<Project>
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
    <AnalysisLevel>latest</AnalysisLevel>
  </PropertyGroup>
  
  <PropertyGroup Condition="$(MSBuildProjectName.Contains('.Tests'))">
    <IsPackable>false</IsPackable>
    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
  </PropertyGroup>
</Project>


================================================================================
FILE: src/Directory.Packages.props
SIZE: 1.29 KB
MODIFIED: 2025-12-28 08:40:28
================================================================================

<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
  </PropertyGroup>
  <ItemGroup>
    <!-- Core Framework (.NET 10) -->
    <PackageVersion Include="Microsoft.EntityFrameworkCore.Sqlite" Version="10.0.1" />
    <PackageVersion Include="Microsoft.EntityFrameworkCore.Design" Version="10.0.1" />
    <PackageVersion Include="Microsoft.AspNetCore.Identity" Version="2.3.1" />
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.1" />
    
    <!-- OpenTelemetry (official packages only) -->
    <PackageVersion Include="OpenTelemetry" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Exporter.Console" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Http" Version="1.14.0" />
    
    <!-- Testing (xUnit v3) -->
    <PackageVersion Include="xunit.v3" Version="3.2.1" />
    <PackageVersion Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
    <PackageVersion Include="xunit.runner.visualstudio" Version="3.1.5" />
  </ItemGroup>
</Project>

================================================================================
FILE: src/.editorconfig
SIZE: .52 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

root = true

[*]
indent_style = space
indent_size = 4
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.{cs,csx}]
dotnet_sort_system_directives_first = true
csharp_using_directive_placement = outside_namespace
csharp_style_namespace_declarations = file_scoped:warning
csharp_style_var_for_built_in_types = true:suggestion
csharp_style_var_when_type_is_apparent = true:suggestion
csharp_prefer_braces = true:warning

[*.{json,yaml,yml}]
indent_size = 2

[*.md]
trim_trailing_whitespace = false


================================================================================
FILE: src/fix-changepassword-and-tests.sh
SIZE: 27.35 KB
MODIFIED: 2025-12-28 11:09:48
================================================================================

#!/bin/bash
# =============================================================================
# Fix ChangePassword.razor form, add rate limiting, fix tests for Windows
# =============================================================================
set -euo pipefail

SRC_DIR="src"
SCRIPT_NAME=$(basename "$0")

echo "=============================================="
echo "  MyBlog: Complete Fix Script"
echo "=============================================="
echo ""

# =============================================================================
# Step 1: Fix ChangePassword.razor - Add name attributes and SupplyParameterFromForm
# =============================================================================
echo "[1/5] Fixing ChangePassword.razor form (adding name attributes)..."

cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Pages/Admin/ChangePassword.razor"
@page "/admin/change-password"
@attribute [Authorize]
@inject IAuthService AuthService
@inject IHttpContextAccessor HttpContextAccessor
@inject NavigationManager Navigation
@using System.Security.Claims

<PageTitle>Change Password</PageTitle>

<h1>Change Password</h1>

<div class="change-password-form">
    @if (!string.IsNullOrEmpty(_successMessage))
    {
        <div class="success-message">@_successMessage</div>
    }

    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="error-message">@_errorMessage</div>
    }

    <form method="post" @onsubmit="HandleSubmit" @formname="changepassword">
        <AntiforgeryToken />

        <div class="form-group">
            <label for="currentPassword">Current Password</label>
            <input type="password" id="currentPassword" name="currentPassword" @bind="_currentPassword" required />
        </div>

        <div class="form-group">
            <label for="newPassword">New Password</label>
            <input type="password" id="newPassword" name="newPassword" @bind="_newPassword" required minlength="8" />
            <small>Minimum 8 characters</small>
        </div>

        <div class="form-group">
            <label for="confirmPassword">Confirm New Password</label>
            <input type="password" id="confirmPassword" name="confirmPassword" @bind="_confirmPassword" required />
        </div>

        <div class="form-actions">
            <button type="submit" class="btn btn-primary">Change Password</button>
            <a href="/admin" class="btn btn-secondary">Cancel</a>
        </div>
    </form>
</div>

@code {
    private string _currentPassword = "";
    private string _newPassword = "";
    private string _confirmPassword = "";
    private string? _successMessage;
    private string? _errorMessage;

    [SupplyParameterFromForm(Name = "currentPassword")]
    public string? FormCurrentPassword { get; set; }

    [SupplyParameterFromForm(Name = "newPassword")]
    public string? FormNewPassword { get; set; }

    [SupplyParameterFromForm(Name = "confirmPassword")]
    public string? FormConfirmPassword { get; set; }

    private async Task HandleSubmit()
    {
        _successMessage = null;
        _errorMessage = null;

        // Use form values if available (SSR form post), otherwise use bound values
        var currentPassword = FormCurrentPassword ?? _currentPassword;
        var newPassword = FormNewPassword ?? _newPassword;
        var confirmPassword = FormConfirmPassword ?? _confirmPassword;

        // Validation
        if (string.IsNullOrWhiteSpace(newPassword) || newPassword.Length < 8)
        {
            _errorMessage = "New password must be at least 8 characters.";
            return;
        }

        if (newPassword != confirmPassword)
        {
            _errorMessage = "New password and confirmation do not match.";
            return;
        }

        if (currentPassword == newPassword)
        {
            _errorMessage = "New password must be different from current password.";
            return;
        }

        // Get current user ID
        var context = HttpContextAccessor.HttpContext;
        var userIdClaim = context?.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;

        if (string.IsNullOrEmpty(userIdClaim) || !Guid.TryParse(userIdClaim, out var userId))
        {
            _errorMessage = "Unable to identify current user. Please log in again.";
            return;
        }

        // Attempt password change
        var success = await AuthService.ChangePasswordAsync(userId, currentPassword, newPassword);

        if (success)
        {
            _successMessage = "Password changed successfully!";
            _currentPassword = "";
            _newPassword = "";
            _confirmPassword = "";
        }
        else
        {
            _errorMessage = "Current password is incorrect.";
        }
    }
}
EOF

echo "      Done."

# =============================================================================
# Step 2: Add rate limiting middleware (slows down but never blocks)
# =============================================================================
echo "[2/5] Adding rate limiting middleware..."

cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Middleware/LoginRateLimitMiddleware.cs"
using System.Collections.Concurrent;

namespace MyBlog.Web.Middleware;

/// <summary>
/// Rate limiting middleware for login attempts.
/// Slows down requests but NEVER blocks users completely.
/// </summary>
public sealed class LoginRateLimitMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<LoginRateLimitMiddleware> _logger;

    // Track attempts per IP: IP -> (attempt count, window start)
    private static readonly ConcurrentDictionary<string, (int Count, DateTime WindowStart)> _attempts = new();

    // Configuration
    private const int WindowMinutes = 15;
    private const int AttemptsBeforeDelay = 5;
    private const int MaxDelaySeconds = 30;

    public LoginRateLimitMiddleware(RequestDelegate next, ILogger<LoginRateLimitMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Only rate limit POST requests to login endpoint
        if (!IsLoginPostRequest(context))
        {
            await _next(context);
            return;
        }

        var ip = GetClientIp(context);
        var delay = CalculateDelay(ip);

        if (delay > TimeSpan.Zero)
        {
            _logger.LogInformation(
                "Rate limiting login attempt from {IP}, delaying {Seconds}s",
                ip, delay.TotalSeconds);
            await Task.Delay(delay, context.RequestAborted);
        }

        // Always proceed - never block
        await _next(context);

        // Record the attempt after processing
        RecordAttempt(ip);
    }

    private static bool IsLoginPostRequest(HttpContext context)
    {
        return context.Request.Method == HttpMethods.Post &&
               context.Request.Path.StartsWithSegments("/login", StringComparison.OrdinalIgnoreCase);
    }

    private static string GetClientIp(HttpContext context)
    {
        // Check for forwarded IP (behind proxy/load balancer)
        var forwardedFor = context.Request.Headers["X-Forwarded-For"].FirstOrDefault();
        if (!string.IsNullOrEmpty(forwardedFor))
        {
            var ip = forwardedFor.Split(',')[0].Trim();
            if (!string.IsNullOrEmpty(ip))
            {
                return ip;
            }
        }

        return context.Connection.RemoteIpAddress?.ToString() ?? "unknown";
    }

    private static TimeSpan CalculateDelay(string ip)
    {
        if (!_attempts.TryGetValue(ip, out var record))
        {
            return TimeSpan.Zero;
        }

        // Reset if window expired
        if (DateTime.UtcNow - record.WindowStart > TimeSpan.FromMinutes(WindowMinutes))
        {
            _attempts.TryRemove(ip, out _);
            return TimeSpan.Zero;
        }

        // No delay for first few attempts
        if (record.Count < AttemptsBeforeDelay)
        {
            return TimeSpan.Zero;
        }

        // Progressive delay: 1s, 2s, 4s, 8s, ... capped at MaxDelaySeconds
        var delayMultiplier = record.Count - AttemptsBeforeDelay;
        var delaySeconds = Math.Min(Math.Pow(2, delayMultiplier), MaxDelaySeconds);
        return TimeSpan.FromSeconds(delaySeconds);
    }

    private static void RecordAttempt(string ip)
    {
        var now = DateTime.UtcNow;

        _attempts.AddOrUpdate(
            ip,
            _ => (1, now),
            (_, existing) =>
            {
                // Reset window if expired
                if (now - existing.WindowStart > TimeSpan.FromMinutes(WindowMinutes))
                {
                    return (1, now);
                }
                return (existing.Count + 1, existing.WindowStart);
            });

        // Cleanup old entries periodically (every 100th request)
        if (Random.Shared.Next(100) == 0)
        {
            CleanupOldEntries();
        }
    }

    private static void CleanupOldEntries()
    {
        var cutoff = DateTime.UtcNow.AddMinutes(-WindowMinutes * 2);
        foreach (var kvp in _attempts)
        {
            if (kvp.Value.WindowStart < cutoff)
            {
                _attempts.TryRemove(kvp.Key, out _);
            }
        }
    }
}

/// <summary>
/// Extension methods for LoginRateLimitMiddleware.
/// </summary>
public static class LoginRateLimitMiddlewareExtensions
{
    /// <summary>
    /// Adds login rate limiting middleware that slows down repeated attempts
    /// but never completely blocks users.
    /// </summary>
    public static IApplicationBuilder UseLoginRateLimit(this IApplicationBuilder app)
    {
        return app.UseMiddleware<LoginRateLimitMiddleware>();
    }
}
EOF

echo "      Done."

# =============================================================================
# Step 3: Update Program.cs to use rate limiting
# =============================================================================
echo "[3/5] Updating Program.cs to use rate limiting middleware..."

# We need to add the middleware. Let's check if it exists and add it if not
if ! grep -q "UseLoginRateLimit" "$SRC_DIR/MyBlog.Web/Program.cs" 2>/dev/null; then
    # Add using statement at the top if not present
    if ! grep -q "using MyBlog.Web.Middleware" "$SRC_DIR/MyBlog.Web/Program.cs" 2>/dev/null; then
        sed -i '1s/^/using MyBlog.Web.Middleware;\n/' "$SRC_DIR/MyBlog.Web/Program.cs"
    fi
    
    # Add middleware after UseRouting (or after app is created if UseRouting doesn't exist)
    if grep -q "app.UseRouting" "$SRC_DIR/MyBlog.Web/Program.cs"; then
        sed -i '/app\.UseRouting/a app.UseLoginRateLimit();' "$SRC_DIR/MyBlog.Web/Program.cs"
    elif grep -q "app.UseAuthentication" "$SRC_DIR/MyBlog.Web/Program.cs"; then
        sed -i '/app\.UseAuthentication/i app.UseLoginRateLimit();' "$SRC_DIR/MyBlog.Web/Program.cs"
    fi
    echo "      Added UseLoginRateLimit() to middleware pipeline."
else
    echo "      UseLoginRateLimit() already present."
fi

echo "      Done."

# =============================================================================
# Step 4: Add tests using in-memory SQLite (Windows compatible)
# =============================================================================
echo "[4/5] Adding Windows-compatible tests (using in-memory SQLite)..."

cat << 'EOF' > "$SRC_DIR/MyBlog.Tests/Integration/AuthServiceLongPasswordTests.cs"
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;

namespace MyBlog.Tests.Integration;

/// <summary>
/// Tests for long password support and account lockout behavior.
/// Uses in-memory SQLite for cross-platform compatibility (Windows/Linux/macOS).
/// </summary>
public sealed class AuthServiceLongPasswordTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly AuthService _sut;
    private readonly PasswordService _passwordService;

    public AuthServiceLongPasswordTests()
    {
        // Use in-memory SQLite - works on all platforms without file locking issues
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _passwordService = new PasswordService();
        var userRepository = new UserRepository(_context);
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Authentication:DefaultAdminPassword"] = "TestAdmin123!"
            })
            .Build();

        _sut = new AuthService(userRepository, _passwordService, configuration);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    // =========================================================================
    // Long Password Tests (128+ characters)
    // =========================================================================

    [Fact]
    public async Task AuthenticateAsync_With128CharacterPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var longPassword = new string('a', 128);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "longpassuser",
            PasswordHash = _passwordService.HashPassword(longPassword),
            Email = "longpass@example.com",
            DisplayName = "Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("longpassuser", longPassword, ct);

        Assert.NotNull(result);
        Assert.Equal("longpassuser", result.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_With256CharacterPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var longPassword = new string('x', 256);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "verylongpassuser",
            PasswordHash = _passwordService.HashPassword(longPassword),
            Email = "verylong@example.com",
            DisplayName = "Very Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("verylongpassuser", longPassword, ct);

        Assert.NotNull(result);
        Assert.Equal("verylongpassuser", result.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_With512CharacterPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var longPassword = new string('P', 512);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "extralongpassuser",
            PasswordHash = _passwordService.HashPassword(longPassword),
            Email = "extralong@example.com",
            DisplayName = "Extra Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("extralongpassuser", longPassword, ct);

        Assert.NotNull(result);
        Assert.Equal("extralongpassuser", result.Username);
    }

    [Fact]
    public async Task ChangePasswordAsync_With128CharacterNewPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "ShortPass123!";
        var newLongPassword = new string('N', 128);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "changepasslonguser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "changelong@example.com",
            DisplayName = "Change Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.ChangePasswordAsync(user.Id, originalPassword, newLongPassword, ct);

        Assert.True(result);

        // Verify new password works
        var authenticated = await _sut.AuthenticateAsync("changepasslonguser", newLongPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task AuthenticateAsync_WithComplexLongPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        // Mix of characters, 200 chars long
        var complexPassword = string.Concat(
            new string('A', 50),
            new string('1', 50),
            new string('!', 50),
            new string('z', 50)
        );

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "complexpassuser",
            PasswordHash = _passwordService.HashPassword(complexPassword),
            Email = "complex@example.com",
            DisplayName = "Complex Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("complexpassuser", complexPassword, ct);

        Assert.NotNull(result);
    }

    // =========================================================================
    // No Account Lockout Tests
    // =========================================================================

    [Fact]
    public async Task AuthenticateAsync_After100FailedAttempts_StillAllowsLogin()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPassword123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "nolockoutuser",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "nolockout@example.com",
            DisplayName = "No Lockout User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Attempt 100 failed logins
        for (var i = 0; i < 100; i++)
        {
            var failedResult = await _sut.AuthenticateAsync("nolockoutuser", "WrongPassword", ct);
            Assert.Null(failedResult);
        }

        // User should still be able to log in with correct password
        var successResult = await _sut.AuthenticateAsync("nolockoutuser", correctPassword, ct);
        Assert.NotNull(successResult);
        Assert.Equal("nolockoutuser", successResult.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_After1000FailedAttempts_StillAllowsLogin()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPassword123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "nolockout1000user",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "nolockout1000@example.com",
            DisplayName = "No Lockout 1000 User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Attempt 1000 failed logins
        for (var i = 0; i < 1000; i++)
        {
            var failedResult = await _sut.AuthenticateAsync("nolockout1000user", $"WrongPassword{i}", ct);
            Assert.Null(failedResult);
        }

        // User should still be able to log in with correct password
        var successResult = await _sut.AuthenticateAsync("nolockout1000user", correctPassword, ct);
        Assert.NotNull(successResult);
        Assert.Equal("nolockout1000user", successResult.Username);
    }

    [Fact]
    public async Task ChangePasswordAsync_AfterManyFailedAttempts_StillWorks()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "NewPassword456!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "changepassnolockout",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "changepassnolockout@example.com",
            DisplayName = "Change Password No Lockout",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Attempt 50 failed password changes
        for (var i = 0; i < 50; i++)
        {
            var failedResult = await _sut.ChangePasswordAsync(user.Id, "WrongOldPassword", "NewPass", ct);
            Assert.False(failedResult);
        }

        // Should still be able to change password with correct current password
        var successResult = await _sut.ChangePasswordAsync(user.Id, originalPassword, newPassword, ct);
        Assert.True(successResult);

        // Verify new password works
        var authenticated = await _sut.AuthenticateAsync("changepassnolockout", newPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task AuthenticateAsync_InterleavedFailuresAndSuccesses_NeverLocks()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPassword123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "interleaveduser",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "interleaved@example.com",
            DisplayName = "Interleaved User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Interleave failed and successful attempts
        for (var i = 0; i < 20; i++)
        {
            // 5 failed attempts
            for (var j = 0; j < 5; j++)
            {
                var failedResult = await _sut.AuthenticateAsync("interleaveduser", "WrongPassword", ct);
                Assert.Null(failedResult);
            }

            // 1 successful attempt
            var successResult = await _sut.AuthenticateAsync("interleaveduser", correctPassword, ct);
            Assert.NotNull(successResult);
        }

        // Final successful login after 100 failed attempts total
        var finalResult = await _sut.AuthenticateAsync("interleaveduser", correctPassword, ct);
        Assert.NotNull(finalResult);
        Assert.Equal("interleaveduser", finalResult.Username);
    }
}
EOF

echo "      Done."

# =============================================================================
# Step 5: Add rate limiting middleware tests
# =============================================================================
echo "[5/5] Adding rate limiting middleware tests..."

cat << 'EOF' > "$SRC_DIR/MyBlog.Tests/Unit/LoginRateLimitMiddlewareTests.cs"
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using MyBlog.Web.Middleware;

namespace MyBlog.Tests.Unit;

/// <summary>
/// Tests for LoginRateLimitMiddleware.
/// Verifies that the middleware slows down but never blocks requests.
/// </summary>
public sealed class LoginRateLimitMiddlewareTests
{
    private readonly LoginRateLimitMiddleware _sut;
    private int _nextCallCount;

    public LoginRateLimitMiddlewareTests()
    {
        _nextCallCount = 0;
        RequestDelegate next = _ =>
        {
            _nextCallCount++;
            return Task.CompletedTask;
        };
        _sut = new LoginRateLimitMiddleware(next, NullLogger<LoginRateLimitMiddleware>.Instance);
    }

    [Fact]
    public async Task InvokeAsync_NonLoginRequest_PassesThroughImmediately()
    {
        var ct = TestContext.Current.CancellationToken;
        var context = CreateHttpContext("/api/posts", "GET");

        await _sut.InvokeAsync(context);

        Assert.Equal(1, _nextCallCount);
    }

    [Fact]
    public async Task InvokeAsync_GetLoginRequest_PassesThroughImmediately()
    {
        var ct = TestContext.Current.CancellationToken;
        var context = CreateHttpContext("/login", "GET");

        await _sut.InvokeAsync(context);

        Assert.Equal(1, _nextCallCount);
    }

    [Fact]
    public async Task InvokeAsync_FirstLoginAttempt_PassesThroughImmediately()
    {
        var ct = TestContext.Current.CancellationToken;
        var context = CreateHttpContext("/login", "POST", "192.168.1.100");

        var sw = System.Diagnostics.Stopwatch.StartNew();
        await _sut.InvokeAsync(context);
        sw.Stop();

        Assert.Equal(1, _nextCallCount);
        Assert.True(sw.ElapsedMilliseconds < 500, "First attempt should not be delayed");
    }

    [Fact]
    public async Task InvokeAsync_AfterManyAttempts_StillPassesThrough()
    {
        // Use unique IP to avoid interference from other tests
        var uniqueIp = $"10.0.0.{Random.Shared.Next(1, 255)}";

        // Make 20 requests - middleware should always pass through
        for (var i = 0; i < 20; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        // All 20 requests should have passed through
        Assert.Equal(20, _nextCallCount);
    }

    [Fact]
    public async Task InvokeAsync_NeverBlocksCompletely()
    {
        // Use unique IP
        var uniqueIp = $"10.0.1.{Random.Shared.Next(1, 255)}";

        // Even after 100 attempts, requests should pass through
        for (var i = 0; i < 100; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            
            // Use a timeout to ensure we're not blocked forever
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(60));
            try
            {
                await _sut.InvokeAsync(context);
            }
            catch (OperationCanceledException)
            {
                Assert.Fail($"Request {i} was blocked or timed out");
            }
        }

        Assert.Equal(100, _nextCallCount);
    }

    private static DefaultHttpContext CreateHttpContext(string path, string method, string? remoteIp = null)
    {
        var context = new DefaultHttpContext();
        context.Request.Path = path;
        context.Request.Method = method;
        
        if (remoteIp != null)
        {
            context.Connection.RemoteIpAddress = System.Net.IPAddress.Parse(remoteIp);
        }

        return context;
    }
}
EOF

echo "      Done."

echo ""
echo "=============================================="
echo "  Completed!"
echo "=============================================="
echo ""
echo "Changes made:"
echo ""
echo "  1. Fixed ChangePassword.razor:"
echo "     - Added 'name' attributes to all form inputs"
echo "     - Added [SupplyParameterFromForm] properties"
echo "     - Updated HandleSubmit to use form values"
echo ""
echo "  2. Added LoginRateLimitMiddleware:"
echo "     - Slows down repeated login attempts (progressive delay)"
echo "     - NEVER blocks users completely"
echo "     - First 5 attempts: no delay"
echo "     - After 5 attempts: 1s, 2s, 4s, 8s... delay (max 30s)"
echo "     - 15-minute sliding window"
echo ""
echo "  3. Updated Program.cs to use rate limiting"
echo ""
echo "  4. Fixed tests to use in-memory SQLite:"
echo "     - Changed from file-based SQLite to 'Data Source=:memory:'"
echo "     - This fixes Windows file locking issues"
echo "     - Works on Windows, Linux, and macOS"
echo ""
echo "  5. Added rate limiting middleware tests"
echo ""
echo "Next steps:"
echo "  1. Run: dotnet build"
echo "  2. Run: dotnet test"
echo ""


================================================================================
FILE: src/fix-rate-limit.sh
SIZE: 14.78 KB
MODIFIED: 2025-12-28 12:39:52
================================================================================

#!/bin/bash
# =============================================================================
# Fix Rate Limit Middleware Tests
# =============================================================================
# The tests are slow because they actually wait for real Task.Delay calls.
# Solution: Make the delay mechanism injectable so tests can skip the waits.
# =============================================================================

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SRC_DIR="$SCRIPT_DIR/src"

echo "=============================================="
echo "  Fixing Rate Limit Middleware Tests"
echo "=============================================="
echo ""

# =============================================================================
# Step 1: Replace the middleware with a testable version
# =============================================================================
echo "[1/2] Updating LoginRateLimitMiddleware to be testable..."

cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Middleware/LoginRateLimitMiddleware.cs"
using System.Collections.Concurrent;

namespace MyBlog.Web.Middleware;

/// <summary>
/// Rate limiting middleware for login attempts.
/// Slows down requests but NEVER blocks users completely.
/// </summary>
public sealed class LoginRateLimitMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<LoginRateLimitMiddleware> _logger;
    private readonly Func<TimeSpan, CancellationToken, Task>? _delayFunc;

    // Track attempts per IP: IP -> (attempt count, window start)
    private static readonly ConcurrentDictionary<string, (int Count, DateTime WindowStart)> _attempts = new();

    // Configuration
    private const int WindowMinutes = 15;
    private const int AttemptsBeforeDelay = 5;
    private const int MaxDelaySeconds = 30;

    public LoginRateLimitMiddleware(RequestDelegate next, ILogger<LoginRateLimitMiddleware> logger)
        : this(next, logger, null)
    {
    }

    /// <summary>
    /// Constructor with injectable delay function for testing.
    /// </summary>
    internal LoginRateLimitMiddleware(
        RequestDelegate next,
        ILogger<LoginRateLimitMiddleware> logger,
        Func<TimeSpan, CancellationToken, Task>? delayFunc)
    {
        _next = next;
        _logger = logger;
        _delayFunc = delayFunc;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Only rate limit POST requests to login endpoint
        if (!IsLoginPostRequest(context))
        {
            await _next(context);
            return;
        }

        var ip = GetClientIp(context);
        var delay = CalculateDelay(ip);

        if (delay > TimeSpan.Zero)
        {
            _logger.LogInformation(
                "Rate limiting login attempt from {IP}, delaying {Seconds}s",
                ip, delay.TotalSeconds);

            // Use injected delay function if available (for testing), otherwise real delay
            if (_delayFunc != null)
            {
                await _delayFunc(delay, context.RequestAborted);
            }
            else
            {
                await Task.Delay(delay, context.RequestAborted);
            }
        }

        // Always proceed - never block
        await _next(context);

        // Record the attempt after processing
        RecordAttempt(ip);
    }

    private static bool IsLoginPostRequest(HttpContext context)
    {
        return context.Request.Method == HttpMethods.Post &&
               context.Request.Path.StartsWithSegments("/login", StringComparison.OrdinalIgnoreCase);
    }

    private static string GetClientIp(HttpContext context)
    {
        // Check for forwarded IP (behind proxy/load balancer)
        var forwardedFor = context.Request.Headers["X-Forwarded-For"].FirstOrDefault();
        if (!string.IsNullOrEmpty(forwardedFor))
        {
            var ip = forwardedFor.Split(',')[0].Trim();
            if (!string.IsNullOrEmpty(ip))
            {
                return ip;
            }
        }

        return context.Connection.RemoteIpAddress?.ToString() ?? "unknown";
    }

    /// <summary>
    /// Calculates the delay for a given IP. Exposed for testing.
    /// </summary>
    internal static TimeSpan CalculateDelay(string ip)
    {
        if (!_attempts.TryGetValue(ip, out var record))
        {
            return TimeSpan.Zero;
        }

        // Reset if window expired
        if (DateTime.UtcNow - record.WindowStart > TimeSpan.FromMinutes(WindowMinutes))
        {
            _attempts.TryRemove(ip, out _);
            return TimeSpan.Zero;
        }

        // No delay for first few attempts
        if (record.Count < AttemptsBeforeDelay)
        {
            return TimeSpan.Zero;
        }

        // Progressive delay: 1s, 2s, 4s, 8s, ... capped at MaxDelaySeconds
        var delayMultiplier = record.Count - AttemptsBeforeDelay;
        var delaySeconds = Math.Min(Math.Pow(2, delayMultiplier), MaxDelaySeconds);
        return TimeSpan.FromSeconds(delaySeconds);
    }

    /// <summary>
    /// Records a login attempt for the given IP. Exposed for testing.
    /// </summary>
    internal static void RecordAttempt(string ip)
    {
        var now = DateTime.UtcNow;

        _attempts.AddOrUpdate(
            ip,
            _ => (1, now),
            (_, existing) =>
            {
                // Reset window if expired
                if (now - existing.WindowStart > TimeSpan.FromMinutes(WindowMinutes))
                {
                    return (1, now);
                }
                return (existing.Count + 1, existing.WindowStart);
            });

        // Cleanup old entries periodically (every 100th request)
        if (Random.Shared.Next(100) == 0)
        {
            CleanupOldEntries();
        }
    }

    /// <summary>
    /// Clears all tracked attempts. For testing only.
    /// </summary>
    internal static void ClearAttempts()
    {
        _attempts.Clear();
    }

    private static void CleanupOldEntries()
    {
        var cutoff = DateTime.UtcNow.AddMinutes(-WindowMinutes * 2);
        foreach (var kvp in _attempts)
        {
            if (kvp.Value.WindowStart < cutoff)
            {
                _attempts.TryRemove(kvp.Key, out _);
            }
        }
    }
}

/// <summary>
/// Extension methods for LoginRateLimitMiddleware.
/// </summary>
public static class LoginRateLimitMiddlewareExtensions
{
    /// <summary>
    /// Adds login rate limiting middleware that slows down repeated attempts
    /// but never completely blocks users.
    /// </summary>
    public static IApplicationBuilder UseLoginRateLimit(this IApplicationBuilder app)
    {
        return app.UseMiddleware<LoginRateLimitMiddleware>();
    }
}
EOF

echo "      Done."

# =============================================================================
# Step 2: Update the tests to use no-op delay
# =============================================================================
echo "[2/2] Updating tests to skip actual delays..."

cat << 'EOF' > "$SRC_DIR/MyBlog.Tests/Unit/LoginRateLimitMiddlewareTests.cs"
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging.Abstractions;
using MyBlog.Web.Middleware;

namespace MyBlog.Tests.Unit;

/// <summary>
/// Tests for LoginRateLimitMiddleware.
/// Verifies that the middleware slows down but never blocks requests.
/// </summary>
public sealed class LoginRateLimitMiddlewareTests : IDisposable
{
    private readonly LoginRateLimitMiddleware _sut;
    private int _nextCallCount;
    private readonly List<TimeSpan> _recordedDelays = [];

    public LoginRateLimitMiddlewareTests()
    {
        // Clear any state from previous tests
        LoginRateLimitMiddleware.ClearAttempts();

        _nextCallCount = 0;
        RequestDelegate next = _ =>
        {
            _nextCallCount++;
            return Task.CompletedTask;
        };

        // Use a no-op delay function that just records the delay
        // This makes tests fast while still verifying delay logic
        Task NoOpDelay(TimeSpan delay, CancellationToken ct)
        {
            _recordedDelays.Add(delay);
            return Task.CompletedTask;
        }

        _sut = new LoginRateLimitMiddleware(
            next,
            NullLogger<LoginRateLimitMiddleware>.Instance,
            NoOpDelay);
    }

    public void Dispose()
    {
        // Clean up after each test
        LoginRateLimitMiddleware.ClearAttempts();
    }

    [Fact]
    public async Task InvokeAsync_NonLoginRequest_PassesThroughImmediately()
    {
        var context = CreateHttpContext("/api/posts", "GET");

        await _sut.InvokeAsync(context);

        Assert.Equal(1, _nextCallCount);
        Assert.Empty(_recordedDelays);
    }

    [Fact]
    public async Task InvokeAsync_GetLoginRequest_PassesThroughImmediately()
    {
        var context = CreateHttpContext("/login", "GET");

        await _sut.InvokeAsync(context);

        Assert.Equal(1, _nextCallCount);
        Assert.Empty(_recordedDelays);
    }

    [Fact]
    public async Task InvokeAsync_FirstFiveAttempts_NoDelay()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // First 5 attempts should have no delay
        for (var i = 0; i < 5; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(5, _nextCallCount);
        Assert.Empty(_recordedDelays); // No delays for first 5 attempts
    }

    [Fact]
    public async Task InvokeAsync_SixthAttempt_HasOneSecondDelay()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make 6 attempts
        for (var i = 0; i < 6; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(6, _nextCallCount);
        Assert.Single(_recordedDelays);
        Assert.Equal(TimeSpan.FromSeconds(1), _recordedDelays[0]);
    }

    [Fact]
    public async Task InvokeAsync_ProgressiveDelays_IncreaseExponentially()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make 10 attempts: 5 no-delay + 5 with delays
        for (var i = 0; i < 10; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(10, _nextCallCount);
        Assert.Equal(5, _recordedDelays.Count); // Delays start after attempt 5

        // Verify exponential progression: 1s, 2s, 4s, 8s, 16s
        Assert.Equal(TimeSpan.FromSeconds(1), _recordedDelays[0]);
        Assert.Equal(TimeSpan.FromSeconds(2), _recordedDelays[1]);
        Assert.Equal(TimeSpan.FromSeconds(4), _recordedDelays[2]);
        Assert.Equal(TimeSpan.FromSeconds(8), _recordedDelays[3]);
        Assert.Equal(TimeSpan.FromSeconds(16), _recordedDelays[4]);
    }

    [Fact]
    public async Task InvokeAsync_DelayCappedAt30Seconds()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make enough attempts to hit the cap (5 no-delay + enough to exceed 30s)
        // After attempt 5: 1, 2, 4, 8, 16, 30, 30, 30...
        for (var i = 0; i < 15; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(15, _nextCallCount);

        // Verify cap at 30 seconds (attempts 11+ should all be 30s)
        var maxDelays = _recordedDelays.Where(d => d == TimeSpan.FromSeconds(30)).ToList();
        Assert.True(maxDelays.Count >= 4, "Should have multiple 30-second delays");
        Assert.True(_recordedDelays.All(d => d <= TimeSpan.FromSeconds(30)), "No delay should exceed 30 seconds");
    }

    [Fact]
    public async Task InvokeAsync_AfterManyAttempts_NeverBlocks()
    {
        var uniqueIp = $"10.0.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make 100 attempts - should all pass through (with delays, but never blocked)
        for (var i = 0; i < 100; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        // Key assertion: ALL requests passed through, none were blocked
        Assert.Equal(100, _nextCallCount);
    }

    [Fact]
    public async Task InvokeAsync_DifferentIPs_IndependentTracking()
    {
        var ip1 = $"10.1.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";
        var ip2 = $"10.2.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // 6 attempts from IP1 (should trigger delay on 6th)
        for (var i = 0; i < 6; i++)
        {
            var context = CreateHttpContext("/login", "POST", ip1);
            await _sut.InvokeAsync(context);
        }

        var ip1Delays = _recordedDelays.Count;
        Assert.Equal(1, ip1Delays); // One delay after 5th attempt

        // First attempt from IP2 should have no delay
        var context2 = CreateHttpContext("/login", "POST", ip2);
        await _sut.InvokeAsync(context2);

        // No new delays should have been added for IP2
        Assert.Equal(ip1Delays, _recordedDelays.Count);
    }

    [Fact]
    public void CalculateDelay_UnknownIP_ReturnsZero()
    {
        var delay = LoginRateLimitMiddleware.CalculateDelay("unknown-ip-never-seen");
        Assert.Equal(TimeSpan.Zero, delay);
    }

    private static DefaultHttpContext CreateHttpContext(string path, string method, string? remoteIp = null)
    {
        var context = new DefaultHttpContext();
        context.Request.Path = path;
        context.Request.Method = method;

        if (remoteIp != null)
        {
            context.Connection.RemoteIpAddress = System.Net.IPAddress.Parse(remoteIp);
        }

        return context;
    }
}
EOF

echo "      Done."

echo ""
echo "=============================================="
echo "  Fix Complete!"
echo "=============================================="
echo ""
echo "Changes made:"
echo ""
echo "  1. Updated LoginRateLimitMiddleware:"
echo "     - Added injectable delay function (internal constructor)"
echo "     - Added ClearAttempts() method for test isolation"
echo "     - Made CalculateDelay() internal for direct testing"
echo ""
echo "  2. Rewrote LoginRateLimitMiddlewareTests:"
echo "     - Uses no-op delay function (records delays but doesn't wait)"
echo "     - Tests run in milliseconds instead of minutes"
echo "     - Added IDisposable to clean up state between tests"
echo "     - Added more specific tests for delay progression"
echo ""
echo "The key insight: the old tests were actually calling Task.Delay()"
echo "with real delays (1s, 2s, 4s, 8s... 30s) for 100 iterations."
echo "That adds up to ~45+ minutes of waiting!"
echo ""
echo "Next steps:"
echo "  1. Run: chmod +x fix-rate-limit-tests.sh && ./fix-rate-limit-tests.sh"
echo "  2. Run: cd src && dotnet test"
echo ""


================================================================================
FILE: src/generate-myblog.sh
SIZE: 118.95 KB
MODIFIED: 2025-12-28 07:41:44
================================================================================

#!/bin/bash
set -euo pipefail

# =============================================================================
# MyBlog Generator Script
# =============================================================================
# This script generates a complete .NET 10 Blazor Server CMS/Blog application.
# It creates all source files, configurations, tests, and GitHub Actions workflows.
#
# Usage: bash src/generate-myblog.sh
# =============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SRC_DIR="$SCRIPT_DIR"

echo "=============================================="
echo "  MyBlog Generator - .NET 10 Blazor CMS"
echo "=============================================="
echo ""
echo "Target directory: $SRC_DIR"
echo "Starting generation at: $(date)"
echo ""

# =============================================================================
# Step 1: Create Directory Structure
# =============================================================================
echo "[1/8] Creating directory structure..."
echo "      WHY: Organizing code into separate projects follows clean architecture"
echo "           principles and enables independent testing and deployment."

mkdir -p "$SRC_DIR/MyBlog.Core/Models"
mkdir -p "$SRC_DIR/MyBlog.Core/Interfaces"
mkdir -p "$SRC_DIR/MyBlog.Core/Services"
mkdir -p "$SRC_DIR/MyBlog.Core/Constants"
mkdir -p "$SRC_DIR/MyBlog.Infrastructure/Data"
mkdir -p "$SRC_DIR/MyBlog.Infrastructure/Repositories"
mkdir -p "$SRC_DIR/MyBlog.Infrastructure/Services"
mkdir -p "$SRC_DIR/MyBlog.Infrastructure/Telemetry"
mkdir -p "$SRC_DIR/MyBlog.Web/Components/Layout"
mkdir -p "$SRC_DIR/MyBlog.Web/Components/Pages"
mkdir -p "$SRC_DIR/MyBlog.Web/Components/Pages/Admin"
mkdir -p "$SRC_DIR/MyBlog.Web/Components/Shared"
mkdir -p "$SRC_DIR/MyBlog.Web/wwwroot/css"
mkdir -p "$SRC_DIR/MyBlog.Tests/Unit"
mkdir -p "$SRC_DIR/MyBlog.Tests/Integration"
mkdir -p "$SRC_DIR/.github/workflows"

echo "      Created project directories."

# =============================================================================
# Step 2: Create Solution and Build Files
# =============================================================================
echo ""
echo "[2/8] Creating solution and build configuration files..."
echo "      WHY: Central package management ensures consistent versions across all"
echo "           projects and simplifies dependency updates."

# MyBlog.slnx - New .NET solution format
cat << 'EOF' > "$SRC_DIR/MyBlog.slnx"
<Solution>
  <Project Path="MyBlog.Core/MyBlog.Core.csproj" />
  <Project Path="MyBlog.Infrastructure/MyBlog.Infrastructure.csproj" />
  <Project Path="MyBlog.Web/MyBlog.Web.csproj" />
  <Project Path="MyBlog.Tests/MyBlog.Tests.csproj" />
</Solution>
EOF

# global.json - Pin SDK version
cat << 'EOF' > "$SRC_DIR/global.json"
{
  "sdk": {
    "version": "10.0.100",
    "rollForward": "latestFeature"
  }
}
EOF

# Directory.Build.props - Shared build properties
cat << 'EOF' > "$SRC_DIR/Directory.Build.props"
<Project>
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
    <AnalysisLevel>latest</AnalysisLevel>
  </PropertyGroup>
  
  <PropertyGroup Condition="$(MSBuildProjectName.Contains('.Tests'))">
    <IsPackable>false</IsPackable>
    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
  </PropertyGroup>
</Project>
EOF

# Directory.Packages.props - Central package management
cat << 'EOF' > "$SRC_DIR/Directory.Packages.props"
<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
  </PropertyGroup>
  <ItemGroup>
    <!-- Core Framework (.NET 10) -->
    <PackageVersion Include="Microsoft.EntityFrameworkCore.Sqlite" Version="10.0.1" />
    <PackageVersion Include="Microsoft.EntityFrameworkCore.Design" Version="10.0.1" />
    <PackageVersion Include="Microsoft.AspNetCore.Identity" Version="2.3.1" />
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.1" />
    
    <!-- OpenTelemetry (official packages only) -->
    <PackageVersion Include="OpenTelemetry" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.14.0" />
    
    <!-- Testing (xUnit v3) -->
    <PackageVersion Include="xunit.v3" Version="3.2.1" />
    <PackageVersion Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
  </ItemGroup>
</Project>
EOF

# .editorconfig
cat << 'EOF' > "$SRC_DIR/.editorconfig"
root = true

[*]
indent_style = space
indent_size = 4
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.{cs,csx}]
dotnet_sort_system_directives_first = true
csharp_using_directive_placement = outside_namespace
csharp_style_namespace_declarations = file_scoped:warning
csharp_style_var_for_built_in_types = true:suggestion
csharp_style_var_when_type_is_apparent = true:suggestion
csharp_prefer_braces = true:warning

[*.{json,yaml,yml}]
indent_size = 2

[*.md]
trim_trailing_whitespace = false
EOF

echo "      Created solution and build files."

# =============================================================================
# Step 3: Create MyBlog.Core Project
# =============================================================================
echo ""
echo "[3/8] Creating MyBlog.Core project (domain models and interfaces)..."
echo "      WHY: The Core project contains domain entities and interfaces with no"
echo "           external dependencies, enabling clean separation of concerns."

# MyBlog.Core.csproj
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/MyBlog.Core.csproj"
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>MyBlog.Core</RootNamespace>
  </PropertyGroup>
</Project>
EOF

# Models/User.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Models/User.cs"
namespace MyBlog.Core.Models;

/// <summary>
/// Represents a user who can create and manage blog posts.
/// </summary>
public sealed class User
{
    /// <summary>Gets or sets the unique identifier for the user.</summary>
    public Guid Id { get; set; }

    /// <summary>Gets or sets the unique username for authentication.</summary>
    public required string Username { get; set; }

    /// <summary>Gets or sets the hashed password.</summary>
    public required string PasswordHash { get; set; }

    /// <summary>Gets or sets the user's email address.</summary>
    public required string Email { get; set; }

    /// <summary>Gets or sets the display name shown on posts.</summary>
    public required string DisplayName { get; set; }

    /// <summary>Gets or sets when the user account was created.</summary>
    public DateTime CreatedAtUtc { get; set; }

    /// <summary>Navigation property for posts authored by this user.</summary>
    public ICollection<Post> Posts { get; set; } = [];

    /// <summary>Navigation property for images uploaded by this user.</summary>
    public ICollection<Image> UploadedImages { get; set; } = [];
}
EOF

# Models/Post.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Models/Post.cs"
namespace MyBlog.Core.Models;

/// <summary>
/// Represents a blog post with Markdown content.
/// </summary>
public sealed class Post
{
    /// <summary>Gets or sets the unique identifier for the post.</summary>
    public Guid Id { get; set; }

    /// <summary>Gets or sets the post title.</summary>
    public required string Title { get; set; }

    /// <summary>Gets or sets the URL-friendly slug.</summary>
    public required string Slug { get; set; }

    /// <summary>Gets or sets the Markdown content of the post.</summary>
    public required string Content { get; set; }

    /// <summary>Gets or sets a brief summary for listings.</summary>
    public required string Summary { get; set; }

    /// <summary>Gets or sets the author's user ID.</summary>
    public Guid AuthorId { get; set; }

    /// <summary>Gets or sets when the post was created.</summary>
    public DateTime CreatedAtUtc { get; set; }

    /// <summary>Gets or sets when the post was last updated.</summary>
    public DateTime UpdatedAtUtc { get; set; }

    /// <summary>Gets or sets when the post was published (null if draft).</summary>
    public DateTime? PublishedAtUtc { get; set; }

    /// <summary>Gets or sets whether the post is publicly visible.</summary>
    public bool IsPublished { get; set; }

    /// <summary>Navigation property for the author.</summary>
    public User? Author { get; set; }

    /// <summary>Navigation property for attached images.</summary>
    public ICollection<Image> Images { get; set; } = [];
}
EOF

# Models/Image.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Models/Image.cs"
namespace MyBlog.Core.Models;

/// <summary>
/// Represents an image stored as a BLOB in the database.
/// </summary>
public sealed class Image
{
    /// <summary>Gets or sets the unique identifier for the image.</summary>
    public Guid Id { get; set; }

    /// <summary>Gets or sets the original file name.</summary>
    public required string FileName { get; set; }

    /// <summary>Gets or sets the MIME content type.</summary>
    public required string ContentType { get; set; }

    /// <summary>Gets or sets the binary image data.</summary>
    public required byte[] Data { get; set; }

    /// <summary>Gets or sets the associated post ID (optional).</summary>
    public Guid? PostId { get; set; }

    /// <summary>Gets or sets when the image was uploaded.</summary>
    public DateTime UploadedAtUtc { get; set; }

    /// <summary>Gets or sets the ID of the user who uploaded the image.</summary>
    public Guid UploadedByUserId { get; set; }

    /// <summary>Navigation property for the associated post.</summary>
    public Post? Post { get; set; }

    /// <summary>Navigation property for the uploader.</summary>
    public User? UploadedBy { get; set; }
}
EOF

# Models/TelemetryLog.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Models/TelemetryLog.cs"
namespace MyBlog.Core.Models;

/// <summary>
/// Represents a telemetry log entry stored in the database.
/// </summary>
public sealed class TelemetryLog
{
    /// <summary>Gets or sets the auto-increment primary key.</summary>
    public int Id { get; set; }

    /// <summary>Gets or sets the UTC timestamp of the log entry.</summary>
    public DateTime TimestampUtc { get; set; }

    /// <summary>Gets or sets the log level (Information, Warning, Error, etc.).</summary>
    public required string Level { get; set; }

    /// <summary>Gets or sets the category/source of the log.</summary>
    public required string Category { get; set; }

    /// <summary>Gets or sets the log message.</summary>
    public required string Message { get; set; }

    /// <summary>Gets or sets the exception details if any.</summary>
    public string? Exception { get; set; }

    /// <summary>Gets or sets the distributed trace ID.</summary>
    public string? TraceId { get; set; }

    /// <summary>Gets or sets the span ID within the trace.</summary>
    public string? SpanId { get; set; }

    /// <summary>Gets or sets additional properties as JSON.</summary>
    public string? Properties { get; set; }
}
EOF

# DTOs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Models/PostDto.cs"
namespace MyBlog.Core.Models;

/// <summary>Data transfer object for post listings.</summary>
public sealed record PostListItemDto(
    Guid Id,
    string Title,
    string Slug,
    string Summary,
    string AuthorDisplayName,
    DateTime? PublishedAtUtc,
    bool IsPublished);

/// <summary>Data transfer object for creating a new post.</summary>
public sealed record CreatePostDto(
    string Title,
    string Content,
    string Summary,
    bool IsPublished);

/// <summary>Data transfer object for updating a post.</summary>
public sealed record UpdatePostDto(
    string Title,
    string Content,
    string Summary,
    bool IsPublished);

/// <summary>Data transfer object for post details.</summary>
public sealed record PostDetailDto(
    Guid Id,
    string Title,
    string Slug,
    string Content,
    string Summary,
    string AuthorDisplayName,
    DateTime CreatedAtUtc,
    DateTime UpdatedAtUtc,
    DateTime? PublishedAtUtc,
    bool IsPublished);
EOF

# Constants/AppConstants.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Constants/AppConstants.cs"
namespace MyBlog.Core.Constants;

/// <summary>
/// Application-wide constants.
/// </summary>
public static class AppConstants
{
    /// <summary>The name of the authentication cookie.</summary>
    public const string AuthCookieName = "MyBlog.Auth";

    /// <summary>The admin role claim value.</summary>
    public const string AdminRole = "Admin";

    /// <summary>Default page size for listings.</summary>
    public const int DefaultPageSize = 10;

    /// <summary>Maximum image size in bytes (5MB).</summary>
    public const int MaxImageSizeBytes = 5 * 1024 * 1024;

    /// <summary>Allowed image content types.</summary>
    public static readonly string[] AllowedImageTypes =
        ["image/jpeg", "image/png", "image/gif", "image/webp"];
}
EOF

# Interfaces/IPostRepository.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Interfaces/IPostRepository.cs"
using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for post operations.
/// </summary>
public interface IPostRepository
{
    /// <summary>Gets a paginated list of published posts.</summary>
    Task<(IReadOnlyList<PostListItemDto> Posts, int TotalCount)> GetPublishedPostsAsync(
        int page, int pageSize, CancellationToken cancellationToken = default);

    /// <summary>Gets all posts for admin view.</summary>
    Task<IReadOnlyList<PostListItemDto>> GetAllPostsAsync(
        CancellationToken cancellationToken = default);

    /// <summary>Gets a post by its slug.</summary>
    Task<PostDetailDto?> GetBySlugAsync(string slug, CancellationToken cancellationToken = default);

    /// <summary>Gets a post by its ID.</summary>
    Task<Post?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Creates a new post.</summary>
    Task<Post> CreateAsync(Post post, CancellationToken cancellationToken = default);

    /// <summary>Updates an existing post.</summary>
    Task UpdateAsync(Post post, CancellationToken cancellationToken = default);

    /// <summary>Deletes a post by ID.</summary>
    Task DeleteAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Gets the total count of posts.</summary>
    Task<int> GetCountAsync(CancellationToken cancellationToken = default);

    /// <summary>Gets recent posts for dashboard.</summary>
    Task<IReadOnlyList<PostListItemDto>> GetRecentPostsAsync(
        int count, CancellationToken cancellationToken = default);
}
EOF

# Interfaces/IUserRepository.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Interfaces/IUserRepository.cs"
using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for user operations.
/// </summary>
public interface IUserRepository
{
    /// <summary>Gets a user by username.</summary>
    Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default);

    /// <summary>Gets a user by ID.</summary>
    Task<User?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Creates a new user.</summary>
    Task<User> CreateAsync(User user, CancellationToken cancellationToken = default);

    /// <summary>Checks if any users exist.</summary>
    Task<bool> AnyUsersExistAsync(CancellationToken cancellationToken = default);
}
EOF

# Interfaces/IImageRepository.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Interfaces/IImageRepository.cs"
using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for image operations.
/// </summary>
public interface IImageRepository
{
    /// <summary>Gets all images.</summary>
    Task<IReadOnlyList<Image>> GetAllAsync(CancellationToken cancellationToken = default);

    /// <summary>Gets an image by ID.</summary>
    Task<Image?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Creates a new image.</summary>
    Task<Image> CreateAsync(Image image, CancellationToken cancellationToken = default);

    /// <summary>Deletes an image by ID.</summary>
    Task DeleteAsync(Guid id, CancellationToken cancellationToken = default);
}
EOF

# Interfaces/ITelemetryLogRepository.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Interfaces/ITelemetryLogRepository.cs"
using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for telemetry log operations.
/// </summary>
public interface ITelemetryLogRepository
{
    /// <summary>Writes a log entry to the database.</summary>
    Task WriteAsync(TelemetryLog log, CancellationToken cancellationToken = default);

    /// <summary>Deletes logs older than the specified date.</summary>
    Task<int> DeleteOlderThanAsync(DateTime cutoffUtc, CancellationToken cancellationToken = default);

    /// <summary>Gets recent logs for viewing.</summary>
    Task<IReadOnlyList<TelemetryLog>> GetRecentAsync(
        int count, CancellationToken cancellationToken = default);
}
EOF

# Interfaces/IPasswordService.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Interfaces/IPasswordService.cs"
namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for password hashing and verification.
/// </summary>
public interface IPasswordService
{
    /// <summary>Hashes a plain text password.</summary>
    string HashPassword(string password);

    /// <summary>Verifies a password against a hash.</summary>
    bool VerifyPassword(string hashedPassword, string providedPassword);
}
EOF

# Interfaces/ISlugService.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Interfaces/ISlugService.cs"
namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for generating URL-friendly slugs.
/// </summary>
public interface ISlugService
{
    /// <summary>Generates a slug from a title.</summary>
    string GenerateSlug(string title);
}
EOF

# Interfaces/IMarkdownService.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Interfaces/IMarkdownService.cs"
namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for rendering Markdown to HTML.
/// </summary>
public interface IMarkdownService
{
    /// <summary>Converts Markdown text to HTML.</summary>
    string ToHtml(string markdown);
}
EOF

# Interfaces/IAuthService.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Interfaces/IAuthService.cs"
using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for authentication operations.
/// </summary>
public interface IAuthService
{
    /// <summary>Attempts to authenticate a user.</summary>
    Task<User?> AuthenticateAsync(
        string username, string password, CancellationToken cancellationToken = default);

    /// <summary>Ensures the default admin user exists.</summary>
    Task EnsureAdminUserAsync(CancellationToken cancellationToken = default);
}
EOF

# Services/SlugService.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Services/SlugService.cs"
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using MyBlog.Core.Interfaces;

namespace MyBlog.Core.Services;

/// <summary>
/// Generates URL-friendly slugs from text.
/// </summary>
public sealed partial class SlugService : ISlugService
{
    /// <inheritdoc />
    public string GenerateSlug(string title)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(title);

        // Normalize unicode and convert to lowercase
        var normalized = title.Normalize(NormalizationForm.FormD);
        var sb = new StringBuilder();

        foreach (var c in normalized)
        {
            var category = CharUnicodeInfo.GetUnicodeCategory(c);
            if (category != UnicodeCategory.NonSpacingMark)
            {
                sb.Append(c);
            }
        }

        var result = sb.ToString().Normalize(NormalizationForm.FormC).ToLowerInvariant();

        // Replace spaces and underscores with hyphens
        result = SpacePattern().Replace(result, "-");

        // Remove all non-alphanumeric characters except hyphens
        result = NonAlphanumericPattern().Replace(result, "");

        // Replace multiple hyphens with single hyphen
        result = MultipleHyphenPattern().Replace(result, "-");

        // Trim hyphens from ends
        result = result.Trim('-');

        return result;
    }

    [GeneratedRegex(@"[\s_]+")]
    private static partial Regex SpacePattern();

    [GeneratedRegex(@"[^a-z0-9\-]")]
    private static partial Regex NonAlphanumericPattern();

    [GeneratedRegex(@"-+")]
    private static partial Regex MultipleHyphenPattern();
}
EOF

# Services/MarkdownService.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Services/MarkdownService.cs"
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using MyBlog.Core.Interfaces;

namespace MyBlog.Core.Services;

/// <summary>
/// Custom Markdown to HTML renderer.
/// Supports: headings, bold, italic, links, images, code blocks, blockquotes, lists, horizontal rules.
/// </summary>
public sealed partial class MarkdownService : IMarkdownService
{
    /// <inheritdoc />
    public string ToHtml(string markdown)
    {
        if (string.IsNullOrWhiteSpace(markdown))
        {
            return string.Empty;
        }

        var lines = markdown.Replace("\r\n", "\n").Split('\n');
        var result = new StringBuilder();
        var inCodeBlock = false;
        var inList = false;
        var codeBlockContent = new StringBuilder();

        foreach (var rawLine in lines)
        {
            var line = rawLine;

            // Handle fenced code blocks
            if (line.StartsWith("```"))
            {
                if (inCodeBlock)
                {
                    result.Append("<pre><code>");
                    result.Append(HttpUtility.HtmlEncode(codeBlockContent.ToString().TrimEnd()));
                    result.AppendLine("</code></pre>");
                    codeBlockContent.Clear();
                    inCodeBlock = false;
                }
                else
                {
                    if (inList)
                    {
                        result.AppendLine("</ul>");
                        inList = false;
                    }
                    inCodeBlock = true;
                }
                continue;
            }

            if (inCodeBlock)
            {
                codeBlockContent.AppendLine(line);
                continue;
            }

            // Handle horizontal rules
            if (HorizontalRulePattern().IsMatch(line))
            {
                if (inList)
                {
                    result.AppendLine("</ul>");
                    inList = false;
                }
                result.AppendLine("<hr />");
                continue;
            }

            // Handle headings
            var headingMatch = HeadingPattern().Match(line);
            if (headingMatch.Success)
            {
                if (inList)
                {
                    result.AppendLine("</ul>");
                    inList = false;
                }
                var level = headingMatch.Groups[1].Value.Length;
                var text = ProcessInline(headingMatch.Groups[2].Value.Trim());
                result.AppendLine($"<h{level}>{text}</h{level}>");
                continue;
            }

            // Handle blockquotes
            if (line.StartsWith('>'))
            {
                if (inList)
                {
                    result.AppendLine("</ul>");
                    inList = false;
                }
                var quoteText = ProcessInline(line[1..].TrimStart());
                result.AppendLine($"<blockquote><p>{quoteText}</p></blockquote>");
                continue;
            }

            // Handle unordered lists
            var listMatch = UnorderedListPattern().Match(line);
            if (listMatch.Success)
            {
                if (!inList)
                {
                    result.AppendLine("<ul>");
                    inList = true;
                }
                var itemText = ProcessInline(listMatch.Groups[1].Value);
                result.AppendLine($"<li>{itemText}</li>");
                continue;
            }

            // Close list if no longer in list item
            if (inList && !string.IsNullOrWhiteSpace(line))
            {
                result.AppendLine("</ul>");
                inList = false;
            }

            // Handle empty lines
            if (string.IsNullOrWhiteSpace(line))
            {
                if (inList)
                {
                    result.AppendLine("</ul>");
                    inList = false;
                }
                continue;
            }

            // Regular paragraph
            var paragraphText = ProcessInline(line);
            result.AppendLine($"<p>{paragraphText}</p>");
        }

        // Close any open list
        if (inList)
        {
            result.AppendLine("</ul>");
        }

        // Close any unclosed code block
        if (inCodeBlock)
        {
            result.Append("<pre><code>");
            result.Append(HttpUtility.HtmlEncode(codeBlockContent.ToString().TrimEnd()));
            result.AppendLine("</code></pre>");
        }

        return result.ToString();
    }

    private static string ProcessInline(string text)
    {
        // Escape HTML first
        text = HttpUtility.HtmlEncode(text);

        // Process inline code (must be before bold/italic to avoid conflicts)
        text = InlineCodePattern().Replace(text, "<code>$1</code>");

        // Process images ![alt](url)
        text = ImagePattern().Replace(text, "<img src=\"$2\" alt=\"$1\" />");

        // Process links [text](url)
        text = LinkPattern().Replace(text, "<a href=\"$2\">$1</a>");

        // Process bold **text** or __text__
        text = BoldPattern().Replace(text, "<strong>$1</strong>");

        // Process italic *text* or _text_
        text = ItalicPattern().Replace(text, "<em>$1</em>");

        return text;
    }

    [GeneratedRegex(@"^(#{1,6})\s+(.+)$")]
    private static partial Regex HeadingPattern();

    [GeneratedRegex(@"^[-*]\s+(.+)$")]
    private static partial Regex UnorderedListPattern();

    [GeneratedRegex(@"^[-*_]{3,}\s*$")]
    private static partial Regex HorizontalRulePattern();

    [GeneratedRegex(@"`([^`]+)`")]
    private static partial Regex InlineCodePattern();

    [GeneratedRegex(@"!\[([^\]]*)\]\(([^)]+)\)")]
    private static partial Regex ImagePattern();

    [GeneratedRegex(@"\[([^\]]+)\]\(([^)]+)\)")]
    private static partial Regex LinkPattern();

    [GeneratedRegex(@"\*\*([^*]+)\*\*|__([^_]+)__")]
    private static partial Regex BoldPattern();

    [GeneratedRegex(@"(?<!\*)\*(?!\*)([^*]+)(?<!\*)\*(?!\*)|(?<!_)_(?!_)([^_]+)(?<!_)_(?!_)")]
    private static partial Regex ItalicPattern();
}
EOF

echo "      Created MyBlog.Core project with models, interfaces, and services."

# =============================================================================
# Step 4: Create MyBlog.Infrastructure Project
# =============================================================================
echo ""
echo "[4/8] Creating MyBlog.Infrastructure project (data access and services)..."
echo "      WHY: Infrastructure contains implementation details like database access,"
echo "           keeping the Core project free of external dependencies."

# MyBlog.Infrastructure.csproj
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/MyBlog.Infrastructure.csproj"
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>MyBlog.Infrastructure</RootNamespace>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" />
    <PackageReference Include="Microsoft.AspNetCore.Identity" />
    <PackageReference Include="OpenTelemetry" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\MyBlog.Core\MyBlog.Core.csproj" />
  </ItemGroup>
</Project>
EOF

# Data/BlogDbContext.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Data/BlogDbContext.cs"
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Data;

/// <summary>
/// Entity Framework Core database context for the blog.
/// </summary>
public sealed class BlogDbContext : DbContext
{
    /// <summary>Initializes a new instance of the BlogDbContext.</summary>
    public BlogDbContext(DbContextOptions<BlogDbContext> options) : base(options)
    {
    }

    /// <summary>Gets or sets the Users table.</summary>
    public DbSet<User> Users => Set<User>();

    /// <summary>Gets or sets the Posts table.</summary>
    public DbSet<Post> Posts => Set<Post>();

    /// <summary>Gets or sets the Images table.</summary>
    public DbSet<Image> Images => Set<Image>();

    /// <summary>Gets or sets the TelemetryLogs table.</summary>
    public DbSet<TelemetryLog> TelemetryLogs => Set<TelemetryLog>();

    /// <inheritdoc />
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // User configuration
        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Username).HasMaxLength(50).IsRequired();
            entity.HasIndex(e => e.Username).IsUnique();
            entity.Property(e => e.PasswordHash).HasMaxLength(256).IsRequired();
            entity.Property(e => e.Email).HasMaxLength(256).IsRequired();
            entity.Property(e => e.DisplayName).HasMaxLength(100).IsRequired();
        });

        // Post configuration
        modelBuilder.Entity<Post>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Title).HasMaxLength(200).IsRequired();
            entity.Property(e => e.Slug).HasMaxLength(200).IsRequired();
            entity.HasIndex(e => e.Slug).IsUnique();
            entity.Property(e => e.Summary).HasMaxLength(500).IsRequired();
            entity.HasOne(e => e.Author)
                .WithMany(u => u.Posts)
                .HasForeignKey(e => e.AuthorId)
                .OnDelete(DeleteBehavior.Restrict);
        });

        // Image configuration
        modelBuilder.Entity<Image>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.FileName).HasMaxLength(256).IsRequired();
            entity.Property(e => e.ContentType).HasMaxLength(100).IsRequired();
            entity.HasOne(e => e.Post)
                .WithMany(p => p.Images)
                .HasForeignKey(e => e.PostId)
                .OnDelete(DeleteBehavior.SetNull);
            entity.HasOne(e => e.UploadedBy)
                .WithMany(u => u.UploadedImages)
                .HasForeignKey(e => e.UploadedByUserId)
                .OnDelete(DeleteBehavior.Restrict);
        });

        // TelemetryLog configuration
        modelBuilder.Entity<TelemetryLog>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Id).ValueGeneratedOnAdd();
            entity.Property(e => e.Level).HasMaxLength(20).IsRequired();
            entity.Property(e => e.Category).HasMaxLength(256).IsRequired();
            entity.HasIndex(e => e.TimestampUtc);
        });
    }
}
EOF

# Data/DatabasePathResolver.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Data/DatabasePathResolver.cs"
namespace MyBlog.Infrastructure.Data;

/// <summary>
/// Resolves the database file path following XDG conventions.
/// </summary>
public static class DatabasePathResolver
{
    /// <summary>
    /// Gets the path for the SQLite database file.
    /// Priority: XDG_DATA_HOME > Platform-specific > Local fallback
    /// </summary>
    public static string GetDatabasePath()
    {
        var dataDir = GetDataDirectory();
        Directory.CreateDirectory(dataDir);
        return Path.Combine(dataDir, "myblog.db");
    }

    /// <summary>
    /// Gets the data directory following platform conventions.
    /// </summary>
    public static string GetDataDirectory()
    {
        string baseDir;

        if (OperatingSystem.IsWindows())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        }
        else if (OperatingSystem.IsMacOS())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        }
        else
        {
            // Linux/Unix: Use XDG_DATA_HOME or fallback
            var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
            baseDir = !string.IsNullOrEmpty(xdgDataHome)
                ? xdgDataHome
                : Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".local", "share");
        }

        // If we can't write to the preferred location, use local directory
        var preferredDir = Path.Combine(baseDir, "MyBlog");
        try
        {
            Directory.CreateDirectory(preferredDir);
            var testFile = Path.Combine(preferredDir, ".write-test");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return preferredDir;
        }
        catch
        {
            // Fallback to local directory
            return Path.Combine(AppContext.BaseDirectory, "data");
        }
    }
}
EOF

# Repositories/PostRepository.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Repositories/PostRepository.cs"
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the post repository.
/// </summary>
public sealed class PostRepository : IPostRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of PostRepository.</summary>
    public PostRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task<(IReadOnlyList<PostListItemDto> Posts, int TotalCount)> GetPublishedPostsAsync(
        int page, int pageSize, CancellationToken cancellationToken = default)
    {
        var query = _context.Posts
            .AsNoTracking()
            .Where(p => p.IsPublished)
            .OrderByDescending(p => p.PublishedAtUtc);

        var totalCount = await query.CountAsync(cancellationToken);

        var posts = await query
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .Include(p => p.Author)
            .Select(p => new PostListItemDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Summary,
                p.Author!.DisplayName,
                p.PublishedAtUtc,
                p.IsPublished))
            .ToListAsync(cancellationToken);

        return (posts, totalCount);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<PostListItemDto>> GetAllPostsAsync(
        CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .AsNoTracking()
            .OrderByDescending(p => p.UpdatedAtUtc)
            .Include(p => p.Author)
            .Select(p => new PostListItemDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Summary,
                p.Author!.DisplayName,
                p.PublishedAtUtc,
                p.IsPublished))
            .ToListAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<PostDetailDto?> GetBySlugAsync(
        string slug, CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .AsNoTracking()
            .Where(p => p.Slug == slug)
            .Include(p => p.Author)
            .Select(p => new PostDetailDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Content,
                p.Summary,
                p.Author!.DisplayName,
                p.CreatedAtUtc,
                p.UpdatedAtUtc,
                p.PublishedAtUtc,
                p.IsPublished))
            .FirstOrDefaultAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Post?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .Include(p => p.Author)
            .FirstOrDefaultAsync(p => p.Id == id, cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Post> CreateAsync(Post post, CancellationToken cancellationToken = default)
    {
        _context.Posts.Add(post);
        await _context.SaveChangesAsync(cancellationToken);
        return post;
    }

    /// <inheritdoc />
    public async Task UpdateAsync(Post post, CancellationToken cancellationToken = default)
    {
        _context.Posts.Update(post);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task DeleteAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var post = await _context.Posts.FindAsync([id], cancellationToken);
        if (post is not null)
        {
            _context.Posts.Remove(post);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }

    /// <inheritdoc />
    public async Task<int> GetCountAsync(CancellationToken cancellationToken = default)
    {
        return await _context.Posts.CountAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<PostListItemDto>> GetRecentPostsAsync(
        int count, CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .AsNoTracking()
            .OrderByDescending(p => p.UpdatedAtUtc)
            .Take(count)
            .Include(p => p.Author)
            .Select(p => new PostListItemDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Summary,
                p.Author!.DisplayName,
                p.PublishedAtUtc,
                p.IsPublished))
            .ToListAsync(cancellationToken);
    }
}
EOF

# Repositories/UserRepository.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Repositories/UserRepository.cs"
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the user repository.
/// </summary>
public sealed class UserRepository : IUserRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of UserRepository.</summary>
    public UserRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task<User?> GetByUsernameAsync(
        string username, CancellationToken cancellationToken = default)
    {
        return await _context.Users
            .FirstOrDefaultAsync(u => u.Username == username, cancellationToken);
    }

    /// <inheritdoc />
    public async Task<User?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.Users.FindAsync([id], cancellationToken);
    }

    /// <inheritdoc />
    public async Task<User> CreateAsync(User user, CancellationToken cancellationToken = default)
    {
        _context.Users.Add(user);
        await _context.SaveChangesAsync(cancellationToken);
        return user;
    }

    /// <inheritdoc />
    public async Task<bool> AnyUsersExistAsync(CancellationToken cancellationToken = default)
    {
        return await _context.Users.AnyAsync(cancellationToken);
    }
}
EOF

# Repositories/ImageRepository.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Repositories/ImageRepository.cs"
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the image repository.
/// </summary>
public sealed class ImageRepository : IImageRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of ImageRepository.</summary>
    public ImageRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<Image>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _context.Images
            .AsNoTracking()
            .OrderByDescending(i => i.UploadedAtUtc)
            .ToListAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Image?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.Images.FindAsync([id], cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Image> CreateAsync(Image image, CancellationToken cancellationToken = default)
    {
        _context.Images.Add(image);
        await _context.SaveChangesAsync(cancellationToken);
        return image;
    }

    /// <inheritdoc />
    public async Task DeleteAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var image = await _context.Images.FindAsync([id], cancellationToken);
        if (image is not null)
        {
            _context.Images.Remove(image);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }
}
EOF

# Repositories/TelemetryLogRepository.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Repositories/TelemetryLogRepository.cs"
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the telemetry log repository.
/// </summary>
public sealed class TelemetryLogRepository : ITelemetryLogRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of TelemetryLogRepository.</summary>
    public TelemetryLogRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task WriteAsync(TelemetryLog log, CancellationToken cancellationToken = default)
    {
        _context.TelemetryLogs.Add(log);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<int> DeleteOlderThanAsync(
        DateTime cutoffUtc, CancellationToken cancellationToken = default)
    {
        return await _context.TelemetryLogs
            .Where(l => l.TimestampUtc < cutoffUtc)
            .ExecuteDeleteAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<TelemetryLog>> GetRecentAsync(
        int count, CancellationToken cancellationToken = default)
    {
        return await _context.TelemetryLogs
            .AsNoTracking()
            .OrderByDescending(l => l.TimestampUtc)
            .Take(count)
            .ToListAsync(cancellationToken);
    }
}
EOF

# Services/PasswordService.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Services/PasswordService.cs"
using Microsoft.AspNetCore.Identity;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Password hashing service using ASP.NET Core Identity's PasswordHasher.
/// </summary>
public sealed class PasswordService : IPasswordService
{
    private readonly PasswordHasher<User> _hasher = new();

    /// <inheritdoc />
    public string HashPassword(string password)
    {
        return _hasher.HashPassword(null!, password);
    }

    /// <inheritdoc />
    public bool VerifyPassword(string hashedPassword, string providedPassword)
    {
        var result = _hasher.VerifyHashedPassword(null!, hashedPassword, providedPassword);
        return result == PasswordVerificationResult.Success ||
               result == PasswordVerificationResult.SuccessRehashNeeded;
    }
}
EOF

# Services/AuthService.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Services/AuthService.cs"
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Authentication service implementation.
/// </summary>
public sealed class AuthService : IAuthService
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordService _passwordService;
    private readonly IConfiguration _configuration;

    /// <summary>Initializes a new instance of AuthService.</summary>
    public AuthService(
        IUserRepository userRepository,
        IPasswordService passwordService,
        IConfiguration configuration)
    {
        _userRepository = userRepository;
        _passwordService = passwordService;
        _configuration = configuration;
    }

    /// <inheritdoc />
    public async Task<User?> AuthenticateAsync(
        string username, string password, CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByUsernameAsync(username, cancellationToken);
        if (user is null)
        {
            return null;
        }

        return _passwordService.VerifyPassword(user.PasswordHash, password) ? user : null;
    }

    /// <inheritdoc />
    public async Task EnsureAdminUserAsync(CancellationToken cancellationToken = default)
    {
        if (await _userRepository.AnyUsersExistAsync(cancellationToken))
        {
            return;
        }

        var defaultPassword = Environment.GetEnvironmentVariable("MYBLOG_ADMIN_PASSWORD")
            ?? _configuration["Authentication:DefaultAdminPassword"]
            ?? "ChangeMe123!";

        var admin = new User
        {
            Id = Guid.NewGuid(),
            Username = "admin",
            PasswordHash = _passwordService.HashPassword(defaultPassword),
            Email = "admin@localhost",
            DisplayName = "Administrator",
            CreatedAtUtc = DateTime.UtcNow
        };

        await _userRepository.CreateAsync(admin, cancellationToken);
    }
}
EOF

# Services/TelemetryCleanupService.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Services/TelemetryCleanupService.cs"
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using MyBlog.Core.Interfaces;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Background service that cleans up old telemetry logs.
/// </summary>
public sealed class TelemetryCleanupService : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<TelemetryCleanupService> _logger;
    private readonly int _retentionDays;

    /// <summary>Initializes a new instance of TelemetryCleanupService.</summary>
    public TelemetryCleanupService(
        IServiceScopeFactory scopeFactory,
        IConfiguration configuration,
        ILogger<TelemetryCleanupService> logger)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
        _retentionDays = configuration.GetValue("Telemetry:RetentionDays", 30);
    }

    /// <inheritdoc />
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Run cleanup immediately on startup
        await CleanupAsync(stoppingToken);

        // Then run daily
        using var timer = new PeriodicTimer(TimeSpan.FromDays(1));
        while (await timer.WaitForNextTickAsync(stoppingToken))
        {
            await CleanupAsync(stoppingToken);
        }
    }

    private async Task CleanupAsync(CancellationToken cancellationToken)
    {
        try
        {
            using var scope = _scopeFactory.CreateScope();
            var repository = scope.ServiceProvider.GetRequiredService<ITelemetryLogRepository>();

            var cutoff = DateTime.UtcNow.AddDays(-_retentionDays);
            var deleted = await repository.DeleteOlderThanAsync(cutoff, cancellationToken);

            if (deleted > 0)
            {
                _logger.LogInformation(
                    "Telemetry cleanup: deleted {Count} logs older than {Days} days",
                    deleted, _retentionDays);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during telemetry cleanup");
        }
    }
}
EOF

# Telemetry/TelemetryPathResolver.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Telemetry/TelemetryPathResolver.cs"
namespace MyBlog.Infrastructure.Telemetry;

/// <summary>
/// Resolves the telemetry directory path following XDG conventions.
/// </summary>
public static class TelemetryPathResolver
{
    /// <summary>
    /// Attempts to get a writable telemetry directory.
    /// Returns null if no writable directory can be found.
    /// </summary>
    public static string? GetTelemetryDirectory()
    {
        // Try XDG/platform-specific location first
        var preferredDir = GetPreferredDirectory();
        if (TryCreateAndVerify(preferredDir))
        {
            return preferredDir;
        }

        // Fallback to local directory
        var localDir = Path.Combine(AppContext.BaseDirectory, "telemetry");
        if (TryCreateAndVerify(localDir))
        {
            return localDir;
        }

        // No writable directory available
        return null;
    }

    private static string GetPreferredDirectory()
    {
        string baseDir;

        if (OperatingSystem.IsWindows())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        }
        else if (OperatingSystem.IsMacOS())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        }
        else
        {
            var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
            baseDir = !string.IsNullOrEmpty(xdgDataHome)
                ? xdgDataHome
                : Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".local", "share");
        }

        return Path.Combine(baseDir, "MyBlog", "telemetry");
    }

    private static bool TryCreateAndVerify(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid()}");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return true;
        }
        catch
        {
            return false;
        }
    }
}
EOF

# Telemetry/DatabaseLogExporter.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Telemetry/DatabaseLogExporter.cs"
using System.Text.Json;
using Microsoft.Extensions.DependencyInjection;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyBlog.Infrastructure.Telemetry;

/// <summary>
/// OpenTelemetry log exporter that writes to SQLite database.
/// </summary>
public sealed class DatabaseLogExporter : BaseExporter<LogRecord>
{
    private readonly IServiceScopeFactory _scopeFactory;

    /// <summary>Initializes a new instance of DatabaseLogExporter.</summary>
    public DatabaseLogExporter(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }

    /// <inheritdoc />
    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        try
        {
            using var scope = _scopeFactory.CreateScope();
            var context = scope.ServiceProvider.GetRequiredService<BlogDbContext>();

            foreach (var record in batch)
            {
                var log = new TelemetryLog
                {
                    TimestampUtc = record.Timestamp.UtcDateTime,
                    Level = record.LogLevel.ToString(),
                    Category = record.CategoryName ?? "Unknown",
                    Message = record.FormattedMessage ?? record.Body ?? "",
                    Exception = record.Exception?.ToString(),
                    TraceId = record.TraceId.ToString(),
                    SpanId = record.SpanId.ToString(),
                    Properties = SerializeAttributes(record)
                };

                context.TelemetryLogs.Add(log);
            }

            context.SaveChanges();
            return ExportResult.Success;
        }
        catch
        {
            return ExportResult.Failure;
        }
    }

    private static string? SerializeAttributes(LogRecord record)
    {
        if (record.Attributes is null)
        {
            return null;
        }

        var dict = new Dictionary<string, object?>();
        foreach (var attr in record.Attributes)
        {
            dict[attr.Key] = attr.Value;
        }

        return dict.Count > 0 ? JsonSerializer.Serialize(dict) : null;
    }
}
EOF

# Telemetry/FileLogExporter.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Telemetry/FileLogExporter.cs"
using System.Text;
using System.Text.Json;
using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyBlog.Infrastructure.Telemetry;

/// <summary>
/// OpenTelemetry log exporter that writes to JSON files.
/// </summary>
public sealed class FileLogExporter : BaseExporter<LogRecord>
{
    private readonly string _directory;
    private readonly string _runId;
    private readonly long _maxFileSizeBytes;
    private readonly object _lock = new();
    private StreamWriter? _writer;
    private long _currentFileSize;
    private int _fileNumber;
    private bool _isFirstRecord = true;
    private readonly JsonSerializerOptions _jsonOptions = new() { WriteIndented = true };

    /// <summary>Initializes a new instance of FileLogExporter.</summary>
    public FileLogExporter(string directory, long maxFileSizeBytes = 25 * 1024 * 1024)
    {
        _directory = directory;
        _maxFileSizeBytes = maxFileSizeBytes;
        _runId = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
        Directory.CreateDirectory(_directory);
    }

    /// <inheritdoc />
    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        try
        {
            lock (_lock)
            {
                EnsureWriter();

                foreach (var record in batch)
                {
                    var obj = new
                    {
                        Timestamp = record.Timestamp.ToString("O"),
                        Level = record.LogLevel.ToString(),
                        Category = record.CategoryName,
                        Message = record.FormattedMessage ?? record.Body,
                        TraceId = record.TraceId.ToString(),
                        SpanId = record.SpanId.ToString(),
                        Exception = record.Exception?.ToString()
                    };

                    var json = JsonSerializer.Serialize(obj, _jsonOptions);
                    var bytes = Encoding.UTF8.GetByteCount(json) + 2;

                    if (_currentFileSize + bytes > _maxFileSizeBytes)
                    {
                        RotateFile();
                    }

                    if (!_isFirstRecord)
                    {
                        _writer!.WriteLine(",");
                    }
                    else
                    {
                        _isFirstRecord = false;
                    }

                    _writer!.Write(json);
                    _currentFileSize += bytes;
                }

                _writer!.Flush();
            }

            return ExportResult.Success;
        }
        catch
        {
            return ExportResult.Failure;
        }
    }

    private void EnsureWriter()
    {
        if (_writer is null)
        {
            OpenNewFile();
        }
    }

    private void OpenNewFile()
    {
        var fileName = _fileNumber == 0
            ? $"logs_{_runId}.json"
            : $"logs_{_runId}_{_fileNumber:D3}.json";

        _writer = new StreamWriter(Path.Combine(_directory, fileName), false, Encoding.UTF8);
        _writer.WriteLine("[");
        _currentFileSize = 2;
        _isFirstRecord = true;
    }

    private void RotateFile()
    {
        CloseWriter();
        _fileNumber++;
        OpenNewFile();
    }

    private void CloseWriter()
    {
        if (_writer is not null)
        {
            _writer.WriteLine();
            _writer.WriteLine("]");
            _writer.Flush();
            _writer.Dispose();
            _writer = null;
        }
    }

    /// <inheritdoc />
    protected override bool OnShutdown(int timeoutMilliseconds)
    {
        lock (_lock)
        {
            CloseWriter();
        }
        return true;
    }
}
EOF

# ServiceCollectionExtensions.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/ServiceCollectionExtensions.cs"
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Services;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;

namespace MyBlog.Infrastructure;

/// <summary>
/// Extension methods for registering infrastructure services.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Adds infrastructure services to the DI container.
    /// </summary>
    public static IServiceCollection AddInfrastructure(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Database
        var connectionString = configuration.GetConnectionString("DefaultConnection");
        if (string.IsNullOrEmpty(connectionString) || connectionString == "Data Source=myblog.db")
        {
            // Use XDG-compliant path
            var dbPath = DatabasePathResolver.GetDatabasePath();
            connectionString = $"Data Source={dbPath}";
        }

        services.AddDbContext<BlogDbContext>(options =>
            options.UseSqlite(connectionString));

        // Repositories
        services.AddScoped<IPostRepository, PostRepository>();
        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IImageRepository, ImageRepository>();
        services.AddScoped<ITelemetryLogRepository, TelemetryLogRepository>();

        // Services
        services.AddSingleton<IPasswordService, PasswordService>();
        services.AddSingleton<ISlugService, SlugService>();
        services.AddSingleton<IMarkdownService, MarkdownService>();
        services.AddScoped<IAuthService, AuthService>();

        // Background services
        services.AddHostedService<TelemetryCleanupService>();

        return services;
    }
}
EOF

echo "      Created MyBlog.Infrastructure project with repositories and services."

# =============================================================================
# Step 5: Create MyBlog.Web Project
# =============================================================================
echo ""
echo "[5/8] Creating MyBlog.Web project (Blazor Server application)..."
echo "      WHY: The Web project is the entry point that hosts the Blazor Server"
echo "           application and handles HTTP requests."

# MyBlog.Web.csproj
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/MyBlog.Web.csproj"
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <RootNamespace>MyBlog.Web</RootNamespace>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\MyBlog.Infrastructure\MyBlog.Infrastructure.csproj" />
  </ItemGroup>
</Project>
EOF

# Program.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Program.cs"
using Microsoft.AspNetCore.Authentication.Cookies;
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Constants;
using MyBlog.Core.Interfaces;
using MyBlog.Infrastructure;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Telemetry;
using MyBlog.Web.Components;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

builder.Services.AddInfrastructure(builder.Configuration);

// Configure authentication
var sessionTimeout = builder.Configuration.GetValue("Authentication:SessionTimeoutMinutes", 30);
builder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie(options =>
    {
        options.Cookie.Name = AppConstants.AuthCookieName;
        options.LoginPath = "/login";
        options.LogoutPath = "/logout";
        options.ExpireTimeSpan = TimeSpan.FromMinutes(sessionTimeout);
        options.SlidingExpiration = true;
        options.Cookie.HttpOnly = true;
        options.Cookie.SecurePolicy = builder.Configuration.GetValue("Application:RequireHttps", false)
            ? CookieSecurePolicy.Always
            : CookieSecurePolicy.SameAsRequest;
    });

builder.Services.AddAuthorization();
builder.Services.AddCascadingAuthenticationState();

// Configure OpenTelemetry
var telemetryDir = TelemetryPathResolver.GetTelemetryDirectory();
var enableFileLogging = builder.Configuration.GetValue("Telemetry:EnableFileLogging", true);
var enableDbLogging = builder.Configuration.GetValue("Telemetry:EnableDatabaseLogging", true);

builder.Services.AddOpenTelemetry()
    .ConfigureResource(r => r.AddService("MyBlog"))
    .WithTracing(tracing =>
    {
        tracing.AddAspNetCoreInstrumentation();
    })
    .WithMetrics(metrics =>
    {
        metrics.AddAspNetCoreInstrumentation();
    });

builder.Logging.AddOpenTelemetry(options =>
{
    options.IncludeScopes = true;
    options.IncludeFormattedMessage = true;

    if (enableDbLogging)
    {
        options.AddProcessor(new BatchLogRecordExportProcessor(
            new DatabaseLogExporter(builder.Services.BuildServiceProvider()
                .GetRequiredService<IServiceScopeFactory>())));
    }

    if (enableFileLogging && telemetryDir is not null)
    {
        options.AddProcessor(new BatchLogRecordExportProcessor(
            new FileLogExporter(telemetryDir)));
    }
});

var app = builder.Build();

// Initialize database
using (var scope = app.Services.CreateScope())
{
    var context = scope.ServiceProvider.GetRequiredService<BlogDbContext>();
    await context.Database.EnsureCreatedAsync();

    var authService = scope.ServiceProvider.GetRequiredService<IAuthService>();
    await authService.EnsureAdminUserAsync();
}

// Configure pipeline
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    if (builder.Configuration.GetValue("Application:RequireHttps", false))
    {
        app.UseHsts();
        app.UseHttpsRedirection();
    }
}

app.UseStaticFiles();
app.UseAuthentication();
app.UseAuthorization();
app.UseAntiforgery();

app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();

// Image endpoint
app.MapGet("/api/images/{id:guid}", async (Guid id, IImageRepository repo, CancellationToken ct) =>
{
    var image = await repo.GetByIdAsync(id, ct);
    return image is null
        ? Results.NotFound()
        : Results.File(image.Data, image.ContentType, image.FileName);
});

app.Run();
EOF

# appsettings.json
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/appsettings.json"
{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=myblog.db"
  },
  "Authentication": {
    "SessionTimeoutMinutes": 30,
    "DefaultAdminPassword": "ChangeMe123!"
  },
  "Telemetry": {
    "RetentionDays": 30,
    "EnableFileLogging": true,
    "EnableDatabaseLogging": true
  },
  "Application": {
    "Title": "MyBlog",
    "PostsPerPage": 10,
    "RequireHttps": false
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  }
}
EOF

# appsettings.Development.json
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/appsettings.Development.json"
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Information"
    }
  }
}
EOF

# Components/App.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/App.razor"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>@(Title ?? "MyBlog")</title>
    <base href="/" />
    <link rel="stylesheet" href="css/site.css" />
    <HeadOutlet />
</head>
<body>
    <Routes />
    <script src="_framework/blazor.web.js"></script>
</body>
</html>

@code {
    [CascadingParameter]
    private HttpContext? HttpContext { get; set; }

    private string? Title => HttpContext?.RequestServices
        .GetService<IConfiguration>()?["Application:Title"];
}
EOF

# Components/Routes.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Routes.razor"
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <AuthorizeRouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)">
            <NotAuthorized>
                <RedirectToLogin />
            </NotAuthorized>
        </AuthorizeRouteView>
        <FocusOnNavigate RouteData="routeData" Selector="h1" />
    </Found>
</Router>
EOF

# Components/_Imports.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/_Imports.razor"
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using MyBlog.Core.Constants
@using MyBlog.Core.Interfaces
@using MyBlog.Core.Models
@using MyBlog.Web.Components
@using MyBlog.Web.Components.Layout
@using MyBlog.Web.Components.Shared
EOF

# Components/Layout/MainLayout.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Layout/MainLayout.razor"
@inherits LayoutComponentBase
@inject IConfiguration Configuration
@inject NavigationManager Navigation

<div class="layout">
    <header class="header">
        <div class="container">
            <a href="/" class="logo">@(Configuration["Application:Title"] ?? "MyBlog")</a>
            <nav class="nav">
                <a href="/">Home</a>
                <a href="/about">About</a>
                <AuthorizeView>
                    <Authorized>
                        <a href="/admin">Admin</a>
                        <form method="post" action="/logout" class="logout-form">
                            <AntiforgeryToken />
                            <button type="submit">Logout</button>
                        </form>
                    </Authorized>
                    <NotAuthorized>
                        <a href="/login">Login</a>
                    </NotAuthorized>
                </AuthorizeView>
            </nav>
        </div>
    </header>

    <main class="main">
        <div class="container">
            @Body
        </div>
    </main>

    <footer class="footer">
        <div class="container">
            <p>&copy; @DateTime.Now.Year @(Configuration["Application:Title"] ?? "MyBlog")</p>
        </div>
    </footer>
</div>
EOF

# Components/Shared/RedirectToLogin.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Shared/RedirectToLogin.razor"
@inject NavigationManager Navigation

@code {
    protected override void OnInitialized()
    {
        Navigation.NavigateTo($"/login?returnUrl={Uri.EscapeDataString(Navigation.Uri)}", forceLoad: true);
    }
}
EOF

# Components/Shared/PostCard.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Shared/PostCard.razor"
<article class="post-card">
    <h2 class="post-card-title">
        <a href="/post/@Post.Slug">@Post.Title</a>
    </h2>
    <div class="post-card-meta">
        <span class="author">By @Post.AuthorDisplayName</span>
        @if (Post.PublishedAtUtc.HasValue)
        {
            <span class="date">@Post.PublishedAtUtc.Value.ToString("MMMM d, yyyy")</span>
        }
        @if (!Post.IsPublished)
        {
            <span class="draft-badge">Draft</span>
        }
    </div>
    <p class="post-card-summary">@Post.Summary</p>
    <a href="/post/@Post.Slug" class="read-more">Read more →</a>
</article>

@code {
    [Parameter, EditorRequired]
    public PostListItemDto Post { get; set; } = default!;
}
EOF

# Components/Shared/Pagination.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Shared/Pagination.razor"
@if (TotalPages > 1)
{
    <nav class="pagination" aria-label="Page navigation">
        @if (CurrentPage > 1)
        {
            <a href="@GetPageUrl(CurrentPage - 1)" class="page-link">← Previous</a>
        }
        
        <span class="page-info">Page @CurrentPage of @TotalPages</span>
        
        @if (CurrentPage < TotalPages)
        {
            <a href="@GetPageUrl(CurrentPage + 1)" class="page-link">Next →</a>
        }
    </nav>
}

@code {
    [Parameter, EditorRequired]
    public int CurrentPage { get; set; }

    [Parameter, EditorRequired]
    public int TotalPages { get; set; }

    [Parameter]
    public string BaseUrl { get; set; } = "/";

    private string GetPageUrl(int page) =>
        page == 1 ? BaseUrl : $"{BaseUrl}?page={page}";
}
EOF

# Components/Shared/MarkdownRenderer.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Shared/MarkdownRenderer.razor"
@inject IMarkdownService MarkdownService

<div class="markdown-content">
    @((MarkupString)MarkdownService.ToHtml(Content ?? ""))
</div>

@code {
    [Parameter]
    public string? Content { get; set; }
}
EOF

# Components/Pages/Home.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Pages/Home.razor"
@page "/"
@inject IPostRepository PostRepository
@inject IConfiguration Configuration

<PageTitle>@(Configuration["Application:Title"] ?? "MyBlog")</PageTitle>

<h1>Welcome to @(Configuration["Application:Title"] ?? "MyBlog")</h1>

@if (_posts is null)
{
    <p>Loading...</p>
}
else if (_posts.Count == 0)
{
    <p>No posts yet. Check back soon!</p>
}
else
{
    <div class="post-list">
        @foreach (var post in _posts)
        {
            <PostCard Post="post" />
        }
    </div>

    <Pagination CurrentPage="_currentPage" TotalPages="_totalPages" BaseUrl="/" />
}

@code {
    private IReadOnlyList<PostListItemDto>? _posts;
    private int _currentPage = 1;
    private int _totalPages = 1;

    [SupplyParameterFromQuery(Name = "page")]
    public int? Page { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        _currentPage = Page ?? 1;
        if (_currentPage < 1) _currentPage = 1;

        var pageSize = Configuration.GetValue("Application:PostsPerPage", 10);
        var (posts, totalCount) = await PostRepository.GetPublishedPostsAsync(_currentPage, pageSize);
        
        _posts = posts;
        _totalPages = (int)Math.Ceiling(totalCount / (double)pageSize);
    }
}
EOF

# Components/Pages/PostDetail.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Pages/PostDetail.razor"
@page "/post/{Slug}"
@inject IPostRepository PostRepository
@inject NavigationManager Navigation

@if (_post is null)
{
    @if (_notFound)
    {
        <PageTitle>Not Found</PageTitle>
        <h1>Post Not Found</h1>
        <p>The post you're looking for doesn't exist.</p>
        <a href="/">← Back to Home</a>
    }
    else
    {
        <p>Loading...</p>
    }
}
else
{
    <PageTitle>@_post.Title</PageTitle>
    
    <article class="post-detail">
        <header class="post-header">
            <h1>@_post.Title</h1>
            <div class="post-meta">
                <span class="author">By @_post.AuthorDisplayName</span>
                @if (_post.PublishedAtUtc.HasValue)
                {
                    <span class="date">Published @_post.PublishedAtUtc.Value.ToString("MMMM d, yyyy")</span>
                }
            </div>
        </header>

        <div class="post-content">
            <MarkdownRenderer Content="@_post.Content" />
        </div>
    </article>

    <a href="/" class="back-link">← Back to Home</a>
}

@code {
    [Parameter]
    public string Slug { get; set; } = "";

    private PostDetailDto? _post;
    private bool _notFound;

    protected override async Task OnParametersSetAsync()
    {
        _post = await PostRepository.GetBySlugAsync(Slug);
        _notFound = _post is null;
        
        // Don't show unpublished posts to public
        if (_post is not null && !_post.IsPublished)
        {
            _post = null;
            _notFound = true;
        }
    }
}
EOF

# Components/Pages/About.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Pages/About.razor"
@page "/about"
@inject IConfiguration Configuration

<PageTitle>About - @(Configuration["Application:Title"] ?? "MyBlog")</PageTitle>

<h1>About</h1>

<p>
    Welcome to @(Configuration["Application:Title"] ?? "MyBlog"), a simple blog built with 
    .NET 10 and Blazor Server.
</p>

<h2>Features</h2>
<ul>
    <li>Markdown-based content</li>
    <li>Image support with database storage</li>
    <li>OpenTelemetry for observability</li>
    <li>Cross-platform deployment</li>
</ul>
EOF

# Components/Pages/Login.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Pages/Login.razor"
@page "/login"
@inject IAuthService AuthService
@inject NavigationManager Navigation
@inject IHttpContextAccessor HttpContextAccessor
@using System.Security.Claims
@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Authentication.Cookies

<PageTitle>Login</PageTitle>

<div class="login-page">
    <h1>Login</h1>

    @if (!string.IsNullOrEmpty(_error))
    {
        <div class="error-message">@_error</div>
    }

    <form method="post" @onsubmit="HandleLogin" @formname="login">
        <AntiforgeryToken />
        
        <div class="form-group">
            <label for="username">Username</label>
            <input type="text" id="username" @bind="_username" required />
        </div>

        <div class="form-group">
            <label for="password">Password</label>
            <input type="password" id="password" @bind="_password" required />
        </div>

        <button type="submit" class="btn btn-primary">Login</button>
    </form>
</div>

@code {
    private string _username = "";
    private string _password = "";
    private string? _error;

    [SupplyParameterFromQuery]
    public string? ReturnUrl { get; set; }

    private async Task HandleLogin()
    {
        var user = await AuthService.AuthenticateAsync(_username, _password);
        if (user is null)
        {
            _error = "Invalid username or password";
            return;
        }

        var claims = new List<Claim>
        {
            new(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new(ClaimTypes.Name, user.Username),
            new(ClaimTypes.Role, AppConstants.AdminRole)
        };

        var identity = new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme);
        var principal = new ClaimsPrincipal(identity);

        var context = HttpContextAccessor.HttpContext;
        if (context is not null)
        {
            await context.SignInAsync(
                CookieAuthenticationDefaults.AuthenticationScheme,
                principal);
        }

        var returnUrl = ReturnUrl ?? "/admin";
        Navigation.NavigateTo(returnUrl, forceLoad: true);
    }
}
EOF

# Components/Pages/Logout.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Pages/Logout.razor"
@page "/logout"
@inject NavigationManager Navigation
@inject IHttpContextAccessor HttpContextAccessor
@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Authentication.Cookies
@attribute [Authorize]

@code {
    protected override async Task OnInitializedAsync()
    {
        var context = HttpContextAccessor.HttpContext;
        if (context is not null)
        {
            await context.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);
        }
        Navigation.NavigateTo("/", forceLoad: true);
    }
}
EOF

# Components/Pages/Admin/Dashboard.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Pages/Admin/Dashboard.razor"
@page "/admin"
@attribute [Authorize]
@inject IPostRepository PostRepository

<PageTitle>Admin Dashboard</PageTitle>

<h1>Admin Dashboard</h1>

<div class="dashboard-stats">
    <div class="stat-card">
        <h3>Total Posts</h3>
        <p class="stat-value">@_postCount</p>
    </div>
</div>

<div class="admin-nav">
    <a href="/admin/posts" class="btn">Manage Posts</a>
    <a href="/admin/posts/new" class="btn">New Post</a>
    <a href="/admin/images" class="btn">Manage Images</a>
</div>

<h2>Recent Posts</h2>
@if (_recentPosts is null)
{
    <p>Loading...</p>
}
else if (_recentPosts.Count == 0)
{
    <p>No posts yet.</p>
}
else
{
    <table class="admin-table">
        <thead>
            <tr>
                <th>Title</th>
                <th>Status</th>
                <th>Updated</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var post in _recentPosts)
            {
                <tr>
                    <td><a href="/admin/posts/edit/@post.Id">@post.Title</a></td>
                    <td>@(post.IsPublished ? "Published" : "Draft")</td>
                    <td>@(post.PublishedAtUtc?.ToString("MMM d, yyyy") ?? "—")</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private int _postCount;
    private IReadOnlyList<PostListItemDto>? _recentPosts;

    protected override async Task OnInitializedAsync()
    {
        _postCount = await PostRepository.GetCountAsync();
        _recentPosts = await PostRepository.GetRecentPostsAsync(5);
    }
}
EOF

# Components/Pages/Admin/PostList.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Pages/Admin/PostList.razor"
@page "/admin/posts"
@attribute [Authorize]
@inject IPostRepository PostRepository
@inject NavigationManager Navigation

<PageTitle>Manage Posts</PageTitle>

<h1>Manage Posts</h1>

<p><a href="/admin/posts/new" class="btn btn-primary">Create New Post</a></p>

@if (_posts is null)
{
    <p>Loading...</p>
}
else if (_posts.Count == 0)
{
    <p>No posts yet.</p>
}
else
{
    <table class="admin-table">
        <thead>
            <tr>
                <th>Title</th>
                <th>Author</th>
                <th>Status</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var post in _posts)
            {
                <tr>
                    <td>@post.Title</td>
                    <td>@post.AuthorDisplayName</td>
                    <td>@(post.IsPublished ? "Published" : "Draft")</td>
                    <td>
                        <a href="/admin/posts/edit/@post.Id">Edit</a>
                        <button @onclick="() => DeletePost(post.Id)" class="btn-link danger">Delete</button>
                    </td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private IReadOnlyList<PostListItemDto>? _posts;

    protected override async Task OnInitializedAsync()
    {
        await LoadPosts();
    }

    private async Task LoadPosts()
    {
        _posts = await PostRepository.GetAllPostsAsync();
    }

    private async Task DeletePost(Guid id)
    {
        await PostRepository.DeleteAsync(id);
        await LoadPosts();
    }
}
EOF

# Components/Pages/Admin/PostEditor.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Pages/Admin/PostEditor.razor"
@page "/admin/posts/new"
@page "/admin/posts/edit/{Id:guid}"
@attribute [Authorize]
@inject IPostRepository PostRepository
@inject ISlugService SlugService
@inject NavigationManager Navigation
@inject AuthenticationStateProvider AuthStateProvider
@using System.Security.Claims

<PageTitle>@(_isEdit ? "Edit Post" : "New Post")</PageTitle>

<h1>@(_isEdit ? "Edit Post" : "New Post")</h1>

<div class="post-editor">
    <div class="editor-form">
        <div class="form-group">
            <label for="title">Title</label>
            <input type="text" id="title" @bind="_title" @bind:event="oninput" />
        </div>

        <div class="form-group">
            <label for="summary">Summary</label>
            <textarea id="summary" @bind="_summary" rows="2"></textarea>
        </div>

        <div class="form-group">
            <label for="content">Content (Markdown)</label>
            <textarea id="content" @bind="_content" @bind:event="oninput" rows="20"></textarea>
        </div>

        <div class="form-group checkbox">
            <label>
                <input type="checkbox" @bind="_isPublished" />
                Published
            </label>
        </div>

        <div class="form-actions">
            <button @onclick="Save" class="btn btn-primary">Save</button>
            <a href="/admin/posts" class="btn">Cancel</a>
        </div>
    </div>

    <div class="editor-preview">
        <h3>Preview</h3>
        <div class="preview-content">
            <MarkdownRenderer Content="@_content" />
        </div>
    </div>
</div>

@code {
    [Parameter]
    public Guid? Id { get; set; }

    private bool _isEdit => Id.HasValue;
    private string _title = "";
    private string _summary = "";
    private string _content = "";
    private bool _isPublished;
    private Post? _existingPost;

    protected override async Task OnParametersSetAsync()
    {
        if (_isEdit)
        {
            _existingPost = await PostRepository.GetByIdAsync(Id!.Value);
            if (_existingPost is not null)
            {
                _title = _existingPost.Title;
                _summary = _existingPost.Summary;
                _content = _existingPost.Content;
                _isPublished = _existingPost.IsPublished;
            }
        }
    }

    private async Task Save()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var userIdClaim = authState.User.FindFirst(ClaimTypes.NameIdentifier);
        var userId = Guid.Parse(userIdClaim!.Value);

        if (_isEdit && _existingPost is not null)
        {
            _existingPost.Title = _title;
            _existingPost.Slug = SlugService.GenerateSlug(_title);
            _existingPost.Summary = _summary;
            _existingPost.Content = _content;
            _existingPost.IsPublished = _isPublished;
            _existingPost.UpdatedAtUtc = DateTime.UtcNow;
            if (_isPublished && !_existingPost.PublishedAtUtc.HasValue)
            {
                _existingPost.PublishedAtUtc = DateTime.UtcNow;
            }

            await PostRepository.UpdateAsync(_existingPost);
        }
        else
        {
            var post = new Post
            {
                Id = Guid.NewGuid(),
                Title = _title,
                Slug = SlugService.GenerateSlug(_title),
                Summary = _summary,
                Content = _content,
                AuthorId = userId,
                CreatedAtUtc = DateTime.UtcNow,
                UpdatedAtUtc = DateTime.UtcNow,
                IsPublished = _isPublished,
                PublishedAtUtc = _isPublished ? DateTime.UtcNow : null
            };

            await PostRepository.CreateAsync(post);
        }

        Navigation.NavigateTo("/admin/posts");
    }
}
EOF

# Components/Pages/Admin/ImageManager.razor
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Pages/Admin/ImageManager.razor"
@page "/admin/images"
@attribute [Authorize]
@inject IImageRepository ImageRepository
@inject AuthenticationStateProvider AuthStateProvider
@using System.Security.Claims

<PageTitle>Manage Images</PageTitle>

<h1>Manage Images</h1>

<div class="image-upload">
    <h3>Upload New Image</h3>
    <InputFile OnChange="HandleFileUpload" accept="image/*" />
    @if (!string.IsNullOrEmpty(_uploadStatus))
    {
        <p class="@(_uploadError ? "error" : "success")">@_uploadStatus</p>
    }
</div>

<h3>Uploaded Images</h3>
@if (_images is null)
{
    <p>Loading...</p>
}
else if (_images.Count == 0)
{
    <p>No images uploaded yet.</p>
}
else
{
    <div class="image-grid">
        @foreach (var image in _images)
        {
            <div class="image-card">
                <img src="/api/images/@image.Id" alt="@image.FileName" />
                <div class="image-info">
                    <p>@image.FileName</p>
                    <code>/api/images/@image.Id</code>
                    <button @onclick="() => DeleteImage(image.Id)" class="btn-link danger">Delete</button>
                </div>
            </div>
        }
    </div>
}

@code {
    private IReadOnlyList<Image>? _images;
    private string? _uploadStatus;
    private bool _uploadError;

    protected override async Task OnInitializedAsync()
    {
        await LoadImages();
    }

    private async Task LoadImages()
    {
        _images = await ImageRepository.GetAllAsync();
    }

    private async Task HandleFileUpload(InputFileChangeEventArgs e)
    {
        _uploadStatus = null;
        _uploadError = false;

        var file = e.File;
        if (file.Size > AppConstants.MaxImageSizeBytes)
        {
            _uploadStatus = "File too large. Maximum size is 5MB.";
            _uploadError = true;
            return;
        }

        if (!AppConstants.AllowedImageTypes.Contains(file.ContentType))
        {
            _uploadStatus = "Invalid file type. Only JPEG, PNG, GIF, and WebP are allowed.";
            _uploadError = true;
            return;
        }

        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var userIdClaim = authState.User.FindFirst(ClaimTypes.NameIdentifier);
        var userId = Guid.Parse(userIdClaim!.Value);

        using var stream = file.OpenReadStream(AppConstants.MaxImageSizeBytes);
        using var ms = new MemoryStream();
        await stream.CopyToAsync(ms);

        var image = new Image
        {
            Id = Guid.NewGuid(),
            FileName = file.Name,
            ContentType = file.ContentType,
            Data = ms.ToArray(),
            UploadedAtUtc = DateTime.UtcNow,
            UploadedByUserId = userId
        };

        await ImageRepository.CreateAsync(image);
        _uploadStatus = "Image uploaded successfully!";
        await LoadImages();
    }

    private async Task DeleteImage(Guid id)
    {
        await ImageRepository.DeleteAsync(id);
        await LoadImages();
    }
}
EOF

# wwwroot/css/site.css
cat << 'EOF' > "$SRC_DIR/MyBlog.Web/wwwroot/css/site.css"
/* =============================================================================
   MyBlog CSS - Custom styles without any framework
   ============================================================================= */

/* CSS Variables for theming */
:root {
    --color-bg: #ffffff;
    --color-bg-alt: #f8f9fa;
    --color-text: #212529;
    --color-text-muted: #6c757d;
    --color-primary: #0d6efd;
    --color-primary-hover: #0b5ed7;
    --color-border: #dee2e6;
    --color-danger: #dc3545;
    --color-success: #198754;
    --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    --font-mono: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    --max-width: 1200px;
    --spacing: 1rem;
    --radius: 0.375rem;
}

/* Reset and base styles */
*, *::before, *::after {
    box-sizing: border-box;
}

html {
    font-size: 16px;
    line-height: 1.5;
}

body {
    margin: 0;
    font-family: var(--font-sans);
    color: var(--color-text);
    background-color: var(--color-bg);
}

h1, h2, h3, h4, h5, h6 {
    margin-top: 0;
    margin-bottom: 0.5em;
    font-weight: 600;
    line-height: 1.2;
}

h1 { font-size: 2.5rem; }
h2 { font-size: 2rem; }
h3 { font-size: 1.5rem; }

p {
    margin-top: 0;
    margin-bottom: 1rem;
}

a {
    color: var(--color-primary);
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

/* Container */
.container {
    max-width: var(--max-width);
    margin: 0 auto;
    padding: 0 var(--spacing);
}

/* Layout */
.layout {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Header */
.header {
    background-color: var(--color-bg-alt);
    border-bottom: 1px solid var(--color-border);
    padding: var(--spacing) 0;
}

.header .container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--spacing);
}

.logo {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-text);
}

.logo:hover {
    text-decoration: none;
}

.nav {
    display: flex;
    gap: var(--spacing);
    align-items: center;
}

.nav a {
    color: var(--color-text);
}

.logout-form {
    display: inline;
}

.logout-form button {
    background: none;
    border: none;
    color: var(--color-primary);
    cursor: pointer;
    font: inherit;
    padding: 0;
}

.logout-form button:hover {
    text-decoration: underline;
}

/* Main content */
.main {
    flex: 1;
    padding: calc(var(--spacing) * 2) 0;
}

/* Footer */
.footer {
    background-color: var(--color-bg-alt);
    border-top: 1px solid var(--color-border);
    padding: var(--spacing) 0;
    text-align: center;
    color: var(--color-text-muted);
}

/* Buttons */
.btn {
    display: inline-block;
    padding: 0.5rem 1rem;
    background-color: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    color: var(--color-text);
    cursor: pointer;
    font: inherit;
    text-decoration: none;
    transition: background-color 0.2s;
}

.btn:hover {
    background-color: var(--color-border);
    text-decoration: none;
}

.btn-primary {
    background-color: var(--color-primary);
    border-color: var(--color-primary);
    color: white;
}

.btn-primary:hover {
    background-color: var(--color-primary-hover);
}

.btn-link {
    background: none;
    border: none;
    color: var(--color-primary);
    cursor: pointer;
    padding: 0;
    font: inherit;
}

.btn-link:hover {
    text-decoration: underline;
}

.btn-link.danger {
    color: var(--color-danger);
}

/* Forms */
.form-group {
    margin-bottom: var(--spacing);
}

.form-group label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: 500;
}

.form-group input[type="text"],
.form-group input[type="password"],
.form-group input[type="email"],
.form-group textarea {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    font: inherit;
}

.form-group textarea {
    resize: vertical;
}

.form-group.checkbox label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.form-group.checkbox input {
    width: auto;
}

.form-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: var(--spacing);
}

/* Post cards */
.post-list {
    display: flex;
    flex-direction: column;
    gap: calc(var(--spacing) * 2);
}

.post-card {
    padding: var(--spacing);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
}

.post-card-title {
    margin-bottom: 0.5rem;
}

.post-card-title a {
    color: var(--color-text);
}

.post-card-meta {
    color: var(--color-text-muted);
    font-size: 0.875rem;
    margin-bottom: 0.5rem;
}

.post-card-meta span {
    margin-right: 1rem;
}

.draft-badge {
    background-color: var(--color-text-muted);
    color: white;
    padding: 0.125rem 0.5rem;
    border-radius: var(--radius);
    font-size: 0.75rem;
}

.read-more {
    font-weight: 500;
}

/* Pagination */
.pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: var(--spacing);
    margin-top: calc(var(--spacing) * 2);
}

.page-info {
    color: var(--color-text-muted);
}

/* Post detail */
.post-detail {
    max-width: 800px;
}

.post-header {
    margin-bottom: calc(var(--spacing) * 2);
}

.post-meta {
    color: var(--color-text-muted);
}

.post-meta span {
    margin-right: 1rem;
}

.back-link {
    display: inline-block;
    margin-top: calc(var(--spacing) * 2);
}

/* Markdown content */
.markdown-content {
    line-height: 1.7;
}

.markdown-content h1,
.markdown-content h2,
.markdown-content h3,
.markdown-content h4,
.markdown-content h5,
.markdown-content h6 {
    margin-top: 1.5em;
}

.markdown-content pre {
    background-color: var(--color-bg-alt);
    padding: var(--spacing);
    border-radius: var(--radius);
    overflow-x: auto;
}

.markdown-content code {
    font-family: var(--font-mono);
    font-size: 0.875em;
}

.markdown-content :not(pre) > code {
    background-color: var(--color-bg-alt);
    padding: 0.125rem 0.25rem;
    border-radius: 0.25rem;
}

.markdown-content blockquote {
    border-left: 4px solid var(--color-border);
    margin: 0;
    padding-left: var(--spacing);
    color: var(--color-text-muted);
}

.markdown-content img {
    max-width: 100%;
    height: auto;
}

.markdown-content hr {
    border: none;
    border-top: 1px solid var(--color-border);
    margin: calc(var(--spacing) * 2) 0;
}

/* Login page */
.login-page {
    max-width: 400px;
    margin: 0 auto;
}

.error-message {
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
    color: #842029;
    padding: var(--spacing);
    border-radius: var(--radius);
    margin-bottom: var(--spacing);
}

/* Admin styles */
.dashboard-stats {
    display: flex;
    gap: var(--spacing);
    margin-bottom: calc(var(--spacing) * 2);
}

.stat-card {
    padding: var(--spacing);
    background-color: var(--color-bg-alt);
    border-radius: var(--radius);
    text-align: center;
}

.stat-value {
    font-size: 2rem;
    font-weight: 700;
    margin: 0;
}

.admin-nav {
    display: flex;
    gap: 0.5rem;
    margin-bottom: calc(var(--spacing) * 2);
}

.admin-table {
    width: 100%;
    border-collapse: collapse;
}

.admin-table th,
.admin-table td {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 1px solid var(--color-border);
}

.admin-table th {
    background-color: var(--color-bg-alt);
    font-weight: 600;
}

/* Post editor */
.post-editor {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: calc(var(--spacing) * 2);
}

.editor-preview {
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    padding: var(--spacing);
    max-height: 80vh;
    overflow-y: auto;
}

.editor-preview h3 {
    margin-bottom: var(--spacing);
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--color-border);
}

/* Image manager */
.image-upload {
    margin-bottom: calc(var(--spacing) * 2);
    padding: var(--spacing);
    background-color: var(--color-bg-alt);
    border-radius: var(--radius);
}

.image-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: var(--spacing);
}

.image-card {
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    overflow: hidden;
}

.image-card img {
    width: 100%;
    height: 150px;
    object-fit: cover;
}

.image-info {
    padding: 0.5rem;
}

.image-info p {
    margin: 0 0 0.25rem;
    font-size: 0.875rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.image-info code {
    display: block;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    margin-bottom: 0.25rem;
}

.success {
    color: var(--color-success);
}

.error {
    color: var(--color-danger);
}

/* Responsive */
@media (max-width: 768px) {
    h1 { font-size: 2rem; }
    h2 { font-size: 1.5rem; }
    
    .header .container {
        flex-direction: column;
        text-align: center;
    }
    
    .nav {
        flex-wrap: wrap;
        justify-content: center;
    }
    
    .post-editor {
        grid-template-columns: 1fr;
    }
    
    .editor-preview {
        order: -1;
        max-height: 300px;
    }
    
    .dashboard-stats {
        flex-direction: column;
    }
    
    .admin-nav {
        flex-wrap: wrap;
    }
}
EOF

echo "      Created MyBlog.Web project with Blazor components and CSS."

# =============================================================================
# Step 6: Create MyBlog.Tests Project
# =============================================================================
echo ""
echo "[6/8] Creating MyBlog.Tests project (xUnit v3 tests)..."
echo "      WHY: Comprehensive tests ensure reliability and enable safe refactoring."
echo "           Using in-memory SQLite allows fast, isolated integration tests."

# MyBlog.Tests.csproj
cat << 'EOF' > "$SRC_DIR/MyBlog.Tests/MyBlog.Tests.csproj"
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>MyBlog.Tests</RootNamespace>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="xunit.v3" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\MyBlog.Core\MyBlog.Core.csproj" />
    <ProjectReference Include="..\MyBlog.Infrastructure\MyBlog.Infrastructure.csproj" />
  </ItemGroup>
</Project>
EOF

# Unit/SlugServiceTests.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Tests/Unit/SlugServiceTests.cs"
using MyBlog.Core.Services;
using Xunit;

namespace MyBlog.Tests.Unit;

public class SlugServiceTests
{
    private readonly SlugService _sut = new();

    [Fact]
    public void GenerateSlug_WithSimpleTitle_ReturnsLowercaseWithHyphens()
    {
        var result = _sut.GenerateSlug("Hello World");
        Assert.Equal("hello-world", result);
    }

    [Fact]
    public void GenerateSlug_WithSpecialCharacters_RemovesThem()
    {
        var result = _sut.GenerateSlug("Hello, World! How's it going?");
        Assert.Equal("hello-world-hows-it-going", result);
    }

    [Fact]
    public void GenerateSlug_WithMultipleSpaces_CollapsesToSingleHyphen()
    {
        var result = _sut.GenerateSlug("Hello    World");
        Assert.Equal("hello-world", result);
    }

    [Fact]
    public void GenerateSlug_WithUnicode_RemovesDiacritics()
    {
        var result = _sut.GenerateSlug("Café résumé");
        Assert.Equal("cafe-resume", result);
    }

    [Fact]
    public void GenerateSlug_WithLeadingTrailingSpaces_TrimsHyphens()
    {
        var result = _sut.GenerateSlug("  Hello World  ");
        Assert.Equal("hello-world", result);
    }

    [Fact]
    public void GenerateSlug_WithNumbers_PreservesNumbers()
    {
        var result = _sut.GenerateSlug("Top 10 Tips for 2024");
        Assert.Equal("top-10-tips-for-2024", result);
    }

    [Fact]
    public void GenerateSlug_WithUnderscores_ConvertsToHyphens()
    {
        var result = _sut.GenerateSlug("hello_world_test");
        Assert.Equal("hello-world-test", result);
    }

    [Fact]
    public void GenerateSlug_WithEmptyString_ThrowsArgumentException()
    {
        Assert.Throws<ArgumentException>(() => _sut.GenerateSlug(""));
    }

    [Fact]
    public void GenerateSlug_WithWhitespaceOnly_ThrowsArgumentException()
    {
        Assert.Throws<ArgumentException>(() => _sut.GenerateSlug("   "));
    }
}
EOF

# Unit/MarkdownServiceTests.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Tests/Unit/MarkdownServiceTests.cs"
using MyBlog.Core.Services;
using Xunit;

namespace MyBlog.Tests.Unit;

public class MarkdownServiceTests
{
    private readonly MarkdownService _sut = new();

    [Fact]
    public void ToHtml_WithHeading1_ReturnsH1Tag()
    {
        var result = _sut.ToHtml("# Hello");
        Assert.Contains("<h1>Hello</h1>", result);
    }

    [Fact]
    public void ToHtml_WithHeading2_ReturnsH2Tag()
    {
        var result = _sut.ToHtml("## Hello");
        Assert.Contains("<h2>Hello</h2>", result);
    }

    [Fact]
    public void ToHtml_WithHeading6_ReturnsH6Tag()
    {
        var result = _sut.ToHtml("###### Hello");
        Assert.Contains("<h6>Hello</h6>", result);
    }

    [Fact]
    public void ToHtml_WithBoldText_ReturnsStrongTag()
    {
        var result = _sut.ToHtml("This is **bold** text");
        Assert.Contains("<strong>bold</strong>", result);
    }

    [Fact]
    public void ToHtml_WithItalicText_ReturnsEmTag()
    {
        var result = _sut.ToHtml("This is *italic* text");
        Assert.Contains("<em>italic</em>", result);
    }

    [Fact]
    public void ToHtml_WithLink_ReturnsAnchorTag()
    {
        var result = _sut.ToHtml("Check [this link](https://example.com)");
        Assert.Contains("<a href=\"https://example.com\">this link</a>", result);
    }

    [Fact]
    public void ToHtml_WithImage_ReturnsImgTag()
    {
        var result = _sut.ToHtml("![alt text](https://example.com/image.png)");
        Assert.Contains("<img src=\"https://example.com/image.png\" alt=\"alt text\" />", result);
    }

    [Fact]
    public void ToHtml_WithInlineCode_ReturnsCodeTag()
    {
        var result = _sut.ToHtml("Use `code` here");
        Assert.Contains("<code>code</code>", result);
    }

    [Fact]
    public void ToHtml_WithCodeBlock_ReturnsPreCodeTags()
    {
        var markdown = "```\nvar x = 1;\n```";
        var result = _sut.ToHtml(markdown);
        Assert.Contains("<pre><code>", result);
        Assert.Contains("var x = 1;", result);
        Assert.Contains("</code></pre>", result);
    }

    [Fact]
    public void ToHtml_WithBlockquote_ReturnsBlockquoteTag()
    {
        var result = _sut.ToHtml("> This is a quote");
        Assert.Contains("<blockquote><p>This is a quote</p></blockquote>", result);
    }

    [Fact]
    public void ToHtml_WithUnorderedList_ReturnsUlLiTags()
    {
        var markdown = "- Item 1\n- Item 2";
        var result = _sut.ToHtml(markdown);
        Assert.Contains("<ul>", result);
        Assert.Contains("<li>Item 1</li>", result);
        Assert.Contains("<li>Item 2</li>", result);
        Assert.Contains("</ul>", result);
    }

    [Fact]
    public void ToHtml_WithHorizontalRule_ReturnsHrTag()
    {
        var result = _sut.ToHtml("---");
        Assert.Contains("<hr />", result);
    }

    [Fact]
    public void ToHtml_WithEmptyString_ReturnsEmptyString()
    {
        var result = _sut.ToHtml("");
        Assert.Equal(string.Empty, result);
    }

    [Fact]
    public void ToHtml_WithPlainText_ReturnsParagraph()
    {
        var result = _sut.ToHtml("Hello world");
        Assert.Contains("<p>Hello world</p>", result);
    }

    [Fact]
    public void ToHtml_WithHtmlCharacters_EscapesThem()
    {
        var result = _sut.ToHtml("Use <script> tags");
        Assert.Contains("&lt;script&gt;", result);
        Assert.DoesNotContain("<script>", result);
    }
}
EOF

# Unit/PasswordServiceTests.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Tests/Unit/PasswordServiceTests.cs"
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Unit;

public class PasswordServiceTests
{
    private readonly PasswordService _sut = new();

    [Fact]
    public void HashPassword_ReturnsNonEmptyHash()
    {
        var hash = _sut.HashPassword("TestPassword123");
        Assert.False(string.IsNullOrEmpty(hash));
    }

    [Fact]
    public void HashPassword_ReturnsDifferentHashForSamePassword()
    {
        var hash1 = _sut.HashPassword("TestPassword123");
        var hash2 = _sut.HashPassword("TestPassword123");
        Assert.NotEqual(hash1, hash2);
    }

    [Fact]
    public void VerifyPassword_WithCorrectPassword_ReturnsTrue()
    {
        var password = "TestPassword123";
        var hash = _sut.HashPassword(password);
        
        var result = _sut.VerifyPassword(hash, password);
        
        Assert.True(result);
    }

    [Fact]
    public void VerifyPassword_WithWrongPassword_ReturnsFalse()
    {
        var hash = _sut.HashPassword("TestPassword123");
        
        var result = _sut.VerifyPassword(hash, "WrongPassword");
        
        Assert.False(result);
    }

    [Fact]
    public void VerifyPassword_WithEmptyPassword_ReturnsFalse()
    {
        var hash = _sut.HashPassword("TestPassword123");
        
        var result = _sut.VerifyPassword(hash, "");
        
        Assert.False(result);
    }
}
EOF

# Integration/PostRepositoryTests.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Tests/Integration/PostRepositoryTests.cs"
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using Xunit;

namespace MyBlog.Tests.Integration;

public class PostRepositoryTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly PostRepository _sut;
    private readonly User _testUser;

    public PostRepositoryTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _testUser = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = "hash",
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(_testUser);
        _context.SaveChanges();

        _sut = new PostRepository(_context);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task CreateAsync_AddsPostToDatabase()
    {
        var post = CreateTestPost("Test Post");

        var result = await _sut.CreateAsync(post);

        Assert.NotEqual(Guid.Empty, result.Id);
        var saved = await _context.Posts.FindAsync(result.Id);
        Assert.NotNull(saved);
        Assert.Equal("Test Post", saved.Title);
    }

    [Fact]
    public async Task GetByIdAsync_WithExistingId_ReturnsPost()
    {
        var post = CreateTestPost("Test Post");
        await _sut.CreateAsync(post);

        var result = await _sut.GetByIdAsync(post.Id);

        Assert.NotNull(result);
        Assert.Equal("Test Post", result.Title);
    }

    [Fact]
    public async Task GetByIdAsync_WithNonExistingId_ReturnsNull()
    {
        var result = await _sut.GetByIdAsync(Guid.NewGuid());
        Assert.Null(result);
    }

    [Fact]
    public async Task GetBySlugAsync_WithExistingSlug_ReturnsPost()
    {
        var post = CreateTestPost("Test Post", "test-post");
        await _sut.CreateAsync(post);

        var result = await _sut.GetBySlugAsync("test-post");

        Assert.NotNull(result);
        Assert.Equal("Test Post", result.Title);
    }

    [Fact]
    public async Task GetPublishedPostsAsync_ReturnsOnlyPublishedPosts()
    {
        var published = CreateTestPost("Published", "published", true);
        var draft = CreateTestPost("Draft", "draft", false);
        await _sut.CreateAsync(published);
        await _sut.CreateAsync(draft);

        var (posts, count) = await _sut.GetPublishedPostsAsync(1, 10);

        Assert.Single(posts);
        Assert.Equal("Published", posts[0].Title);
        Assert.Equal(1, count);
    }

    [Fact]
    public async Task UpdateAsync_ModifiesExistingPost()
    {
        var post = CreateTestPost("Original Title");
        await _sut.CreateAsync(post);

        post.Title = "Updated Title";
        await _sut.UpdateAsync(post);

        var updated = await _context.Posts.FindAsync(post.Id);
        Assert.Equal("Updated Title", updated!.Title);
    }

    [Fact]
    public async Task DeleteAsync_RemovesPostFromDatabase()
    {
        var post = CreateTestPost("To Delete");
        await _sut.CreateAsync(post);

        await _sut.DeleteAsync(post.Id);

        var deleted = await _context.Posts.FindAsync(post.Id);
        Assert.Null(deleted);
    }

    [Fact]
    public async Task GetCountAsync_ReturnsCorrectCount()
    {
        await _sut.CreateAsync(CreateTestPost("Post 1"));
        await _sut.CreateAsync(CreateTestPost("Post 2"));
        await _sut.CreateAsync(CreateTestPost("Post 3"));

        var count = await _sut.GetCountAsync();

        Assert.Equal(3, count);
    }

    private Post CreateTestPost(string title, string? slug = null, bool isPublished = true)
    {
        return new Post
        {
            Id = Guid.NewGuid(),
            Title = title,
            Slug = slug ?? title.ToLower().Replace(" ", "-"),
            Content = "Test content",
            Summary = "Test summary",
            AuthorId = _testUser.Id,
            CreatedAtUtc = DateTime.UtcNow,
            UpdatedAtUtc = DateTime.UtcNow,
            IsPublished = isPublished,
            PublishedAtUtc = isPublished ? DateTime.UtcNow : null
        };
    }
}
EOF

# Integration/AuthServiceTests.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Tests/Integration/AuthServiceTests.cs"
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Integration;

public class AuthServiceTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly AuthService _sut;
    private readonly PasswordService _passwordService;

    public AuthServiceTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        var userRepository = new UserRepository(_context);
        _passwordService = new PasswordService();
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Authentication:DefaultAdminPassword"] = "TestAdmin123!"
            })
            .Build();

        _sut = new AuthService(userRepository, _passwordService, configuration);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task AuthenticateAsync_WithValidCredentials_ReturnsUser()
    {
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword("TestPassword"),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync();

        var result = await _sut.AuthenticateAsync("testuser", "TestPassword");

        Assert.NotNull(result);
        Assert.Equal("testuser", result.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_WithWrongPassword_ReturnsNull()
    {
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword("TestPassword"),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync();

        var result = await _sut.AuthenticateAsync("testuser", "WrongPassword");

        Assert.Null(result);
    }

    [Fact]
    public async Task AuthenticateAsync_WithUnknownUser_ReturnsNull()
    {
        var result = await _sut.AuthenticateAsync("nonexistent", "anypassword");
        Assert.Null(result);
    }

    [Fact]
    public async Task EnsureAdminUserAsync_WhenNoUsers_CreatesAdmin()
    {
        await _sut.EnsureAdminUserAsync();

        var admin = await _context.Users.FirstOrDefaultAsync(u => u.Username == "admin");
        Assert.NotNull(admin);
    }

    [Fact]
    public async Task EnsureAdminUserAsync_WhenUsersExist_DoesNotCreateAnother()
    {
        var existingUser = new User
        {
            Id = Guid.NewGuid(),
            Username = "existing",
            PasswordHash = "hash",
            Email = "existing@example.com",
            DisplayName = "Existing",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(existingUser);
        await _context.SaveChangesAsync();

        await _sut.EnsureAdminUserAsync();

        var userCount = await _context.Users.CountAsync();
        Assert.Equal(1, userCount);
    }
}
EOF

# Integration/TelemetryCleanupTests.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Tests/Integration/TelemetryCleanupTests.cs"
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using Xunit;

namespace MyBlog.Tests.Integration;

public class TelemetryCleanupTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly TelemetryLogRepository _sut;

    public TelemetryCleanupTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _sut = new TelemetryLogRepository(_context);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task DeleteOlderThanAsync_RemovesOldLogs()
    {
        // Add old logs
        var oldLog = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow.AddDays(-60),
            Level = "Information",
            Category = "Test",
            Message = "Old log"
        };
        _context.TelemetryLogs.Add(oldLog);

        // Add recent log
        var recentLog = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow.AddDays(-5),
            Level = "Information",
            Category = "Test",
            Message = "Recent log"
        };
        _context.TelemetryLogs.Add(recentLog);
        await _context.SaveChangesAsync();

        var cutoff = DateTime.UtcNow.AddDays(-30);
        var deleted = await _sut.DeleteOlderThanAsync(cutoff);

        Assert.Equal(1, deleted);
        var remaining = await _context.TelemetryLogs.CountAsync();
        Assert.Equal(1, remaining);
    }

    [Fact]
    public async Task DeleteOlderThanAsync_KeepsRecentLogs()
    {
        var recentLog = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow.AddDays(-1),
            Level = "Information",
            Category = "Test",
            Message = "Recent log"
        };
        _context.TelemetryLogs.Add(recentLog);
        await _context.SaveChangesAsync();

        var cutoff = DateTime.UtcNow.AddDays(-30);
        var deleted = await _sut.DeleteOlderThanAsync(cutoff);

        Assert.Equal(0, deleted);
        var remaining = await _context.TelemetryLogs.CountAsync();
        Assert.Equal(1, remaining);
    }

    [Fact]
    public async Task WriteAsync_AddsLogToDatabase()
    {
        var log = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow,
            Level = "Error",
            Category = "Test",
            Message = "Test error message"
        };

        await _sut.WriteAsync(log);

        var saved = await _context.TelemetryLogs.FirstOrDefaultAsync();
        Assert.NotNull(saved);
        Assert.Equal("Error", saved.Level);
        Assert.Equal("Test error message", saved.Message);
    }
}
EOF

echo "      Created MyBlog.Tests project with unit and integration tests."

# =============================================================================
# Step 7: Create GitHub Actions Workflow
# =============================================================================
echo ""
echo "[7/8] Creating GitHub Actions workflow..."
echo "      WHY: CI/CD automation ensures every change is tested across platforms"
echo "           and automatically deploys to production on protected branches."

cat << 'EOF' > "$SRC_DIR/.github/workflows/build-deploy.yml"
name: Build, Test, and Deploy

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

jobs:
  build-test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore dependencies
        run: dotnet restore src/MyBlog.slnx

      - name: Build solution
        run: dotnet build src/MyBlog.slnx -c Release --no-restore

      - name: Run tests
        run: dotnet test src/MyBlog.slnx -c Release --no-build --logger trx --results-directory TestResults

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.os }}
          path: TestResults
          retention-days: 7

  deploy:
    needs: build-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Publish application
        run: dotnet publish src/MyBlog.Web/MyBlog.Web.csproj -c Release -o ./publish -r win-x86 --self-contained false

      - name: Deploy via WebDeploy
        shell: pwsh
        run: |
          # WebDeploy is typically pre-installed on windows-latest
          $msdeployPath = "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe"
          
          if (-not (Test-Path $msdeployPath)) {
            Write-Host "Installing Web Deploy..."
            choco install webdeploy -y --no-progress
            $msdeployPath = "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe"
          }
          
          Write-Host "Deploying to ${{ secrets.SERVER_COMPUTER_NAME }}..."
          
          & $msdeployPath -verb:sync `
            -source:contentPath="${{ github.workspace }}\publish" `
            -dest:contentPath="${{ secrets.WEBSITE_NAME }}",computerName="https://${{ secrets.SERVER_COMPUTER_NAME }}:8172/msdeploy.axd",userName="${{ secrets.SERVER_USERNAME }}",password="${{ secrets.SERVER_PASSWORD }}",authType="Basic" `
            -allowUntrusted `
            -enableRule:DoNotDeleteRule
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Deployment failed with exit code $LASTEXITCODE"
            exit 1
          }
          
          Write-Host "Deployment completed successfully!"
EOF

echo "      Created GitHub Actions workflow for CI/CD."

# =============================================================================
# Step 8: Final Setup
# =============================================================================
echo ""
echo "[8/8] Setting permissions and creating helper scripts..."

# Make the generator script executable
chmod +x "$SRC_DIR/generate-myblog.sh" 2>/dev/null || true

# Create a run script
cat << 'EOF' > "$SRC_DIR/run.sh"
#!/bin/bash
# Run the MyBlog application in development mode
cd "$(dirname "$0")/MyBlog.Web"
dotnet run
EOF
chmod +x "$SRC_DIR/run.sh"

# Create a test script
cat << 'EOF' > "$SRC_DIR/test.sh"
#!/bin/bash
# Run all tests
cd "$(dirname "$0")"
dotnet test MyBlog.slnx -v normal
EOF
chmod +x "$SRC_DIR/test.sh"

echo "      Created helper scripts."

# =============================================================================
# Complete!
# =============================================================================
echo ""
echo "=============================================="
echo "  Generation Complete!"
echo "=============================================="
echo ""
echo "Project structure created in: $SRC_DIR"
echo ""
echo "Next steps:"
echo ""
echo "  1. Restore packages:"
echo "     cd $SRC_DIR && dotnet restore MyBlog.slnx"
echo ""
echo "  2. Build the solution:"
echo "     dotnet build MyBlog.slnx"
echo ""
echo "  3. Run the application:"
echo "     cd MyBlog.Web && dotnet run"
echo "     OR use: ./run.sh"
echo ""
echo "  4. Run tests:"
echo "     dotnet test MyBlog.slnx"
echo "     OR use: ./test.sh"
echo ""
echo "  5. Access the application:"
echo "     http://localhost:5000 (or the port shown in console)"
echo ""
echo "Default admin credentials:"
echo "  Username: admin"
echo "  Password: ChangeMe123! (or set MYBLOG_ADMIN_PASSWORD env var)"
echo ""
echo "Database location (created on first run):"
echo "  Linux:   ~/.local/share/MyBlog/myblog.db"
echo "  macOS:   ~/Library/Application Support/MyBlog/myblog.db"
echo "  Windows: %LOCALAPPDATA%/MyBlog/myblog.db"
echo ""
echo "For GitHub Actions deployment, set these secrets:"
echo "  - WEBSITE_NAME"
echo "  - SERVER_COMPUTER_NAME"
echo "  - SERVER_USERNAME"
echo "  - SERVER_PASSWORD"
echo ""
echo "Generation completed at: $(date)"
echo "=============================================="


================================================================================
FILE: src/.github/workflows/build-deploy.yml
SIZE: 3.10 KB
MODIFIED: 2025-12-28 10:33:37
================================================================================

name: Build, Test, and Deploy

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

jobs:
  build-test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore dependencies
        run: dotnet restore src/MyBlog.slnx

      - name: Build solution
        run: dotnet build src/MyBlog.slnx -c Release --no-restore

      - name: Run tests
        run: dotnet test src/MyBlog.slnx -c Release --no-build --logger trx --results-directory TestResults

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.os }}
          path: TestResults
          retention-days: 7

  deploy:
    needs: build-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Publish application
        run: dotnet publish src/MyBlog.Web/MyBlog.Web.csproj -c Release -o ./publish -r win-x86 --self-contained false

      - name: Deploy via WebDeploy
        shell: pwsh
        env:
          DEPLOY_SOURCE: ${{ github.workspace }}\publish
          DEPLOY_SITE: ${{ secrets.WEBSITE_NAME }}
          DEPLOY_HOST: ${{ secrets.SERVER_COMPUTER_NAME }}
          DEPLOY_USER: ${{ secrets.SERVER_USERNAME }}
          DEPLOY_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
        run: |
          $msdeployPath = "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe"
          
          if (-not (Test-Path $msdeployPath)) {
            Write-Host "Installing Web Deploy..."
            choco install webdeploy -y --no-progress
          }
          
          Write-Host "Deploying to $env:DEPLOY_HOST..."
          Write-Host "Note: Using AppOffline rule to prevent file-in-use errors"

          $sourceArg = "-source:contentPath=$env:DEPLOY_SOURCE"
          $destArg = "-dest:contentPath=$env:DEPLOY_SITE,computerName=https://$($env:DEPLOY_HOST):8172/MsDeploy.axd?site=$env:DEPLOY_SITE,userName=$env:DEPLOY_USER,password=$env:DEPLOY_PASSWORD,AuthType='Basic'"
          
          # Key fix: Added -enableRule:AppOffline to stop the app during deployment
          # This creates app_offline.htm, waits for app to stop, deploys, then removes the file
          & $msdeployPath -verb:sync $sourceArg $destArg `
            -allowUntrusted `
            -enableRule:DoNotDeleteRule `
            -enableRule:AppOffline `
            -retryAttempts:3 `
            -retryInterval:3000
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Deployment failed with exit code $LASTEXITCODE"
            exit 1
          }
          
          Write-Host "Deployment completed successfully!"


================================================================================
FILE: src/global.json
SIZE: .07 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

{
  "sdk": {
    "version": "10.0.100",
    "rollForward": "latestFeature"
  }
}


================================================================================
FILE: src/MyBlog.Core/Constants/AppConstants.cs
SIZE: .73 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

namespace MyBlog.Core.Constants;

/// <summary>
/// Application-wide constants.
/// </summary>
public static class AppConstants
{
    /// <summary>The name of the authentication cookie.</summary>
    public const string AuthCookieName = "MyBlog.Auth";

    /// <summary>The admin role claim value.</summary>
    public const string AdminRole = "Admin";

    /// <summary>Default page size for listings.</summary>
    public const int DefaultPageSize = 10;

    /// <summary>Maximum image size in bytes (5MB).</summary>
    public const int MaxImageSizeBytes = 5 * 1024 * 1024;

    /// <summary>Allowed image content types.</summary>
    public static readonly string[] AllowedImageTypes =
        ["image/jpeg", "image/png", "image/gif", "image/webp"];
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IAuthService.cs
SIZE: 1.05 KB
MODIFIED: 2025-12-28 10:33:37
================================================================================

using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for authentication operations.
/// </summary>
public interface IAuthService
{
    /// <summary>Attempts to authenticate a user.</summary>
    Task<User?> AuthenticateAsync(
        string username, string password, CancellationToken cancellationToken = default);

    /// <summary>Ensures the default admin user exists.</summary>
    Task EnsureAdminUserAsync(CancellationToken cancellationToken = default);

    /// <summary>Changes a user's password.</summary>
    /// <returns>True if password was changed, false if current password was incorrect.</returns>
    Task<bool> ChangePasswordAsync(
        Guid userId,
        string currentPassword,
        string newPassword,
        CancellationToken cancellationToken = default);

    /// <summary>Resets a user's password without requiring the current password (admin function).</summary>
    Task ResetPasswordAsync(
        Guid userId,
        string newPassword,
        CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IImageRepository.cs
SIZE: .69 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for image operations.
/// </summary>
public interface IImageRepository
{
    /// <summary>Gets all images.</summary>
    Task<IReadOnlyList<Image>> GetAllAsync(CancellationToken cancellationToken = default);

    /// <summary>Gets an image by ID.</summary>
    Task<Image?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Creates a new image.</summary>
    Task<Image> CreateAsync(Image image, CancellationToken cancellationToken = default);

    /// <summary>Deletes an image by ID.</summary>
    Task DeleteAsync(Guid id, CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IMarkdownService.cs
SIZE: .24 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for rendering Markdown to HTML.
/// </summary>
public interface IMarkdownService
{
    /// <summary>Converts Markdown text to HTML.</summary>
    string ToHtml(string markdown);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IPasswordService.cs
SIZE: .38 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for password hashing and verification.
/// </summary>
public interface IPasswordService
{
    /// <summary>Hashes a plain text password.</summary>
    string HashPassword(string password);

    /// <summary>Verifies a password against a hash.</summary>
    bool VerifyPassword(string hashedPassword, string providedPassword);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IPostRepository.cs
SIZE: 1.56 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for post operations.
/// </summary>
public interface IPostRepository
{
    /// <summary>Gets a paginated list of published posts.</summary>
    Task<(IReadOnlyList<PostListItemDto> Posts, int TotalCount)> GetPublishedPostsAsync(
        int page, int pageSize, CancellationToken cancellationToken = default);

    /// <summary>Gets all posts for admin view.</summary>
    Task<IReadOnlyList<PostListItemDto>> GetAllPostsAsync(
        CancellationToken cancellationToken = default);

    /// <summary>Gets a post by its slug.</summary>
    Task<PostDetailDto?> GetBySlugAsync(string slug, CancellationToken cancellationToken = default);

    /// <summary>Gets a post by its ID.</summary>
    Task<Post?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Creates a new post.</summary>
    Task<Post> CreateAsync(Post post, CancellationToken cancellationToken = default);

    /// <summary>Updates an existing post.</summary>
    Task UpdateAsync(Post post, CancellationToken cancellationToken = default);

    /// <summary>Deletes a post by ID.</summary>
    Task DeleteAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Gets the total count of posts.</summary>
    Task<int> GetCountAsync(CancellationToken cancellationToken = default);

    /// <summary>Gets recent posts for dashboard.</summary>
    Task<IReadOnlyList<PostListItemDto>> GetRecentPostsAsync(
        int count, CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/ISlugService.cs
SIZE: .24 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for generating URL-friendly slugs.
/// </summary>
public interface ISlugService
{
    /// <summary>Generates a slug from a title.</summary>
    string GenerateSlug(string title);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/ITelemetryLogRepository.cs
SIZE: .67 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for telemetry log operations.
/// </summary>
public interface ITelemetryLogRepository
{
    /// <summary>Writes a log entry to the database.</summary>
    Task WriteAsync(TelemetryLog log, CancellationToken cancellationToken = default);

    /// <summary>Deletes logs older than the specified date.</summary>
    Task<int> DeleteOlderThanAsync(DateTime cutoffUtc, CancellationToken cancellationToken = default);

    /// <summary>Gets recent logs for viewing.</summary>
    Task<IReadOnlyList<TelemetryLog>> GetRecentAsync(
        int count, CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/MyBlog.Core/Interfaces/IUserRepository.cs
SIZE: .83 KB
MODIFIED: 2025-12-28 10:33:37
================================================================================

using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for user data access.
/// </summary>
public interface IUserRepository
{
    /// <summary>Gets a user by ID.</summary>
    Task<User?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Gets a user by username.</summary>
    Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default);

    /// <summary>Checks if any users exist.</summary>
    Task<bool> AnyUsersExistAsync(CancellationToken cancellationToken = default);

    /// <summary>Creates a new user.</summary>
    Task CreateAsync(User user, CancellationToken cancellationToken = default);

    /// <summary>Updates an existing user.</summary>
    Task UpdateAsync(User user, CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/MyBlog.Core/Models/Image.cs
SIZE: 1.15 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

namespace MyBlog.Core.Models;

/// <summary>
/// Represents an image stored as a BLOB in the database.
/// </summary>
public sealed class Image
{
    /// <summary>Gets or sets the unique identifier for the image.</summary>
    public Guid Id { get; set; }

    /// <summary>Gets or sets the original file name.</summary>
    public required string FileName { get; set; }

    /// <summary>Gets or sets the MIME content type.</summary>
    public required string ContentType { get; set; }

    /// <summary>Gets or sets the binary image data.</summary>
    public required byte[] Data { get; set; }

    /// <summary>Gets or sets the associated post ID (optional).</summary>
    public Guid? PostId { get; set; }

    /// <summary>Gets or sets when the image was uploaded.</summary>
    public DateTime UploadedAtUtc { get; set; }

    /// <summary>Gets or sets the ID of the user who uploaded the image.</summary>
    public Guid UploadedByUserId { get; set; }

    /// <summary>Navigation property for the associated post.</summary>
    public Post? Post { get; set; }

    /// <summary>Navigation property for the uploader.</summary>
    public User? UploadedBy { get; set; }
}


================================================================================
FILE: src/MyBlog.Core/Models/Post.cs
SIZE: 1.49 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

namespace MyBlog.Core.Models;

/// <summary>
/// Represents a blog post with Markdown content.
/// </summary>
public sealed class Post
{
    /// <summary>Gets or sets the unique identifier for the post.</summary>
    public Guid Id { get; set; }

    /// <summary>Gets or sets the post title.</summary>
    public required string Title { get; set; }

    /// <summary>Gets or sets the URL-friendly slug.</summary>
    public required string Slug { get; set; }

    /// <summary>Gets or sets the Markdown content of the post.</summary>
    public required string Content { get; set; }

    /// <summary>Gets or sets a brief summary for listings.</summary>
    public required string Summary { get; set; }

    /// <summary>Gets or sets the author's user ID.</summary>
    public Guid AuthorId { get; set; }

    /// <summary>Gets or sets when the post was created.</summary>
    public DateTime CreatedAtUtc { get; set; }

    /// <summary>Gets or sets when the post was last updated.</summary>
    public DateTime UpdatedAtUtc { get; set; }

    /// <summary>Gets or sets when the post was published (null if draft).</summary>
    public DateTime? PublishedAtUtc { get; set; }

    /// <summary>Gets or sets whether the post is publicly visible.</summary>
    public bool IsPublished { get; set; }

    /// <summary>Navigation property for the author.</summary>
    public User? Author { get; set; }

    /// <summary>Navigation property for attached images.</summary>
    public ICollection<Image> Images { get; set; } = [];
}


================================================================================
FILE: src/MyBlog.Core/Models/PostDto.cs
SIZE: .95 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

namespace MyBlog.Core.Models;

/// <summary>Data transfer object for post listings.</summary>
public sealed record PostListItemDto(
    Guid Id,
    string Title,
    string Slug,
    string Summary,
    string AuthorDisplayName,
    DateTime? PublishedAtUtc,
    bool IsPublished);

/// <summary>Data transfer object for creating a new post.</summary>
public sealed record CreatePostDto(
    string Title,
    string Content,
    string Summary,
    bool IsPublished);

/// <summary>Data transfer object for updating a post.</summary>
public sealed record UpdatePostDto(
    string Title,
    string Content,
    string Summary,
    bool IsPublished);

/// <summary>Data transfer object for post details.</summary>
public sealed record PostDetailDto(
    Guid Id,
    string Title,
    string Slug,
    string Content,
    string Summary,
    string AuthorDisplayName,
    DateTime CreatedAtUtc,
    DateTime UpdatedAtUtc,
    DateTime? PublishedAtUtc,
    bool IsPublished);


================================================================================
FILE: src/MyBlog.Core/Models/TelemetryLog.cs
SIZE: 1.17 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

namespace MyBlog.Core.Models;

/// <summary>
/// Represents a telemetry log entry stored in the database.
/// </summary>
public sealed class TelemetryLog
{
    /// <summary>Gets or sets the auto-increment primary key.</summary>
    public int Id { get; set; }

    /// <summary>Gets or sets the UTC timestamp of the log entry.</summary>
    public DateTime TimestampUtc { get; set; }

    /// <summary>Gets or sets the log level (Information, Warning, Error, etc.).</summary>
    public required string Level { get; set; }

    /// <summary>Gets or sets the category/source of the log.</summary>
    public required string Category { get; set; }

    /// <summary>Gets or sets the log message.</summary>
    public required string Message { get; set; }

    /// <summary>Gets or sets the exception details if any.</summary>
    public string? Exception { get; set; }

    /// <summary>Gets or sets the distributed trace ID.</summary>
    public string? TraceId { get; set; }

    /// <summary>Gets or sets the span ID within the trace.</summary>
    public string? SpanId { get; set; }

    /// <summary>Gets or sets additional properties as JSON.</summary>
    public string? Properties { get; set; }
}


================================================================================
FILE: src/MyBlog.Core/Models/User.cs
SIZE: 1.12 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

namespace MyBlog.Core.Models;

/// <summary>
/// Represents a user who can create and manage blog posts.
/// </summary>
public sealed class User
{
    /// <summary>Gets or sets the unique identifier for the user.</summary>
    public Guid Id { get; set; }

    /// <summary>Gets or sets the unique username for authentication.</summary>
    public required string Username { get; set; }

    /// <summary>Gets or sets the hashed password.</summary>
    public required string PasswordHash { get; set; }

    /// <summary>Gets or sets the user's email address.</summary>
    public required string Email { get; set; }

    /// <summary>Gets or sets the display name shown on posts.</summary>
    public required string DisplayName { get; set; }

    /// <summary>Gets or sets when the user account was created.</summary>
    public DateTime CreatedAtUtc { get; set; }

    /// <summary>Navigation property for posts authored by this user.</summary>
    public ICollection<Post> Posts { get; set; } = [];

    /// <summary>Navigation property for images uploaded by this user.</summary>
    public ICollection<Image> UploadedImages { get; set; } = [];
}


================================================================================
FILE: src/MyBlog.Core/MyBlog.Core.csproj
SIZE: .12 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>MyBlog.Core</RootNamespace>
  </PropertyGroup>
</Project>


================================================================================
FILE: src/MyBlog.Core/Services/MarkdownService.cs
SIZE: 6.04 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using MyBlog.Core.Interfaces;

namespace MyBlog.Core.Services;

/// <summary>
/// Custom Markdown to HTML renderer.
/// Supports: headings, bold, italic, links, images, code blocks, blockquotes, lists, horizontal rules.
/// </summary>
public sealed partial class MarkdownService : IMarkdownService
{
    /// <inheritdoc />
    public string ToHtml(string markdown)
    {
        if (string.IsNullOrWhiteSpace(markdown))
        {
            return string.Empty;
        }

        var lines = markdown.Replace("\r\n", "\n").Split('\n');
        var result = new StringBuilder();
        var inCodeBlock = false;
        var inList = false;
        var codeBlockContent = new StringBuilder();

        foreach (var rawLine in lines)
        {
            var line = rawLine;

            // Handle fenced code blocks
            if (line.StartsWith("```"))
            {
                if (inCodeBlock)
                {
                    result.Append("<pre><code>");
                    result.Append(HttpUtility.HtmlEncode(codeBlockContent.ToString().TrimEnd()));
                    result.AppendLine("</code></pre>");
                    codeBlockContent.Clear();
                    inCodeBlock = false;
                }
                else
                {
                    if (inList)
                    {
                        result.AppendLine("</ul>");
                        inList = false;
                    }
                    inCodeBlock = true;
                }
                continue;
            }

            if (inCodeBlock)
            {
                codeBlockContent.AppendLine(line);
                continue;
            }

            // Handle horizontal rules
            if (HorizontalRulePattern().IsMatch(line))
            {
                if (inList)
                {
                    result.AppendLine("</ul>");
                    inList = false;
                }
                result.AppendLine("<hr />");
                continue;
            }

            // Handle headings
            var headingMatch = HeadingPattern().Match(line);
            if (headingMatch.Success)
            {
                if (inList)
                {
                    result.AppendLine("</ul>");
                    inList = false;
                }
                var level = headingMatch.Groups[1].Value.Length;
                var text = ProcessInline(headingMatch.Groups[2].Value.Trim());
                result.AppendLine($"<h{level}>{text}</h{level}>");
                continue;
            }

            // Handle blockquotes
            if (line.StartsWith('>'))
            {
                if (inList)
                {
                    result.AppendLine("</ul>");
                    inList = false;
                }
                var quoteText = ProcessInline(line[1..].TrimStart());
                result.AppendLine($"<blockquote><p>{quoteText}</p></blockquote>");
                continue;
            }

            // Handle unordered lists
            var listMatch = UnorderedListPattern().Match(line);
            if (listMatch.Success)
            {
                if (!inList)
                {
                    result.AppendLine("<ul>");
                    inList = true;
                }
                var itemText = ProcessInline(listMatch.Groups[1].Value);
                result.AppendLine($"<li>{itemText}</li>");
                continue;
            }

            // Close list if no longer in list item
            if (inList && !string.IsNullOrWhiteSpace(line))
            {
                result.AppendLine("</ul>");
                inList = false;
            }

            // Handle empty lines
            if (string.IsNullOrWhiteSpace(line))
            {
                if (inList)
                {
                    result.AppendLine("</ul>");
                    inList = false;
                }
                continue;
            }

            // Regular paragraph
            var paragraphText = ProcessInline(line);
            result.AppendLine($"<p>{paragraphText}</p>");
        }

        // Close any open list
        if (inList)
        {
            result.AppendLine("</ul>");
        }

        // Close any unclosed code block
        if (inCodeBlock)
        {
            result.Append("<pre><code>");
            result.Append(HttpUtility.HtmlEncode(codeBlockContent.ToString().TrimEnd()));
            result.AppendLine("</code></pre>");
        }

        return result.ToString();
    }

    private static string ProcessInline(string text)
    {
        // Escape HTML first
        text = HttpUtility.HtmlEncode(text);

        // Process inline code (must be before bold/italic to avoid conflicts)
        text = InlineCodePattern().Replace(text, "<code>$1</code>");

        // Process images ![alt](url)
        text = ImagePattern().Replace(text, "<img src=\"$2\" alt=\"$1\" />");

        // Process links [text](url)
        text = LinkPattern().Replace(text, "<a href=\"$2\">$1</a>");

        // Process bold **text** or __text__
        text = BoldPattern().Replace(text, "<strong>$1</strong>");

        // Process italic *text* or _text_
        text = ItalicPattern().Replace(text, "<em>$1</em>");

        return text;
    }

    [GeneratedRegex(@"^(#{1,6})\s+(.+)$")]
    private static partial Regex HeadingPattern();

    [GeneratedRegex(@"^[-*]\s+(.+)$")]
    private static partial Regex UnorderedListPattern();

    [GeneratedRegex(@"^[-*_]{3,}\s*$")]
    private static partial Regex HorizontalRulePattern();

    [GeneratedRegex(@"`([^`]+)`")]
    private static partial Regex InlineCodePattern();

    [GeneratedRegex(@"!\[([^\]]*)\]\(([^)]+)\)")]
    private static partial Regex ImagePattern();

    [GeneratedRegex(@"\[([^\]]+)\]\(([^)]+)\)")]
    private static partial Regex LinkPattern();

    [GeneratedRegex(@"\*\*([^*]+)\*\*|__([^_]+)__")]
    private static partial Regex BoldPattern();

    [GeneratedRegex(@"(?<!\*)\*(?!\*)([^*]+)(?<!\*)\*(?!\*)|(?<!_)_(?!_)([^_]+)(?<!_)_(?!_)")]
    private static partial Regex ItalicPattern();
}


================================================================================
FILE: src/MyBlog.Core/Services/SlugService.cs
SIZE: 1.59 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using MyBlog.Core.Interfaces;

namespace MyBlog.Core.Services;

/// <summary>
/// Generates URL-friendly slugs from text.
/// </summary>
public sealed partial class SlugService : ISlugService
{
    /// <inheritdoc />
    public string GenerateSlug(string title)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(title);

        // Normalize unicode and convert to lowercase
        var normalized = title.Normalize(NormalizationForm.FormD);
        var sb = new StringBuilder();

        foreach (var c in normalized)
        {
            var category = CharUnicodeInfo.GetUnicodeCategory(c);
            if (category != UnicodeCategory.NonSpacingMark)
            {
                sb.Append(c);
            }
        }

        var result = sb.ToString().Normalize(NormalizationForm.FormC).ToLowerInvariant();

        // Replace spaces and underscores with hyphens
        result = SpacePattern().Replace(result, "-");

        // Remove all non-alphanumeric characters except hyphens
        result = NonAlphanumericPattern().Replace(result, "");

        // Replace multiple hyphens with single hyphen
        result = MultipleHyphenPattern().Replace(result, "-");

        // Trim hyphens from ends
        result = result.Trim('-');

        return result;
    }

    [GeneratedRegex(@"[\s_]+")]
    private static partial Regex SpacePattern();

    [GeneratedRegex(@"[^a-z0-9\-]")]
    private static partial Regex NonAlphanumericPattern();

    [GeneratedRegex(@"-+")]
    private static partial Regex MultipleHyphenPattern();
}


================================================================================
FILE: src/MyBlog.Infrastructure/Data/BlogDbContext.cs
SIZE: 3.11 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Data;

/// <summary>
/// Entity Framework Core database context for the blog.
/// </summary>
public sealed class BlogDbContext : DbContext
{
    /// <summary>Initializes a new instance of the BlogDbContext.</summary>
    public BlogDbContext(DbContextOptions<BlogDbContext> options) : base(options)
    {
    }

    /// <summary>Gets or sets the Users table.</summary>
    public DbSet<User> Users => Set<User>();

    /// <summary>Gets or sets the Posts table.</summary>
    public DbSet<Post> Posts => Set<Post>();

    /// <summary>Gets or sets the Images table.</summary>
    public DbSet<Image> Images => Set<Image>();

    /// <summary>Gets or sets the TelemetryLogs table.</summary>
    public DbSet<TelemetryLog> TelemetryLogs => Set<TelemetryLog>();

    /// <inheritdoc />
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // User configuration
        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Username).HasMaxLength(50).IsRequired();
            entity.HasIndex(e => e.Username).IsUnique();
            entity.Property(e => e.PasswordHash).HasMaxLength(256).IsRequired();
            entity.Property(e => e.Email).HasMaxLength(256).IsRequired();
            entity.Property(e => e.DisplayName).HasMaxLength(100).IsRequired();
        });

        // Post configuration
        modelBuilder.Entity<Post>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Title).HasMaxLength(200).IsRequired();
            entity.Property(e => e.Slug).HasMaxLength(200).IsRequired();
            entity.HasIndex(e => e.Slug).IsUnique();
            entity.Property(e => e.Summary).HasMaxLength(500).IsRequired();
            entity.HasOne(e => e.Author)
                .WithMany(u => u.Posts)
                .HasForeignKey(e => e.AuthorId)
                .OnDelete(DeleteBehavior.Restrict);
        });

        // Image configuration
        modelBuilder.Entity<Image>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.FileName).HasMaxLength(256).IsRequired();
            entity.Property(e => e.ContentType).HasMaxLength(100).IsRequired();
            entity.HasOne(e => e.Post)
                .WithMany(p => p.Images)
                .HasForeignKey(e => e.PostId)
                .OnDelete(DeleteBehavior.SetNull);
            entity.HasOne(e => e.UploadedBy)
                .WithMany(u => u.UploadedImages)
                .HasForeignKey(e => e.UploadedByUserId)
                .OnDelete(DeleteBehavior.Restrict);
        });

        // TelemetryLog configuration
        modelBuilder.Entity<TelemetryLog>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Id).ValueGeneratedOnAdd();
            entity.Property(e => e.Level).HasMaxLength(20).IsRequired();
            entity.Property(e => e.Category).HasMaxLength(256).IsRequired();
            entity.HasIndex(e => e.TimestampUtc);
        });
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Data/DatabasePathResolver.cs
SIZE: 1.90 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

namespace MyBlog.Infrastructure.Data;

/// <summary>
/// Resolves the database file path following XDG conventions.
/// </summary>
public static class DatabasePathResolver
{
    /// <summary>
    /// Gets the path for the SQLite database file.
    /// Priority: XDG_DATA_HOME > Platform-specific > Local fallback
    /// </summary>
    public static string GetDatabasePath()
    {
        var dataDir = GetDataDirectory();
        Directory.CreateDirectory(dataDir);
        return Path.Combine(dataDir, "myblog.db");
    }

    /// <summary>
    /// Gets the data directory following platform conventions.
    /// </summary>
    public static string GetDataDirectory()
    {
        string baseDir;

        if (OperatingSystem.IsWindows())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        }
        else if (OperatingSystem.IsMacOS())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        }
        else
        {
            // Linux/Unix: Use XDG_DATA_HOME or fallback
            var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
            baseDir = !string.IsNullOrEmpty(xdgDataHome)
                ? xdgDataHome
                : Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".local", "share");
        }

        // If we can't write to the preferred location, use local directory
        var preferredDir = Path.Combine(baseDir, "MyBlog");
        try
        {
            Directory.CreateDirectory(preferredDir);
            var testFile = Path.Combine(preferredDir, ".write-test");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return preferredDir;
        }
        catch
        {
            // Fallback to local directory
            return Path.Combine(AppContext.BaseDirectory, "data");
        }
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/MyBlog.Infrastructure.csproj
SIZE: .44 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>MyBlog.Infrastructure</RootNamespace>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" />
    <PackageReference Include="Microsoft.AspNetCore.Identity" />
    <PackageReference Include="OpenTelemetry" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\MyBlog.Core\MyBlog.Core.csproj" />
  </ItemGroup>
</Project>


================================================================================
FILE: src/MyBlog.Infrastructure/Repositories/ImageRepository.cs
SIZE: 1.61 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the image repository.
/// </summary>
public sealed class ImageRepository : IImageRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of ImageRepository.</summary>
    public ImageRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<Image>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _context.Images
            .AsNoTracking()
            .OrderByDescending(i => i.UploadedAtUtc)
            .ToListAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Image?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.Images.FindAsync([id], cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Image> CreateAsync(Image image, CancellationToken cancellationToken = default)
    {
        _context.Images.Add(image);
        await _context.SaveChangesAsync(cancellationToken);
        return image;
    }

    /// <inheritdoc />
    public async Task DeleteAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var image = await _context.Images.FindAsync([id], cancellationToken);
        if (image is not null)
        {
            _context.Images.Remove(image);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Repositories/PostRepository.cs
SIZE: 4.56 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the post repository.
/// </summary>
public sealed class PostRepository : IPostRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of PostRepository.</summary>
    public PostRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task<(IReadOnlyList<PostListItemDto> Posts, int TotalCount)> GetPublishedPostsAsync(
        int page, int pageSize, CancellationToken cancellationToken = default)
    {
        var query = _context.Posts
            .AsNoTracking()
            .Where(p => p.IsPublished)
            .OrderByDescending(p => p.PublishedAtUtc);

        var totalCount = await query.CountAsync(cancellationToken);

        var posts = await query
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .Include(p => p.Author)
            .Select(p => new PostListItemDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Summary,
                p.Author!.DisplayName,
                p.PublishedAtUtc,
                p.IsPublished))
            .ToListAsync(cancellationToken);

        return (posts, totalCount);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<PostListItemDto>> GetAllPostsAsync(
        CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .AsNoTracking()
            .OrderByDescending(p => p.UpdatedAtUtc)
            .Include(p => p.Author)
            .Select(p => new PostListItemDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Summary,
                p.Author!.DisplayName,
                p.PublishedAtUtc,
                p.IsPublished))
            .ToListAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<PostDetailDto?> GetBySlugAsync(
        string slug, CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .AsNoTracking()
            .Where(p => p.Slug == slug)
            .Include(p => p.Author)
            .Select(p => new PostDetailDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Content,
                p.Summary,
                p.Author!.DisplayName,
                p.CreatedAtUtc,
                p.UpdatedAtUtc,
                p.PublishedAtUtc,
                p.IsPublished))
            .FirstOrDefaultAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Post?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .Include(p => p.Author)
            .FirstOrDefaultAsync(p => p.Id == id, cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Post> CreateAsync(Post post, CancellationToken cancellationToken = default)
    {
        _context.Posts.Add(post);
        await _context.SaveChangesAsync(cancellationToken);
        return post;
    }

    /// <inheritdoc />
    public async Task UpdateAsync(Post post, CancellationToken cancellationToken = default)
    {
        _context.Posts.Update(post);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task DeleteAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var post = await _context.Posts.FindAsync([id], cancellationToken);
        if (post is not null)
        {
            _context.Posts.Remove(post);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }

    /// <inheritdoc />
    public async Task<int> GetCountAsync(CancellationToken cancellationToken = default)
    {
        return await _context.Posts.CountAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<PostListItemDto>> GetRecentPostsAsync(
        int count, CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .AsNoTracking()
            .OrderByDescending(p => p.UpdatedAtUtc)
            .Take(count)
            .Include(p => p.Author)
            .Select(p => new PostListItemDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Summary,
                p.Author!.DisplayName,
                p.PublishedAtUtc,
                p.IsPublished))
            .ToListAsync(cancellationToken);
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Repositories/TelemetryLogRepository.cs
SIZE: 1.43 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the telemetry log repository.
/// </summary>
public sealed class TelemetryLogRepository : ITelemetryLogRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of TelemetryLogRepository.</summary>
    public TelemetryLogRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task WriteAsync(TelemetryLog log, CancellationToken cancellationToken = default)
    {
        _context.TelemetryLogs.Add(log);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<int> DeleteOlderThanAsync(
        DateTime cutoffUtc, CancellationToken cancellationToken = default)
    {
        return await _context.TelemetryLogs
            .Where(l => l.TimestampUtc < cutoffUtc)
            .ExecuteDeleteAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<TelemetryLog>> GetRecentAsync(
        int count, CancellationToken cancellationToken = default)
    {
        return await _context.TelemetryLogs
            .AsNoTracking()
            .OrderByDescending(l => l.TimestampUtc)
            .Take(count)
            .ToListAsync(cancellationToken);
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Repositories/UserRepository.cs
SIZE: 1.57 KB
MODIFIED: 2025-12-28 10:33:37
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// SQLite implementation of the user repository.
/// </summary>
public sealed class UserRepository : IUserRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of UserRepository.</summary>
    public UserRepository(BlogDbContext context) => _context = context;

    /// <inheritdoc />
    public async Task<User?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
        => await _context.Users.FirstOrDefaultAsync(u => u.Id == id, cancellationToken);

    /// <inheritdoc />
    public async Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default)
        => await _context.Users.FirstOrDefaultAsync(
            u => u.Username.ToLower() == username.ToLower(), cancellationToken);

    /// <inheritdoc />
    public async Task<bool> AnyUsersExistAsync(CancellationToken cancellationToken = default)
        => await _context.Users.AnyAsync(cancellationToken);

    /// <inheritdoc />
    public async Task CreateAsync(User user, CancellationToken cancellationToken = default)
    {
        _context.Users.Add(user);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task UpdateAsync(User user, CancellationToken cancellationToken = default)
    {
        _context.Users.Update(user);
        await _context.SaveChangesAsync(cancellationToken);
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/ServiceCollectionExtensions.cs
SIZE: 1.85 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Services;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;

namespace MyBlog.Infrastructure;

/// <summary>
/// Extension methods for registering infrastructure services.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Adds infrastructure services to the DI container.
    /// </summary>
    public static IServiceCollection AddInfrastructure(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Database
        var connectionString = configuration.GetConnectionString("DefaultConnection");
        if (string.IsNullOrEmpty(connectionString) || connectionString == "Data Source=myblog.db")
        {
            // Use XDG-compliant path
            var dbPath = DatabasePathResolver.GetDatabasePath();
            connectionString = $"Data Source={dbPath}";
        }

        services.AddDbContext<BlogDbContext>(options =>
            options.UseSqlite(connectionString));

        // Repositories
        services.AddScoped<IPostRepository, PostRepository>();
        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IImageRepository, ImageRepository>();
        services.AddScoped<ITelemetryLogRepository, TelemetryLogRepository>();

        // Services
        services.AddSingleton<IPasswordService, PasswordService>();
        services.AddSingleton<ISlugService, SlugService>();
        services.AddSingleton<IMarkdownService, MarkdownService>();
        services.AddScoped<IAuthService, AuthService>();

        // Background services
        services.AddHostedService<TelemetryCleanupService>();

        return services;
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Services/AuthService.cs
SIZE: 3.21 KB
MODIFIED: 2025-12-28 10:33:37
================================================================================

using Microsoft.Extensions.Configuration;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Authentication service implementation.
/// </summary>
public sealed class AuthService : IAuthService
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordService _passwordService;
    private readonly IConfiguration _configuration;

    /// <summary>Initializes a new instance of AuthService.</summary>
    public AuthService(
        IUserRepository userRepository,
        IPasswordService passwordService,
        IConfiguration configuration)
    {
        _userRepository = userRepository;
        _passwordService = passwordService;
        _configuration = configuration;
    }

    /// <inheritdoc />
    public async Task<User?> AuthenticateAsync(
        string username, string password, CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByUsernameAsync(username, cancellationToken);
        if (user is null)
        {
            return null;
        }

        return _passwordService.VerifyPassword(user.PasswordHash, password) ? user : null;
    }

    /// <inheritdoc />
    public async Task EnsureAdminUserAsync(CancellationToken cancellationToken = default)
    {
        if (await _userRepository.AnyUsersExistAsync(cancellationToken))
        {
            return;
        }

        var defaultPassword = Environment.GetEnvironmentVariable("MYBLOG_ADMIN_PASSWORD")
            ?? _configuration["Authentication:DefaultAdminPassword"]
            ?? "ChangeMe123!";

        var admin = new User
        {
            Id = Guid.NewGuid(),
            Username = "admin",
            PasswordHash = _passwordService.HashPassword(defaultPassword),
            Email = "admin@localhost",
            DisplayName = "Administrator",
            CreatedAtUtc = DateTime.UtcNow
        };

        await _userRepository.CreateAsync(admin, cancellationToken);
    }

    /// <inheritdoc />
    public async Task<bool> ChangePasswordAsync(
        Guid userId,
        string currentPassword,
        string newPassword,
        CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
        if (user is null)
        {
            return false;
        }

        // Verify current password
        if (!_passwordService.VerifyPassword(user.PasswordHash, currentPassword))
        {
            return false;
        }

        // Update to new password
        user.PasswordHash = _passwordService.HashPassword(newPassword);
        await _userRepository.UpdateAsync(user, cancellationToken);

        return true;
    }

    /// <inheritdoc />
    public async Task ResetPasswordAsync(
        Guid userId,
        string newPassword,
        CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
        if (user is null)
        {
            throw new InvalidOperationException($"User with ID {userId} not found.");
        }

        user.PasswordHash = _passwordService.HashPassword(newPassword);
        await _userRepository.UpdateAsync(user, cancellationToken);
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Services/PasswordService.cs
SIZE: .82 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using Microsoft.AspNetCore.Identity;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Password hashing service using ASP.NET Core Identity's PasswordHasher.
/// </summary>
public sealed class PasswordService : IPasswordService
{
    private readonly PasswordHasher<User> _hasher = new();

    /// <inheritdoc />
    public string HashPassword(string password)
    {
        return _hasher.HashPassword(null!, password);
    }

    /// <inheritdoc />
    public bool VerifyPassword(string hashedPassword, string providedPassword)
    {
        var result = _hasher.VerifyHashedPassword(null!, hashedPassword, providedPassword);
        return result == PasswordVerificationResult.Success ||
               result == PasswordVerificationResult.SuccessRehashNeeded;
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Services/TelemetryCleanupService.cs
SIZE: 2.11 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using MyBlog.Core.Interfaces;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Background service that cleans up old telemetry logs.
/// </summary>
public sealed class TelemetryCleanupService : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<TelemetryCleanupService> _logger;
    private readonly int _retentionDays;

    /// <summary>Initializes a new instance of TelemetryCleanupService.</summary>
    public TelemetryCleanupService(
        IServiceScopeFactory scopeFactory,
        IConfiguration configuration,
        ILogger<TelemetryCleanupService> logger)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
        _retentionDays = configuration.GetValue("Telemetry:RetentionDays", 30);
    }

    /// <inheritdoc />
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Run cleanup immediately on startup
        await CleanupAsync(stoppingToken);

        // Then run daily
        using var timer = new PeriodicTimer(TimeSpan.FromDays(1));
        while (await timer.WaitForNextTickAsync(stoppingToken))
        {
            await CleanupAsync(stoppingToken);
        }
    }

    private async Task CleanupAsync(CancellationToken cancellationToken)
    {
        try
        {
            using var scope = _scopeFactory.CreateScope();
            var repository = scope.ServiceProvider.GetRequiredService<ITelemetryLogRepository>();

            var cutoff = DateTime.UtcNow.AddDays(-_retentionDays);
            var deleted = await repository.DeleteOlderThanAsync(cutoff, cancellationToken);

            if (deleted > 0)
            {
                _logger.LogInformation(
                    "Telemetry cleanup: deleted {Count} logs older than {Days} days",
                    deleted, _retentionDays);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during telemetry cleanup");
        }
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Telemetry/DatabaseLogExporter.cs
SIZE: 2.11 KB
MODIFIED: 2025-12-28 07:55:11
================================================================================

using System.Text.Json;
using Microsoft.Extensions.DependencyInjection;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyBlog.Infrastructure.Telemetry;

/// <summary>
/// OpenTelemetry log exporter that writes to SQLite database.
/// </summary>
public sealed class DatabaseLogExporter : BaseExporter<LogRecord>
{
    private readonly IServiceScopeFactory _scopeFactory;

    /// <summary>Initializes a new instance of DatabaseLogExporter.</summary>
    public DatabaseLogExporter(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }

    /// <inheritdoc />
    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        try
        {
            using var scope = _scopeFactory.CreateScope();
            var context = scope.ServiceProvider.GetRequiredService<BlogDbContext>();

            foreach (var record in batch)
            {
                var log = new TelemetryLog
                {
                    TimestampUtc = record.Timestamp.ToUniversalTime(),
                    Level = record.LogLevel.ToString(),
                    Category = record.CategoryName ?? "Unknown",
                    Message = record.FormattedMessage ?? record.Body ?? "",
                    Exception = record.Exception?.ToString(),
                    TraceId = record.TraceId.ToString(),
                    SpanId = record.SpanId.ToString(),
                    Properties = SerializeAttributes(record)
                };

                context.TelemetryLogs.Add(log);
            }

            context.SaveChanges();
            return ExportResult.Success;
        }
        catch
        {
            return ExportResult.Failure;
        }
    }

    private static string? SerializeAttributes(LogRecord record)
    {
        if (record.Attributes is null)
        {
            return null;
        }

        var dict = new Dictionary<string, object?>();
        foreach (var attr in record.Attributes)
        {
            dict[attr.Key] = attr.Value;
        }

        return dict.Count > 0 ? JsonSerializer.Serialize(dict) : null;
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Telemetry/FileLogExporter.cs
SIZE: 3.61 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using System.Text;
using System.Text.Json;
using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyBlog.Infrastructure.Telemetry;

/// <summary>
/// OpenTelemetry log exporter that writes to JSON files.
/// </summary>
public sealed class FileLogExporter : BaseExporter<LogRecord>
{
    private readonly string _directory;
    private readonly string _runId;
    private readonly long _maxFileSizeBytes;
    private readonly object _lock = new();
    private StreamWriter? _writer;
    private long _currentFileSize;
    private int _fileNumber;
    private bool _isFirstRecord = true;
    private readonly JsonSerializerOptions _jsonOptions = new() { WriteIndented = true };

    /// <summary>Initializes a new instance of FileLogExporter.</summary>
    public FileLogExporter(string directory, long maxFileSizeBytes = 25 * 1024 * 1024)
    {
        _directory = directory;
        _maxFileSizeBytes = maxFileSizeBytes;
        _runId = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
        Directory.CreateDirectory(_directory);
    }

    /// <inheritdoc />
    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        try
        {
            lock (_lock)
            {
                EnsureWriter();

                foreach (var record in batch)
                {
                    var obj = new
                    {
                        Timestamp = record.Timestamp.ToString("O"),
                        Level = record.LogLevel.ToString(),
                        Category = record.CategoryName,
                        Message = record.FormattedMessage ?? record.Body,
                        TraceId = record.TraceId.ToString(),
                        SpanId = record.SpanId.ToString(),
                        Exception = record.Exception?.ToString()
                    };

                    var json = JsonSerializer.Serialize(obj, _jsonOptions);
                    var bytes = Encoding.UTF8.GetByteCount(json) + 2;

                    if (_currentFileSize + bytes > _maxFileSizeBytes)
                    {
                        RotateFile();
                    }

                    if (!_isFirstRecord)
                    {
                        _writer!.WriteLine(",");
                    }
                    else
                    {
                        _isFirstRecord = false;
                    }

                    _writer!.Write(json);
                    _currentFileSize += bytes;
                }

                _writer!.Flush();
            }

            return ExportResult.Success;
        }
        catch
        {
            return ExportResult.Failure;
        }
    }

    private void EnsureWriter()
    {
        if (_writer is null)
        {
            OpenNewFile();
        }
    }

    private void OpenNewFile()
    {
        var fileName = _fileNumber == 0
            ? $"logs_{_runId}.json"
            : $"logs_{_runId}_{_fileNumber:D3}.json";

        _writer = new StreamWriter(Path.Combine(_directory, fileName), false, Encoding.UTF8);
        _writer.WriteLine("[");
        _currentFileSize = 2;
        _isFirstRecord = true;
    }

    private void RotateFile()
    {
        CloseWriter();
        _fileNumber++;
        OpenNewFile();
    }

    private void CloseWriter()
    {
        if (_writer is not null)
        {
            _writer.WriteLine();
            _writer.WriteLine("]");
            _writer.Flush();
            _writer.Dispose();
            _writer = null;
        }
    }

    /// <inheritdoc />
    protected override bool OnShutdown(int timeoutMilliseconds)
    {
        lock (_lock)
        {
            CloseWriter();
        }
        return true;
    }
}


================================================================================
FILE: src/MyBlog.Infrastructure/Telemetry/TelemetryPathResolver.cs
SIZE: 2.00 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

namespace MyBlog.Infrastructure.Telemetry;

/// <summary>
/// Resolves the telemetry directory path following XDG conventions.
/// </summary>
public static class TelemetryPathResolver
{
    /// <summary>
    /// Attempts to get a writable telemetry directory.
    /// Returns null if no writable directory can be found.
    /// </summary>
    public static string? GetTelemetryDirectory()
    {
        // Try XDG/platform-specific location first
        var preferredDir = GetPreferredDirectory();
        if (TryCreateAndVerify(preferredDir))
        {
            return preferredDir;
        }

        // Fallback to local directory
        var localDir = Path.Combine(AppContext.BaseDirectory, "telemetry");
        if (TryCreateAndVerify(localDir))
        {
            return localDir;
        }

        // No writable directory available
        return null;
    }

    private static string GetPreferredDirectory()
    {
        string baseDir;

        if (OperatingSystem.IsWindows())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        }
        else if (OperatingSystem.IsMacOS())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        }
        else
        {
            var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
            baseDir = !string.IsNullOrEmpty(xdgDataHome)
                ? xdgDataHome
                : Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".local", "share");
        }

        return Path.Combine(baseDir, "MyBlog", "telemetry");
    }

    private static bool TryCreateAndVerify(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid()}");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return true;
        }
        catch
        {
            return false;
        }
    }
}


================================================================================
FILE: src/MyBlog.slnx
SIZE: .24 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

<Solution>
  <Project Path="MyBlog.Core/MyBlog.Core.csproj" />
  <Project Path="MyBlog.Infrastructure/MyBlog.Infrastructure.csproj" />
  <Project Path="MyBlog.Web/MyBlog.Web.csproj" />
  <Project Path="MyBlog.Tests/MyBlog.Tests.csproj" />
</Solution>


================================================================================
FILE: src/MyBlog.Tests/Integration/AuthServiceLongPasswordTests.cs
SIZE: 11.12 KB
MODIFIED: 2025-12-28 11:13:41
================================================================================

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Integration;

/// <summary>
/// Tests for long password support and account lockout behavior.
/// Uses in-memory SQLite for cross-platform compatibility (Windows/Linux/macOS).
/// </summary>
public sealed class AuthServiceLongPasswordTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly AuthService _sut;
    private readonly PasswordService _passwordService;

    public AuthServiceLongPasswordTests()
    {
        // Use in-memory SQLite - works on all platforms without file locking issues
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _passwordService = new PasswordService();
        var userRepository = new UserRepository(_context);
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Authentication:DefaultAdminPassword"] = "TestAdmin123!"
            })
            .Build();

        _sut = new AuthService(userRepository, _passwordService, configuration);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    // =========================================================================
    // Long Password Tests (128+ characters)
    // =========================================================================

    [Fact]
    public async Task AuthenticateAsync_With128CharacterPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var longPassword = new string('a', 128);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "longpassuser",
            PasswordHash = _passwordService.HashPassword(longPassword),
            Email = "longpass@example.com",
            DisplayName = "Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("longpassuser", longPassword, ct);

        Assert.NotNull(result);
        Assert.Equal("longpassuser", result.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_With256CharacterPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var longPassword = new string('x', 256);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "verylongpassuser",
            PasswordHash = _passwordService.HashPassword(longPassword),
            Email = "verylong@example.com",
            DisplayName = "Very Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("verylongpassuser", longPassword, ct);

        Assert.NotNull(result);
        Assert.Equal("verylongpassuser", result.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_With512CharacterPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var longPassword = new string('P', 512);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "extralongpassuser",
            PasswordHash = _passwordService.HashPassword(longPassword),
            Email = "extralong@example.com",
            DisplayName = "Extra Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("extralongpassuser", longPassword, ct);

        Assert.NotNull(result);
        Assert.Equal("extralongpassuser", result.Username);
    }

    [Fact]
    public async Task ChangePasswordAsync_With128CharacterNewPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "ShortPass123!";
        var newLongPassword = new string('N', 128);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "changepasslonguser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "changelong@example.com",
            DisplayName = "Change Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.ChangePasswordAsync(user.Id, originalPassword, newLongPassword, ct);

        Assert.True(result);

        // Verify new password works
        var authenticated = await _sut.AuthenticateAsync("changepasslonguser", newLongPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task AuthenticateAsync_WithComplexLongPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        // Mix of characters, 200 chars long
        var complexPassword = string.Concat(
            new string('A', 50),
            new string('1', 50),
            new string('!', 50),
            new string('z', 50)
        );

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "complexpassuser",
            PasswordHash = _passwordService.HashPassword(complexPassword),
            Email = "complex@example.com",
            DisplayName = "Complex Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("complexpassuser", complexPassword, ct);

        Assert.NotNull(result);
    }

    // =========================================================================
    // No Account Lockout Tests
    // =========================================================================

    [Fact]
    public async Task AuthenticateAsync_After100FailedAttempts_StillAllowsLogin()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPassword123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "nolockoutuser",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "nolockout@example.com",
            DisplayName = "No Lockout User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Attempt 100 failed logins
        for (var i = 0; i < 100; i++)
        {
            var failedResult = await _sut.AuthenticateAsync("nolockoutuser", "WrongPassword", ct);
            Assert.Null(failedResult);
        }

        // User should still be able to log in with correct password
        var successResult = await _sut.AuthenticateAsync("nolockoutuser", correctPassword, ct);
        Assert.NotNull(successResult);
        Assert.Equal("nolockoutuser", successResult.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_After1000FailedAttempts_StillAllowsLogin()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPassword123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "nolockout1000user",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "nolockout1000@example.com",
            DisplayName = "No Lockout 1000 User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Attempt 1000 failed logins
        for (var i = 0; i < 1000; i++)
        {
            var failedResult = await _sut.AuthenticateAsync("nolockout1000user", $"WrongPassword{i}", ct);
            Assert.Null(failedResult);
        }

        // User should still be able to log in with correct password
        var successResult = await _sut.AuthenticateAsync("nolockout1000user", correctPassword, ct);
        Assert.NotNull(successResult);
        Assert.Equal("nolockout1000user", successResult.Username);
    }

    [Fact]
    public async Task ChangePasswordAsync_AfterManyFailedAttempts_StillWorks()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "NewPassword456!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "changepassnolockout",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "changepassnolockout@example.com",
            DisplayName = "Change Password No Lockout",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Attempt 50 failed password changes
        for (var i = 0; i < 50; i++)
        {
            var failedResult = await _sut.ChangePasswordAsync(user.Id, "WrongOldPassword", "NewPass", ct);
            Assert.False(failedResult);
        }

        // Should still be able to change password with correct current password
        var successResult = await _sut.ChangePasswordAsync(user.Id, originalPassword, newPassword, ct);
        Assert.True(successResult);

        // Verify new password works
        var authenticated = await _sut.AuthenticateAsync("changepassnolockout", newPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task AuthenticateAsync_InterleavedFailuresAndSuccesses_NeverLocks()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPassword123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "interleaveduser",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "interleaved@example.com",
            DisplayName = "Interleaved User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Interleave failed and successful attempts
        for (var i = 0; i < 20; i++)
        {
            // 5 failed attempts
            for (var j = 0; j < 5; j++)
            {
                var failedResult = await _sut.AuthenticateAsync("interleaveduser", "WrongPassword", ct);
                Assert.Null(failedResult);
            }

            // 1 successful attempt
            var successResult = await _sut.AuthenticateAsync("interleaveduser", correctPassword, ct);
            Assert.NotNull(successResult);
        }

        // Final successful login after 100 failed attempts total
        var finalResult = await _sut.AuthenticateAsync("interleaveduser", correctPassword, ct);
        Assert.NotNull(finalResult);
        Assert.Equal("interleaveduser", finalResult.Username);
    }
}


================================================================================
FILE: src/MyBlog.Tests/Integration/AuthServiceTests.cs
SIZE: 3.85 KB
MODIFIED: 2025-12-28 08:39:37
================================================================================

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Integration;

public class AuthServiceTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly AuthService _sut;
    private readonly PasswordService _passwordService = new();

    public AuthServiceTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        var userRepository = new UserRepository(_context);
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Authentication:DefaultAdminPassword"] = "TestAdmin123!"
            })
            .Build();

        _sut = new AuthService(userRepository, _passwordService, configuration);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task AuthenticateAsync_WithValidCredentials_ReturnsUser()
    {
        var ct = TestContext.Current.CancellationToken;
        var password = "TestPassword123";
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(password),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("testuser", password, ct);

        Assert.NotNull(result);
        Assert.Equal("testuser", result.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_WithInvalidPassword_ReturnsNull()
    {
        var ct = TestContext.Current.CancellationToken;
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword("CorrectPassword"),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("testuser", "WrongPassword", ct);

        Assert.Null(result);
    }

    [Fact]
    public async Task AuthenticateAsync_WithNonExistentUser_ReturnsNull()
    {
        var ct = TestContext.Current.CancellationToken;
        var result = await _sut.AuthenticateAsync("nonexistent", "password", ct);
        Assert.Null(result);
    }

    [Fact]
    public async Task EnsureAdminUserAsync_WhenNoUsersExist_CreatesAdmin()
    {
        var ct = TestContext.Current.CancellationToken;
        await _sut.EnsureAdminUserAsync(ct);

        var admin = await _context.Users.FirstOrDefaultAsync(u => u.Username == "admin", ct);
        Assert.NotNull(admin);
    }

    [Fact]
    public async Task EnsureAdminUserAsync_WhenUsersExist_DoesNotCreateAnother()
    {
        var ct = TestContext.Current.CancellationToken;
        var existingUser = new User
        {
            Id = Guid.NewGuid(),
            Username = "existing",
            PasswordHash = "hash",
            Email = "existing@example.com",
            DisplayName = "Existing",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(existingUser);
        await _context.SaveChangesAsync(ct);

        await _sut.EnsureAdminUserAsync(ct);

        var userCount = await _context.Users.CountAsync(ct);
        Assert.Equal(1, userCount);
    }
}


================================================================================
FILE: src/MyBlog.Tests/Integration/PasswordChangeTests.cs
SIZE: 6.10 KB
MODIFIED: 2025-12-28 10:34:32
================================================================================

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Integration;

public class PasswordChangeTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly AuthService _sut;
    private readonly PasswordService _passwordService = new();
    private readonly UserRepository _userRepository;

    public PasswordChangeTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _userRepository = new UserRepository(_context);
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Authentication:DefaultAdminPassword"] = "TestAdmin123!"
            })
            .Build();

        _sut = new AuthService(_userRepository, _passwordService, configuration);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task ChangePasswordAsync_WithCorrectCurrentPassword_ReturnsTrue()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "NewPassword456!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.ChangePasswordAsync(user.Id, originalPassword, newPassword, ct);

        Assert.True(result);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithCorrectPassword_AllowsLoginWithNewPassword()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "NewPassword456!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        await _sut.ChangePasswordAsync(user.Id, originalPassword, newPassword, ct);

        // Should authenticate with new password
        var authenticated = await _sut.AuthenticateAsync("testuser", newPassword, ct);
        Assert.NotNull(authenticated);

        // Should NOT authenticate with old password
        var oldAuth = await _sut.AuthenticateAsync("testuser", originalPassword, ct);
        Assert.Null(oldAuth);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithWrongCurrentPassword_ReturnsFalse()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPass123!";
        var wrongPassword = "WrongPassword!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.ChangePasswordAsync(user.Id, wrongPassword, "NewPass123!", ct);

        Assert.False(result);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithWrongPassword_DoesNotChangePassword()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPass123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        await _sut.ChangePasswordAsync(user.Id, "WrongPassword!", "NewPass123!", ct);

        // Original password should still work
        var authenticated = await _sut.AuthenticateAsync("testuser", correctPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithNonExistentUser_ReturnsFalse()
    {
        var ct = TestContext.Current.CancellationToken;
        var result = await _sut.ChangePasswordAsync(Guid.NewGuid(), "any", "password", ct);
        Assert.False(result);
    }

    [Fact]
    public async Task ResetPasswordAsync_SetsNewPassword()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "ResetPassword789!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        await _sut.ResetPasswordAsync(user.Id, newPassword, ct);

        var authenticated = await _sut.AuthenticateAsync("testuser", newPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task ResetPasswordAsync_WithNonExistentUser_ThrowsException()
    {
        var ct = TestContext.Current.CancellationToken;
        await Assert.ThrowsAsync<InvalidOperationException>(
            () => _sut.ResetPasswordAsync(Guid.NewGuid(), "password", ct));
    }
}


================================================================================
FILE: src/MyBlog.Tests/Integration/PostRepositoryTests.cs
SIZE: 4.88 KB
MODIFIED: 2025-12-28 08:39:37
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using Xunit;

namespace MyBlog.Tests.Integration;

public class PostRepositoryTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly PostRepository _sut;
    private readonly User _testUser;

    public PostRepositoryTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _testUser = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = "hash",
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(_testUser);
        _context.SaveChanges();

        _sut = new PostRepository(_context);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task CreateAsync_AddsPostToDatabase()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("Test Post");

        var result = await _sut.CreateAsync(post, ct);

        Assert.NotEqual(Guid.Empty, result.Id);
        var saved = await _context.Posts.FindAsync([result.Id], ct);
        Assert.NotNull(saved);
        Assert.Equal("Test Post", saved.Title);
    }

    [Fact]
    public async Task GetByIdAsync_WithExistingId_ReturnsPost()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("Test Post");
        await _sut.CreateAsync(post, ct);

        var result = await _sut.GetByIdAsync(post.Id, ct);

        Assert.NotNull(result);
        Assert.Equal("Test Post", result.Title);
    }

    [Fact]
    public async Task GetByIdAsync_WithNonExistingId_ReturnsNull()
    {
        var ct = TestContext.Current.CancellationToken;
        var result = await _sut.GetByIdAsync(Guid.NewGuid(), ct);
        Assert.Null(result);
    }

    [Fact]
    public async Task GetBySlugAsync_WithExistingSlug_ReturnsPost()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("Test Post", "test-post");
        await _sut.CreateAsync(post, ct);

        var result = await _sut.GetBySlugAsync("test-post", ct);

        Assert.NotNull(result);
        Assert.Equal("Test Post", result.Title);
    }

    [Fact]
    public async Task GetPublishedPostsAsync_ReturnsOnlyPublishedPosts()
    {
        var ct = TestContext.Current.CancellationToken;
        await _sut.CreateAsync(CreateTestPost("Published", isPublished: true), ct);
        await _sut.CreateAsync(CreateTestPost("Draft", isPublished: false), ct);

        var (posts, totalCount) = await _sut.GetPublishedPostsAsync(1, 10, ct);

        Assert.Single(posts);
        Assert.Equal("Published", posts.First().Title);
        Assert.Equal(1, totalCount);
    }

    [Fact]
    public async Task UpdateAsync_ModifiesPost()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("Original Title");
        await _sut.CreateAsync(post, ct);

        post.Title = "Updated Title";
        await _sut.UpdateAsync(post, ct);

        var result = await _sut.GetByIdAsync(post.Id, ct);
        Assert.Equal("Updated Title", result!.Title);
    }

    [Fact]
    public async Task DeleteAsync_RemovesPost()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("To Delete");
        await _sut.CreateAsync(post, ct);

        await _sut.DeleteAsync(post.Id, ct);

        var result = await _sut.GetByIdAsync(post.Id, ct);
        Assert.Null(result);
    }

    [Fact]
    public async Task GetPublishedPostsAsync_ReturnsCorrectCount()
    {
        var ct = TestContext.Current.CancellationToken;
        await _sut.CreateAsync(CreateTestPost("Post 1", isPublished: true), ct);
        await _sut.CreateAsync(CreateTestPost("Post 2", isPublished: true), ct);
        await _sut.CreateAsync(CreateTestPost("Draft", isPublished: false), ct);

        var (_, totalCount) = await _sut.GetPublishedPostsAsync(1, 10, ct);

        Assert.Equal(2, totalCount);
    }

    private Post CreateTestPost(string title, string? slug = null, bool isPublished = true)
    {
        return new Post
        {
            Id = Guid.NewGuid(),
            Title = title,
            Slug = slug ?? title.ToLower().Replace(" ", "-"),
            Content = "Test content",
            Summary = "Test summary",
            AuthorId = _testUser.Id,
            CreatedAtUtc = DateTime.UtcNow,
            UpdatedAtUtc = DateTime.UtcNow,
            IsPublished = isPublished,
            PublishedAtUtc = isPublished ? DateTime.UtcNow : null
        };
    }
}


================================================================================
FILE: src/MyBlog.Tests/Integration/TelemetryCleanupTests.cs
SIZE: 2.68 KB
MODIFIED: 2025-12-28 08:27:55
================================================================================

using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using Xunit;

namespace MyBlog.Tests.Integration;

public class TelemetryCleanupTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly TelemetryLogRepository _sut;

    public TelemetryCleanupTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _sut = new TelemetryLogRepository(_context);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task DeleteOlderThanAsync_RemovesOldLogs()
    {
        var ct = TestContext.Current.CancellationToken;

        // Add old logs
        var oldLog = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow.AddDays(-60),
            Level = "Information",
            Category = "Test",
            Message = "Old log"
        };
        _context.TelemetryLogs.Add(oldLog);

        // Add recent log
        var recentLog = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow.AddDays(-5),
            Level = "Information",
            Category = "Test",
            Message = "Recent log"
        };
        _context.TelemetryLogs.Add(recentLog);
        await _context.SaveChangesAsync(ct);

        var cutoff = DateTime.UtcNow.AddDays(-30);
        var deleted = await _sut.DeleteOlderThanAsync(cutoff, ct);

        Assert.Equal(1, deleted);
        var remaining = await _context.TelemetryLogs.CountAsync(ct);
        Assert.Equal(1, remaining);
    }

    [Fact]
    public async Task DeleteOlderThanAsync_WithNoOldLogs_ReturnsZero()
    {
        var ct = TestContext.Current.CancellationToken;

        var recentLog = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow.AddDays(-5),
            Level = "Information",
            Category = "Test",
            Message = "Recent log"
        };
        _context.TelemetryLogs.Add(recentLog);
        await _context.SaveChangesAsync(ct);

        var cutoff = DateTime.UtcNow.AddDays(-30);
        var deleted = await _sut.DeleteOlderThanAsync(cutoff, ct);

        Assert.Equal(0, deleted);
    }

    [Fact]
    public async Task DeleteOlderThanAsync_WithEmptyTable_ReturnsZero()
    {
        var ct = TestContext.Current.CancellationToken;
        var cutoff = DateTime.UtcNow.AddDays(-30);
        var deleted = await _sut.DeleteOlderThanAsync(cutoff, ct);
        Assert.Equal(0, deleted);
    }
}


================================================================================
FILE: src/MyBlog.Tests/MyBlog.Tests.csproj
SIZE: .67 KB
MODIFIED: 2025-12-28 11:17:07
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>MyBlog.Tests</RootNamespace>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="xunit.v3" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
  <PackageReference Include="xunit.runner.visualstudio" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\MyBlog.Core\MyBlog.Core.csproj" />
    <ProjectReference Include="..\MyBlog.Web\MyBlog.Web.csproj" />
    <ProjectReference Include="..\MyBlog.Infrastructure\MyBlog.Infrastructure.csproj" />
  </ItemGroup>
</Project>


================================================================================
FILE: src/MyBlog.Tests/Unit/LoginRateLimitMiddlewareTests.cs
SIZE: 6.75 KB
MODIFIED: 2025-12-28 12:44:14
================================================================================

using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging.Abstractions;
using MyBlog.Web.Middleware;
using Xunit;

namespace MyBlog.Tests.Unit;

/// <summary>
/// Tests for LoginRateLimitMiddleware.
/// Verifies that the middleware slows down but never blocks requests.
/// </summary>
public sealed class LoginRateLimitMiddlewareTests : IDisposable
{
    private readonly LoginRateLimitMiddleware _sut;
    private int _nextCallCount;
    private readonly List<TimeSpan> _recordedDelays = [];

    public LoginRateLimitMiddlewareTests()
    {
        // Clear any state from previous tests
        LoginRateLimitMiddleware.ClearAttempts();

        _nextCallCount = 0;
        RequestDelegate next = _ =>
        {
            _nextCallCount++;
            return Task.CompletedTask;
        };

        // Use a no-op delay function that just records the delay
        // This makes tests fast while still verifying delay logic
        Task NoOpDelay(TimeSpan delay, CancellationToken ct)
        {
            _recordedDelays.Add(delay);
            return Task.CompletedTask;
        }

        _sut = new LoginRateLimitMiddleware(
            next,
            NullLogger<LoginRateLimitMiddleware>.Instance,
            NoOpDelay);
    }

    public void Dispose()
    {
        // Clean up after each test
        LoginRateLimitMiddleware.ClearAttempts();
    }

    [Fact]
    public async Task InvokeAsync_NonLoginRequest_PassesThroughImmediately()
    {
        var context = CreateHttpContext("/api/posts", "GET");

        await _sut.InvokeAsync(context);

        Assert.Equal(1, _nextCallCount);
        Assert.Empty(_recordedDelays);
    }

    [Fact]
    public async Task InvokeAsync_GetLoginRequest_PassesThroughImmediately()
    {
        var context = CreateHttpContext("/login", "GET");

        await _sut.InvokeAsync(context);

        Assert.Equal(1, _nextCallCount);
        Assert.Empty(_recordedDelays);
    }

    [Fact]
    public async Task InvokeAsync_FirstFiveAttempts_NoDelay()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // First 5 attempts should have no delay
        for (var i = 0; i < 5; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(5, _nextCallCount);
        Assert.Empty(_recordedDelays); // No delays for first 5 attempts
    }

    [Fact]
    public async Task InvokeAsync_SixthAttempt_HasOneSecondDelay()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make 6 attempts
        for (var i = 0; i < 6; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(6, _nextCallCount);
        Assert.Single(_recordedDelays);
        Assert.Equal(TimeSpan.FromSeconds(1), _recordedDelays[0]);
    }

    [Fact]
    public async Task InvokeAsync_ProgressiveDelays_IncreaseExponentially()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make 10 attempts: 5 no-delay + 5 with delays
        for (var i = 0; i < 10; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(10, _nextCallCount);
        Assert.Equal(5, _recordedDelays.Count); // Delays start after attempt 5

        // Verify exponential progression: 1s, 2s, 4s, 8s, 16s
        Assert.Equal(TimeSpan.FromSeconds(1), _recordedDelays[0]);
        Assert.Equal(TimeSpan.FromSeconds(2), _recordedDelays[1]);
        Assert.Equal(TimeSpan.FromSeconds(4), _recordedDelays[2]);
        Assert.Equal(TimeSpan.FromSeconds(8), _recordedDelays[3]);
        Assert.Equal(TimeSpan.FromSeconds(16), _recordedDelays[4]);
    }

    [Fact]
    public async Task InvokeAsync_DelayCappedAt30Seconds()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make enough attempts to hit the cap (5 no-delay + enough to exceed 30s)
        // After attempt 5: 1, 2, 4, 8, 16, 30, 30, 30...
        for (var i = 0; i < 15; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(15, _nextCallCount);

        // Verify cap at 30 seconds (attempts 11+ should all be 30s)
        var maxDelays = _recordedDelays.Where(d => d == TimeSpan.FromSeconds(30)).ToList();
        Assert.True(maxDelays.Count >= 4, "Should have multiple 30-second delays");
        Assert.True(_recordedDelays.All(d => d <= TimeSpan.FromSeconds(30)), "No delay should exceed 30 seconds");
    }

    [Fact]
    public async Task InvokeAsync_AfterManyAttempts_NeverBlocks()
    {
        var uniqueIp = $"10.0.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make 100 attempts - should all pass through (with delays, but never blocked)
        for (var i = 0; i < 100; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        // Key assertion: ALL requests passed through, none were blocked
        Assert.Equal(100, _nextCallCount);
    }

    [Fact]
    public async Task InvokeAsync_DifferentIPs_IndependentTracking()
    {
        var ip1 = $"10.1.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";
        var ip2 = $"10.2.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // 6 attempts from IP1 (should trigger delay on 6th)
        for (var i = 0; i < 6; i++)
        {
            var context = CreateHttpContext("/login", "POST", ip1);
            await _sut.InvokeAsync(context);
        }

        var ip1Delays = _recordedDelays.Count;
        Assert.Equal(1, ip1Delays); // One delay after 5th attempt

        // First attempt from IP2 should have no delay
        var context2 = CreateHttpContext("/login", "POST", ip2);
        await _sut.InvokeAsync(context2);

        // No new delays should have been added for IP2
        Assert.Equal(ip1Delays, _recordedDelays.Count);
    }

    [Fact]
    public void CalculateDelay_UnknownIP_ReturnsZero()
    {
        var delay = LoginRateLimitMiddleware.CalculateDelay("unknown-ip-never-seen");
        Assert.Equal(TimeSpan.Zero, delay);
    }

    private static DefaultHttpContext CreateHttpContext(string path, string method, string? remoteIp = null)
    {
        var context = new DefaultHttpContext();
        context.Request.Path = path;
        context.Request.Method = method;

        if (remoteIp != null)
        {
            context.Connection.RemoteIpAddress = System.Net.IPAddress.Parse(remoteIp);
        }

        return context;
    }
}


================================================================================
FILE: src/MyBlog.Tests/Unit/MarkdownServiceTests.cs
SIZE: 3.30 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using MyBlog.Core.Services;
using Xunit;

namespace MyBlog.Tests.Unit;

public class MarkdownServiceTests
{
    private readonly MarkdownService _sut = new();

    [Fact]
    public void ToHtml_WithHeading1_ReturnsH1Tag()
    {
        var result = _sut.ToHtml("# Hello");
        Assert.Contains("<h1>Hello</h1>", result);
    }

    [Fact]
    public void ToHtml_WithHeading2_ReturnsH2Tag()
    {
        var result = _sut.ToHtml("## Hello");
        Assert.Contains("<h2>Hello</h2>", result);
    }

    [Fact]
    public void ToHtml_WithHeading6_ReturnsH6Tag()
    {
        var result = _sut.ToHtml("###### Hello");
        Assert.Contains("<h6>Hello</h6>", result);
    }

    [Fact]
    public void ToHtml_WithBoldText_ReturnsStrongTag()
    {
        var result = _sut.ToHtml("This is **bold** text");
        Assert.Contains("<strong>bold</strong>", result);
    }

    [Fact]
    public void ToHtml_WithItalicText_ReturnsEmTag()
    {
        var result = _sut.ToHtml("This is *italic* text");
        Assert.Contains("<em>italic</em>", result);
    }

    [Fact]
    public void ToHtml_WithLink_ReturnsAnchorTag()
    {
        var result = _sut.ToHtml("Check [this link](https://example.com)");
        Assert.Contains("<a href=\"https://example.com\">this link</a>", result);
    }

    [Fact]
    public void ToHtml_WithImage_ReturnsImgTag()
    {
        var result = _sut.ToHtml("![alt text](https://example.com/image.png)");
        Assert.Contains("<img src=\"https://example.com/image.png\" alt=\"alt text\" />", result);
    }

    [Fact]
    public void ToHtml_WithInlineCode_ReturnsCodeTag()
    {
        var result = _sut.ToHtml("Use `code` here");
        Assert.Contains("<code>code</code>", result);
    }

    [Fact]
    public void ToHtml_WithCodeBlock_ReturnsPreCodeTags()
    {
        var markdown = "```\nvar x = 1;\n```";
        var result = _sut.ToHtml(markdown);
        Assert.Contains("<pre><code>", result);
        Assert.Contains("var x = 1;", result);
        Assert.Contains("</code></pre>", result);
    }

    [Fact]
    public void ToHtml_WithBlockquote_ReturnsBlockquoteTag()
    {
        var result = _sut.ToHtml("> This is a quote");
        Assert.Contains("<blockquote><p>This is a quote</p></blockquote>", result);
    }

    [Fact]
    public void ToHtml_WithUnorderedList_ReturnsUlLiTags()
    {
        var markdown = "- Item 1\n- Item 2";
        var result = _sut.ToHtml(markdown);
        Assert.Contains("<ul>", result);
        Assert.Contains("<li>Item 1</li>", result);
        Assert.Contains("<li>Item 2</li>", result);
        Assert.Contains("</ul>", result);
    }

    [Fact]
    public void ToHtml_WithHorizontalRule_ReturnsHrTag()
    {
        var result = _sut.ToHtml("---");
        Assert.Contains("<hr />", result);
    }

    [Fact]
    public void ToHtml_WithEmptyString_ReturnsEmptyString()
    {
        var result = _sut.ToHtml("");
        Assert.Equal(string.Empty, result);
    }

    [Fact]
    public void ToHtml_WithPlainText_ReturnsParagraph()
    {
        var result = _sut.ToHtml("Hello world");
        Assert.Contains("<p>Hello world</p>", result);
    }

    [Fact]
    public void ToHtml_WithHtmlCharacters_EscapesThem()
    {
        var result = _sut.ToHtml("Use <script> tags");
        Assert.Contains("&lt;script&gt;", result);
        Assert.DoesNotContain("<script>", result);
    }
}


================================================================================
FILE: src/MyBlog.Tests/Unit/PasswordServiceTests.cs
SIZE: 1.30 KB
MODIFIED: 2025-12-28 08:05:13
================================================================================

using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Unit;

public class PasswordServiceTests
{
    private readonly PasswordService _sut = new();

    [Fact]
    public void HashPassword_ReturnsNonEmptyHash()
    {
        var hash = _sut.HashPassword("TestPassword123");
        Assert.False(string.IsNullOrEmpty(hash));
    }

    [Fact]
    public void HashPassword_ReturnsDifferentHashForSamePassword()
    {
        var hash1 = _sut.HashPassword("TestPassword123");
        var hash2 = _sut.HashPassword("TestPassword123");
        Assert.NotEqual(hash1, hash2);
    }

    [Fact]
    public void VerifyPassword_WithCorrectPassword_ReturnsTrue()
    {
        var password = "TestPassword123";
        var hash = _sut.HashPassword(password);

        var result = _sut.VerifyPassword(hash, password);

        Assert.True(result);
    }

    [Fact]
    public void VerifyPassword_WithWrongPassword_ReturnsFalse()
    {
        var hash = _sut.HashPassword("TestPassword123");

        var result = _sut.VerifyPassword(hash, "WrongPassword");

        Assert.False(result);
    }

    [Fact]
    public void VerifyPassword_WithEmptyPassword_ReturnsFalse()
    {
        var hash = _sut.HashPassword("TestPassword123");

        var result = _sut.VerifyPassword(hash, "");

        Assert.False(result);
    }
}


================================================================================
FILE: src/MyBlog.Tests/Unit/SlugServiceTests.cs
SIZE: 1.85 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

using MyBlog.Core.Services;
using Xunit;

namespace MyBlog.Tests.Unit;

public class SlugServiceTests
{
    private readonly SlugService _sut = new();

    [Fact]
    public void GenerateSlug_WithSimpleTitle_ReturnsLowercaseWithHyphens()
    {
        var result = _sut.GenerateSlug("Hello World");
        Assert.Equal("hello-world", result);
    }

    [Fact]
    public void GenerateSlug_WithSpecialCharacters_RemovesThem()
    {
        var result = _sut.GenerateSlug("Hello, World! How's it going?");
        Assert.Equal("hello-world-hows-it-going", result);
    }

    [Fact]
    public void GenerateSlug_WithMultipleSpaces_CollapsesToSingleHyphen()
    {
        var result = _sut.GenerateSlug("Hello    World");
        Assert.Equal("hello-world", result);
    }

    [Fact]
    public void GenerateSlug_WithUnicode_RemovesDiacritics()
    {
        var result = _sut.GenerateSlug("Café résumé");
        Assert.Equal("cafe-resume", result);
    }

    [Fact]
    public void GenerateSlug_WithLeadingTrailingSpaces_TrimsHyphens()
    {
        var result = _sut.GenerateSlug("  Hello World  ");
        Assert.Equal("hello-world", result);
    }

    [Fact]
    public void GenerateSlug_WithNumbers_PreservesNumbers()
    {
        var result = _sut.GenerateSlug("Top 10 Tips for 2024");
        Assert.Equal("top-10-tips-for-2024", result);
    }

    [Fact]
    public void GenerateSlug_WithUnderscores_ConvertsToHyphens()
    {
        var result = _sut.GenerateSlug("hello_world_test");
        Assert.Equal("hello-world-test", result);
    }

    [Fact]
    public void GenerateSlug_WithEmptyString_ThrowsArgumentException()
    {
        Assert.Throws<ArgumentException>(() => _sut.GenerateSlug(""));
    }

    [Fact]
    public void GenerateSlug_WithWhitespaceOnly_ThrowsArgumentException()
    {
        Assert.Throws<ArgumentException>(() => _sut.GenerateSlug("   "));
    }
}


================================================================================
FILE: src/MyBlog.Web/appsettings.Development.json
SIZE: .11 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Information"
    }
  }
}


================================================================================
FILE: src/MyBlog.Web/appsettings.json
SIZE: .54 KB
MODIFIED: 2025-12-28 10:14:51
================================================================================

{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=myblog.db"
  },
  "Authentication": {
    "SessionTimeoutMinutes": 30,
    "DefaultAdminPassword": "ChangeMe123!"
  },
  "Telemetry": {
    "RetentionDays": 30,
    "EnableFileLogging": true,
    "EnableDatabaseLogging": true
  },
  "Application": {
    "Title": "MyBlog",
    "PostsPerPage": 10,
    "RequireHttps": false
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  }
}


================================================================================
FILE: src/MyBlog.Web/Middleware/LoginRateLimitMiddleware.cs
SIZE: 5.65 KB
MODIFIED: 2025-12-28 12:56:41
================================================================================

using System.Collections.Concurrent;

namespace MyBlog.Web.Middleware;

/// <summary>
/// Rate limiting middleware for login attempts.
/// Slows down requests but NEVER blocks users completely.
/// </summary>
public sealed class LoginRateLimitMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<LoginRateLimitMiddleware> _logger;
    private readonly Func<TimeSpan, CancellationToken, Task>? _delayFunc;

    // Track attempts per IP: IP -> (attempt count, window start)
    private static readonly ConcurrentDictionary<string, (int Count, DateTime WindowStart)> _attempts = new();

    // Configuration
    private const int WindowMinutes = 15;
    private const int AttemptsBeforeDelay = 5;
    private const int MaxDelaySeconds = 30;

    // Use this for the standard DI activation
    [ActivatorUtilitiesConstructor]
    public LoginRateLimitMiddleware(RequestDelegate next, ILogger<LoginRateLimitMiddleware> logger)
        : this(next, logger, null)
    {
    }

    /// <summary>
    /// Constructor with injectable delay function for testing.
    /// </summary>
    public LoginRateLimitMiddleware(
        RequestDelegate next,
        ILogger<LoginRateLimitMiddleware> logger,
        Func<TimeSpan, CancellationToken, Task>? delayFunc)
    {
        _next = next;
        _logger = logger;
        _delayFunc = delayFunc;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Only rate limit POST requests to login endpoint
        if (!IsLoginPostRequest(context))
        {
            await _next(context);
            return;
        }

        var ip = GetClientIp(context);
        var delay = CalculateDelay(ip);

        if (delay > TimeSpan.Zero)
        {
            _logger.LogInformation(
                "Rate limiting login attempt from {IP}, delaying {Seconds}s",
                ip, delay.TotalSeconds);

            // Use injected delay function if available (for testing), otherwise real delay
            if (_delayFunc != null)
            {
                await _delayFunc(delay, context.RequestAborted);
            }
            else
            {
                await Task.Delay(delay, context.RequestAborted);
            }
        }

        // Always proceed - never block
        await _next(context);

        // Record the attempt after processing
        RecordAttempt(ip);
    }

    private static bool IsLoginPostRequest(HttpContext context)
    {
        return context.Request.Method == HttpMethods.Post &&
               context.Request.Path.StartsWithSegments("/login", StringComparison.OrdinalIgnoreCase);
    }

    private static string GetClientIp(HttpContext context)
    {
        // Check for forwarded IP (behind proxy/load balancer)
        var forwardedFor = context.Request.Headers["X-Forwarded-For"].FirstOrDefault();
        if (!string.IsNullOrEmpty(forwardedFor))
        {
            var ip = forwardedFor.Split(',')[0].Trim();
            if (!string.IsNullOrEmpty(ip))
            {
                return ip;
            }
        }

        return context.Connection.RemoteIpAddress?.ToString() ?? "unknown";
    }

    /// <summary>
    /// Calculates the delay for a given IP. Exposed for testing.
    /// </summary>
    public static TimeSpan CalculateDelay(string ip)
    {
        if (!_attempts.TryGetValue(ip, out var record))
        {
            return TimeSpan.Zero;
        }

        // Reset if window expired
        if (DateTime.UtcNow - record.WindowStart > TimeSpan.FromMinutes(WindowMinutes))
        {
            _attempts.TryRemove(ip, out _);
            return TimeSpan.Zero;
        }

        // No delay for first few attempts
        if (record.Count < AttemptsBeforeDelay)
        {
            return TimeSpan.Zero;
        }

        // Progressive delay: 1s, 2s, 4s, 8s, ... capped at MaxDelaySeconds
        var delayMultiplier = record.Count - AttemptsBeforeDelay;
        var delaySeconds = Math.Min(Math.Pow(2, delayMultiplier), MaxDelaySeconds);
        return TimeSpan.FromSeconds(delaySeconds);
    }

    /// <summary>
    /// Records a login attempt for the given IP. Exposed for testing.
    /// </summary>
    internal static void RecordAttempt(string ip)
    {
        var now = DateTime.UtcNow;

        _attempts.AddOrUpdate(
            ip,
            _ => (1, now),
            (_, existing) =>
            {
                // Reset window if expired
                if (now - existing.WindowStart > TimeSpan.FromMinutes(WindowMinutes))
                {
                    return (1, now);
                }
                return (existing.Count + 1, existing.WindowStart);
            });

        // Cleanup old entries periodically (every 100th request)
        if (Random.Shared.Next(100) == 0)
        {
            CleanupOldEntries();
        }
    }

    /// <summary>
    /// Clears all tracked attempts. For testing only.
    /// </summary>
    public static void ClearAttempts()
    {
        _attempts.Clear();
    }

    private static void CleanupOldEntries()
    {
        var cutoff = DateTime.UtcNow.AddMinutes(-WindowMinutes * 2);
        foreach (var kvp in _attempts)
        {
            if (kvp.Value.WindowStart < cutoff)
            {
                _attempts.TryRemove(kvp.Key, out _);
            }
        }
    }
}

/// <summary>
/// Extension methods for LoginRateLimitMiddleware.
/// </summary>
public static class LoginRateLimitMiddlewareExtensions
{
    /// <summary>
    /// Adds login rate limiting middleware that slows down repeated attempts
    /// but never completely blocks users.
    /// </summary>
    public static IApplicationBuilder UseLoginRateLimit(this IApplicationBuilder app)
    {
        return app.UseMiddleware<LoginRateLimitMiddleware>();
    }
}


================================================================================
FILE: src/MyBlog.Web/MyBlog.Web.csproj
SIZE: .55 KB
MODIFIED: 2025-12-28 08:26:41
================================================================================

<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <RootNamespace>MyBlog.Web</RootNamespace>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\MyBlog.Infrastructure\MyBlog.Infrastructure.csproj" />
  </ItemGroup>
</Project>

================================================================================
FILE: src/MyBlog.Web/Program.cs
SIZE: 3.15 KB
MODIFIED: 2025-12-28 11:13:13
================================================================================

using Microsoft.AspNetCore.Authentication.Cookies;
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Constants;
using MyBlog.Core.Interfaces;
using MyBlog.Infrastructure;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Telemetry;
using MyBlog.Web.Components;
using MyBlog.Web.Middleware;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

builder.Services.AddInfrastructure(builder.Configuration);

// Configure authentication
var sessionTimeout = builder.Configuration.GetValue("Authentication:SessionTimeoutMinutes", 30);
builder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie(options =>
    {
        options.Cookie.Name = AppConstants.AuthCookieName;
        options.LoginPath = "/login";
        options.LogoutPath = "/logout";
        options.ExpireTimeSpan = TimeSpan.FromMinutes(sessionTimeout);
        options.SlidingExpiration = true;
        options.Cookie.HttpOnly = true;
        options.Cookie.SecurePolicy = builder.Configuration.GetValue("Application:RequireHttps", false)
            ? CookieSecurePolicy.Always
            : CookieSecurePolicy.SameAsRequest;
    });

builder.Services.AddHttpContextAccessor();
builder.Services.AddCascadingAuthenticationState();
builder.Services.AddAuthorization();

// Configure OpenTelemetry
var serviceName = "MyBlog.Web";
var serviceVersion = "1.0.0";

builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource.AddService(serviceName, serviceVersion))
    .WithTracing(tracing => tracing
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter())
    .WithMetrics(metrics => metrics
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter());

// Configure OpenTelemetry logging
builder.Logging.AddOpenTelemetry(logging =>
{
    logging.SetResourceBuilder(ResourceBuilder.CreateDefault().AddService(serviceName, serviceVersion));
    logging.IncludeFormattedMessage = true;
    logging.IncludeScopes = true;
    logging.AddConsoleExporter();
});

var app = builder.Build();

// Initialize database and ensure admin user exists
// Use a scope to resolve scoped services during startup
using (var scope = app.Services.CreateScope())
{
    var context = scope.ServiceProvider.GetRequiredService<BlogDbContext>();
    await context.Database.EnsureCreatedAsync();

    var authService = scope.ServiceProvider.GetRequiredService<IAuthService>();
    await authService.EnsureAdminUserAsync();
}

// Configure HTTP pipeline
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    if (builder.Configuration.GetValue("Application:RequireHttps", false))
    {
        app.UseHsts();
        app.UseHttpsRedirection();
    }
}

app.UseStaticFiles();
app.UseLoginRateLimit();
app.UseAuthentication();
app.UseAuthorization();
app.UseAntiforgery();

app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();

app.Run();


================================================================================
FILE: src/MyBlog.Web/wwwroot/css/site.css
SIZE: 9.19 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

/* =============================================================================
   MyBlog CSS - Custom styles without any framework
   ============================================================================= */

/* CSS Variables for theming */
:root {
    --color-bg: #ffffff;
    --color-bg-alt: #f8f9fa;
    --color-text: #212529;
    --color-text-muted: #6c757d;
    --color-primary: #0d6efd;
    --color-primary-hover: #0b5ed7;
    --color-border: #dee2e6;
    --color-danger: #dc3545;
    --color-success: #198754;
    --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    --font-mono: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    --max-width: 1200px;
    --spacing: 1rem;
    --radius: 0.375rem;
}

/* Reset and base styles */
*, *::before, *::after {
    box-sizing: border-box;
}

html {
    font-size: 16px;
    line-height: 1.5;
}

body {
    margin: 0;
    font-family: var(--font-sans);
    color: var(--color-text);
    background-color: var(--color-bg);
}

h1, h2, h3, h4, h5, h6 {
    margin-top: 0;
    margin-bottom: 0.5em;
    font-weight: 600;
    line-height: 1.2;
}

h1 { font-size: 2.5rem; }
h2 { font-size: 2rem; }
h3 { font-size: 1.5rem; }

p {
    margin-top: 0;
    margin-bottom: 1rem;
}

a {
    color: var(--color-primary);
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

/* Container */
.container {
    max-width: var(--max-width);
    margin: 0 auto;
    padding: 0 var(--spacing);
}

/* Layout */
.layout {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Header */
.header {
    background-color: var(--color-bg-alt);
    border-bottom: 1px solid var(--color-border);
    padding: var(--spacing) 0;
}

.header .container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--spacing);
}

.logo {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-text);
}

.logo:hover {
    text-decoration: none;
}

.nav {
    display: flex;
    gap: var(--spacing);
    align-items: center;
}

.nav a {
    color: var(--color-text);
}

.logout-form {
    display: inline;
}

.logout-form button {
    background: none;
    border: none;
    color: var(--color-primary);
    cursor: pointer;
    font: inherit;
    padding: 0;
}

.logout-form button:hover {
    text-decoration: underline;
}

/* Main content */
.main {
    flex: 1;
    padding: calc(var(--spacing) * 2) 0;
}

/* Footer */
.footer {
    background-color: var(--color-bg-alt);
    border-top: 1px solid var(--color-border);
    padding: var(--spacing) 0;
    text-align: center;
    color: var(--color-text-muted);
}

/* Buttons */
.btn {
    display: inline-block;
    padding: 0.5rem 1rem;
    background-color: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    color: var(--color-text);
    cursor: pointer;
    font: inherit;
    text-decoration: none;
    transition: background-color 0.2s;
}

.btn:hover {
    background-color: var(--color-border);
    text-decoration: none;
}

.btn-primary {
    background-color: var(--color-primary);
    border-color: var(--color-primary);
    color: white;
}

.btn-primary:hover {
    background-color: var(--color-primary-hover);
}

.btn-link {
    background: none;
    border: none;
    color: var(--color-primary);
    cursor: pointer;
    padding: 0;
    font: inherit;
}

.btn-link:hover {
    text-decoration: underline;
}

.btn-link.danger {
    color: var(--color-danger);
}

/* Forms */
.form-group {
    margin-bottom: var(--spacing);
}

.form-group label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: 500;
}

.form-group input[type="text"],
.form-group input[type="password"],
.form-group input[type="email"],
.form-group textarea {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    font: inherit;
}

.form-group textarea {
    resize: vertical;
}

.form-group.checkbox label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.form-group.checkbox input {
    width: auto;
}

.form-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: var(--spacing);
}

/* Post cards */
.post-list {
    display: flex;
    flex-direction: column;
    gap: calc(var(--spacing) * 2);
}

.post-card {
    padding: var(--spacing);
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
}

.post-card-title {
    margin-bottom: 0.5rem;
}

.post-card-title a {
    color: var(--color-text);
}

.post-card-meta {
    color: var(--color-text-muted);
    font-size: 0.875rem;
    margin-bottom: 0.5rem;
}

.post-card-meta span {
    margin-right: 1rem;
}

.draft-badge {
    background-color: var(--color-text-muted);
    color: white;
    padding: 0.125rem 0.5rem;
    border-radius: var(--radius);
    font-size: 0.75rem;
}

.read-more {
    font-weight: 500;
}

/* Pagination */
.pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: var(--spacing);
    margin-top: calc(var(--spacing) * 2);
}

.page-info {
    color: var(--color-text-muted);
}

/* Post detail */
.post-detail {
    max-width: 800px;
}

.post-header {
    margin-bottom: calc(var(--spacing) * 2);
}

.post-meta {
    color: var(--color-text-muted);
}

.post-meta span {
    margin-right: 1rem;
}

.back-link {
    display: inline-block;
    margin-top: calc(var(--spacing) * 2);
}

/* Markdown content */
.markdown-content {
    line-height: 1.7;
}

.markdown-content h1,
.markdown-content h2,
.markdown-content h3,
.markdown-content h4,
.markdown-content h5,
.markdown-content h6 {
    margin-top: 1.5em;
}

.markdown-content pre {
    background-color: var(--color-bg-alt);
    padding: var(--spacing);
    border-radius: var(--radius);
    overflow-x: auto;
}

.markdown-content code {
    font-family: var(--font-mono);
    font-size: 0.875em;
}

.markdown-content :not(pre) > code {
    background-color: var(--color-bg-alt);
    padding: 0.125rem 0.25rem;
    border-radius: 0.25rem;
}

.markdown-content blockquote {
    border-left: 4px solid var(--color-border);
    margin: 0;
    padding-left: var(--spacing);
    color: var(--color-text-muted);
}

.markdown-content img {
    max-width: 100%;
    height: auto;
}

.markdown-content hr {
    border: none;
    border-top: 1px solid var(--color-border);
    margin: calc(var(--spacing) * 2) 0;
}

/* Login page */
.login-page {
    max-width: 400px;
    margin: 0 auto;
}

.error-message {
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
    color: #842029;
    padding: var(--spacing);
    border-radius: var(--radius);
    margin-bottom: var(--spacing);
}

/* Admin styles */
.dashboard-stats {
    display: flex;
    gap: var(--spacing);
    margin-bottom: calc(var(--spacing) * 2);
}

.stat-card {
    padding: var(--spacing);
    background-color: var(--color-bg-alt);
    border-radius: var(--radius);
    text-align: center;
}

.stat-value {
    font-size: 2rem;
    font-weight: 700;
    margin: 0;
}

.admin-nav {
    display: flex;
    gap: 0.5rem;
    margin-bottom: calc(var(--spacing) * 2);
}

.admin-table {
    width: 100%;
    border-collapse: collapse;
}

.admin-table th,
.admin-table td {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 1px solid var(--color-border);
}

.admin-table th {
    background-color: var(--color-bg-alt);
    font-weight: 600;
}

/* Post editor */
.post-editor {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: calc(var(--spacing) * 2);
}

.editor-preview {
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    padding: var(--spacing);
    max-height: 80vh;
    overflow-y: auto;
}

.editor-preview h3 {
    margin-bottom: var(--spacing);
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--color-border);
}

/* Image manager */
.image-upload {
    margin-bottom: calc(var(--spacing) * 2);
    padding: var(--spacing);
    background-color: var(--color-bg-alt);
    border-radius: var(--radius);
}

.image-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: var(--spacing);
}

.image-card {
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    overflow: hidden;
}

.image-card img {
    width: 100%;
    height: 150px;
    object-fit: cover;
}

.image-info {
    padding: 0.5rem;
}

.image-info p {
    margin: 0 0 0.25rem;
    font-size: 0.875rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.image-info code {
    display: block;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    margin-bottom: 0.25rem;
}

.success {
    color: var(--color-success);
}

.error {
    color: var(--color-danger);
}

/* Responsive */
@media (max-width: 768px) {
    h1 { font-size: 2rem; }
    h2 { font-size: 1.5rem; }
    
    .header .container {
        flex-direction: column;
        text-align: center;
    }
    
    .nav {
        flex-wrap: wrap;
        justify-content: center;
    }
    
    .post-editor {
        grid-template-columns: 1fr;
    }
    
    .editor-preview {
        order: -1;
        max-height: 300px;
    }
    
    .dashboard-stats {
        flex-direction: column;
    }
    
    .admin-nav {
        flex-wrap: wrap;
    }
}


================================================================================
FILE: src/run.sh
SIZE: .10 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

#!/bin/bash
# Run the MyBlog application in development mode
cd "$(dirname "$0")/MyBlog.Web"
dotnet run


================================================================================
FILE: src/test.sh
SIZE: .08 KB
MODIFIED: 2025-12-28 07:44:06
================================================================================

#!/bin/bash
# Run all tests
cd "$(dirname "$0")"
dotnet test MyBlog.slnx -v normal


================================================================================
FILE: src/upgrade-myblog.sh
SIZE: 30.16 KB
MODIFIED: 2025-12-28 10:31:00
================================================================================

#!/bin/bash
# =============================================================================
# MyBlog Upgrade Script
# Adds password change functionality, fixes deployment, generates tests & docs
# =============================================================================

set -e

# Detect the src directory
if [ -d "./src" ]; then
    SRC_DIR="./src"
elif [ -d "../src" ]; then
    SRC_DIR="../src"
else
    echo "Error: Cannot find src directory. Run this from the repository root."
    exit 1
fi

echo "=============================================="
echo "  MyBlog Upgrade Script"
echo "=============================================="
echo ""
echo "This script will:"
echo "  1. Add password change functionality to the website"
echo "  2. Fix the ERROR_FILE_IN_USE deployment issue"
echo "  3. Generate test cases for new features"
echo "  4. Create a comprehensive README"
echo ""
read -p "Continue? (y/N) " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Aborted."
    exit 0
fi

# =============================================================================
# Step 1: Add IUserRepository.UpdateAsync and IAuthService.ChangePasswordAsync
# =============================================================================
echo ""
echo "[1/7] Adding password change interface methods..."

# Update IUserRepository.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Interfaces/IUserRepository.cs"
using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for user data access.
/// </summary>
public interface IUserRepository
{
    /// <summary>Gets a user by ID.</summary>
    Task<User?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Gets a user by username.</summary>
    Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default);

    /// <summary>Checks if any users exist.</summary>
    Task<bool> AnyUsersExistAsync(CancellationToken cancellationToken = default);

    /// <summary>Creates a new user.</summary>
    Task CreateAsync(User user, CancellationToken cancellationToken = default);

    /// <summary>Updates an existing user.</summary>
    Task UpdateAsync(User user, CancellationToken cancellationToken = default);
}
EOF

# Update IAuthService.cs
cat << 'EOF' > "$SRC_DIR/MyBlog.Core/Interfaces/IAuthService.cs"
using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for authentication operations.
/// </summary>
public interface IAuthService
{
    /// <summary>Attempts to authenticate a user.</summary>
    Task<User?> AuthenticateAsync(
        string username, string password, CancellationToken cancellationToken = default);

    /// <summary>Ensures the default admin user exists.</summary>
    Task EnsureAdminUserAsync(CancellationToken cancellationToken = default);

    /// <summary>Changes a user's password.</summary>
    /// <returns>True if password was changed, false if current password was incorrect.</returns>
    Task<bool> ChangePasswordAsync(
        Guid userId,
        string currentPassword,
        string newPassword,
        CancellationToken cancellationToken = default);

    /// <summary>Resets a user's password without requiring the current password (admin function).</summary>
    Task ResetPasswordAsync(
        Guid userId,
        string newPassword,
        CancellationToken cancellationToken = default);
}
EOF

echo "      Done."

# =============================================================================
# Step 2: Update UserRepository implementation
# =============================================================================
echo "[2/7] Updating UserRepository with UpdateAsync..."

cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Repositories/UserRepository.cs"
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// SQLite implementation of the user repository.
/// </summary>
public sealed class UserRepository : IUserRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of UserRepository.</summary>
    public UserRepository(BlogDbContext context) => _context = context;

    /// <inheritdoc />
    public async Task<User?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
        => await _context.Users.FirstOrDefaultAsync(u => u.Id == id, cancellationToken);

    /// <inheritdoc />
    public async Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default)
        => await _context.Users.FirstOrDefaultAsync(
            u => u.Username.ToLower() == username.ToLower(), cancellationToken);

    /// <inheritdoc />
    public async Task<bool> AnyUsersExistAsync(CancellationToken cancellationToken = default)
        => await _context.Users.AnyAsync(cancellationToken);

    /// <inheritdoc />
    public async Task CreateAsync(User user, CancellationToken cancellationToken = default)
    {
        _context.Users.Add(user);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task UpdateAsync(User user, CancellationToken cancellationToken = default)
    {
        _context.Users.Update(user);
        await _context.SaveChangesAsync(cancellationToken);
    }
}
EOF

echo "      Done."

# =============================================================================
# Step 3: Update AuthService implementation
# =============================================================================
echo "[3/7] Updating AuthService with ChangePasswordAsync..."

cat << 'EOF' > "$SRC_DIR/MyBlog.Infrastructure/Services/AuthService.cs"
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Authentication service implementation.
/// </summary>
public sealed class AuthService : IAuthService
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordService _passwordService;
    private readonly IConfiguration _configuration;

    /// <summary>Initializes a new instance of AuthService.</summary>
    public AuthService(
        IUserRepository userRepository,
        IPasswordService passwordService,
        IConfiguration configuration)
    {
        _userRepository = userRepository;
        _passwordService = passwordService;
        _configuration = configuration;
    }

    /// <inheritdoc />
    public async Task<User?> AuthenticateAsync(
        string username, string password, CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByUsernameAsync(username, cancellationToken);
        if (user is null)
        {
            return null;
        }

        return _passwordService.VerifyPassword(user.PasswordHash, password) ? user : null;
    }

    /// <inheritdoc />
    public async Task EnsureAdminUserAsync(CancellationToken cancellationToken = default)
    {
        if (await _userRepository.AnyUsersExistAsync(cancellationToken))
        {
            return;
        }

        var defaultPassword = Environment.GetEnvironmentVariable("MYBLOG_ADMIN_PASSWORD")
            ?? _configuration["Authentication:DefaultAdminPassword"]
            ?? "ChangeMe123!";

        var admin = new User
        {
            Id = Guid.NewGuid(),
            Username = "admin",
            PasswordHash = _passwordService.HashPassword(defaultPassword),
            Email = "admin@localhost",
            DisplayName = "Administrator",
            CreatedAtUtc = DateTime.UtcNow
        };

        await _userRepository.CreateAsync(admin, cancellationToken);
    }

    /// <inheritdoc />
    public async Task<bool> ChangePasswordAsync(
        Guid userId,
        string currentPassword,
        string newPassword,
        CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
        if (user is null)
        {
            return false;
        }

        // Verify current password
        if (!_passwordService.VerifyPassword(user.PasswordHash, currentPassword))
        {
            return false;
        }

        // Update to new password
        user.PasswordHash = _passwordService.HashPassword(newPassword);
        await _userRepository.UpdateAsync(user, cancellationToken);

        return true;
    }

    /// <inheritdoc />
    public async Task ResetPasswordAsync(
        Guid userId,
        string newPassword,
        CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
        if (user is null)
        {
            throw new InvalidOperationException($"User with ID {userId} not found.");
        }

        user.PasswordHash = _passwordService.HashPassword(newPassword);
        await _userRepository.UpdateAsync(user, cancellationToken);
    }
}
EOF

echo "      Done."

# =============================================================================
# Step 4: Create ChangePassword.razor page
# =============================================================================
echo "[4/7] Creating password change UI..."

cat << 'EOF' > "$SRC_DIR/MyBlog.Web/Components/Pages/Admin/ChangePassword.razor"
@page "/admin/change-password"
@attribute [Authorize]
@inject IAuthService AuthService
@inject IHttpContextAccessor HttpContextAccessor
@inject NavigationManager Navigation
@using System.Security.Claims

<PageTitle>Change Password</PageTitle>

<h1>Change Password</h1>

<div class="change-password-form">
    @if (!string.IsNullOrEmpty(_successMessage))
    {
        <div class="success-message">@_successMessage</div>
    }

    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="error-message">@_errorMessage</div>
    }

    <form method="post" @onsubmit="HandleSubmit" @formname="changepassword">
        <AntiforgeryToken />

        <div class="form-group">
            <label for="currentPassword">Current Password</label>
            <input type="password" id="currentPassword" @bind="_currentPassword" required />
        </div>

        <div class="form-group">
            <label for="newPassword">New Password</label>
            <input type="password" id="newPassword" @bind="_newPassword" required minlength="8" />
            <small>Minimum 8 characters</small>
        </div>

        <div class="form-group">
            <label for="confirmPassword">Confirm New Password</label>
            <input type="password" id="confirmPassword" @bind="_confirmPassword" required />
        </div>

        <div class="form-actions">
            <button type="submit" class="btn btn-primary">Change Password</button>
            <a href="/admin" class="btn btn-secondary">Cancel</a>
        </div>
    </form>
</div>

@code {
    private string _currentPassword = "";
    private string _newPassword = "";
    private string _confirmPassword = "";
    private string? _successMessage;
    private string? _errorMessage;

    private async Task HandleSubmit()
    {
        _successMessage = null;
        _errorMessage = null;

        // Validation
        if (string.IsNullOrWhiteSpace(_newPassword) || _newPassword.Length < 8)
        {
            _errorMessage = "New password must be at least 8 characters.";
            return;
        }

        if (_newPassword != _confirmPassword)
        {
            _errorMessage = "New password and confirmation do not match.";
            return;
        }

        if (_currentPassword == _newPassword)
        {
            _errorMessage = "New password must be different from current password.";
            return;
        }

        // Get current user ID
        var context = HttpContextAccessor.HttpContext;
        var userIdClaim = context?.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        
        if (string.IsNullOrEmpty(userIdClaim) || !Guid.TryParse(userIdClaim, out var userId))
        {
            _errorMessage = "Unable to identify current user. Please log in again.";
            return;
        }

        // Attempt password change
        var success = await AuthService.ChangePasswordAsync(userId, _currentPassword, _newPassword);

        if (success)
        {
            _successMessage = "Password changed successfully!";
            _currentPassword = "";
            _newPassword = "";
            _confirmPassword = "";
        }
        else
        {
            _errorMessage = "Current password is incorrect.";
        }
    }
}
EOF

echo "      Done."

# =============================================================================
# Step 5: Update GitHub Actions workflow with AppOffline
# =============================================================================
echo "[5/7] Fixing deployment with AppOffline rule..."

cat << 'EOF' > "$SRC_DIR/.github/workflows/build-deploy.yml"
name: Build, Test, and Deploy

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

jobs:
  build-test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore dependencies
        run: dotnet restore src/MyBlog.slnx

      - name: Build solution
        run: dotnet build src/MyBlog.slnx -c Release --no-restore

      - name: Run tests
        run: dotnet test src/MyBlog.slnx -c Release --no-build --logger trx --results-directory TestResults

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.os }}
          path: TestResults
          retention-days: 7

  deploy:
    needs: build-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Publish application
        run: dotnet publish src/MyBlog.Web/MyBlog.Web.csproj -c Release -o ./publish -r win-x86 --self-contained false

      - name: Deploy via WebDeploy
        shell: pwsh
        env:
          DEPLOY_SOURCE: ${{ github.workspace }}\publish
          DEPLOY_SITE: ${{ secrets.WEBSITE_NAME }}
          DEPLOY_HOST: ${{ secrets.SERVER_COMPUTER_NAME }}
          DEPLOY_USER: ${{ secrets.SERVER_USERNAME }}
          DEPLOY_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
        run: |
          $msdeployPath = "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe"
          
          if (-not (Test-Path $msdeployPath)) {
            Write-Host "Installing Web Deploy..."
            choco install webdeploy -y --no-progress
          }
          
          Write-Host "Deploying to $env:DEPLOY_HOST..."
          Write-Host "Note: Using AppOffline rule to prevent file-in-use errors"

          $sourceArg = "-source:contentPath=$env:DEPLOY_SOURCE"
          $destArg = "-dest:contentPath=$env:DEPLOY_SITE,computerName=https://$($env:DEPLOY_HOST):8172/MsDeploy.axd?site=$env:DEPLOY_SITE,userName=$env:DEPLOY_USER,password=$env:DEPLOY_PASSWORD,AuthType='Basic'"
          
          # Key fix: Added -enableRule:AppOffline to stop the app during deployment
          # This creates app_offline.htm, waits for app to stop, deploys, then removes the file
          & $msdeployPath -verb:sync $sourceArg $destArg `
            -allowUntrusted `
            -enableRule:DoNotDeleteRule `
            -enableRule:AppOffline `
            -retryAttempts:3 `
            -retryInterval:3000
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Deployment failed with exit code $LASTEXITCODE"
            exit 1
          }
          
          Write-Host "Deployment completed successfully!"
EOF

echo "      Done."

# =============================================================================
# Step 6: Generate test cases
# =============================================================================
echo "[6/7] Generating test cases for password change..."

cat << 'EOF' > "$SRC_DIR/MyBlog.Tests/Integration/PasswordChangeTests.cs"
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Integration;

public class PasswordChangeTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly AuthService _sut;
    private readonly PasswordService _passwordService = new();
    private readonly UserRepository _userRepository;

    public PasswordChangeTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _userRepository = new UserRepository(_context);
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Authentication:DefaultAdminPassword"] = "TestAdmin123!"
            })
            .Build();

        _sut = new AuthService(_userRepository, _passwordService, configuration);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task ChangePasswordAsync_WithCorrectCurrentPassword_ReturnsTrue()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "NewPassword456!";
        
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.ChangePasswordAsync(user.Id, originalPassword, newPassword, ct);

        Assert.True(result);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithCorrectPassword_AllowsLoginWithNewPassword()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "NewPassword456!";
        
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        await _sut.ChangePasswordAsync(user.Id, originalPassword, newPassword, ct);

        // Should authenticate with new password
        var authenticated = await _sut.AuthenticateAsync("testuser", newPassword, ct);
        Assert.NotNull(authenticated);
        
        // Should NOT authenticate with old password
        var oldAuth = await _sut.AuthenticateAsync("testuser", originalPassword, ct);
        Assert.Null(oldAuth);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithWrongCurrentPassword_ReturnsFalse()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPass123!";
        var wrongPassword = "WrongPassword!";
        
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.ChangePasswordAsync(user.Id, wrongPassword, "NewPass123!", ct);

        Assert.False(result);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithWrongPassword_DoesNotChangePassword()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPass123!";
        
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        await _sut.ChangePasswordAsync(user.Id, "WrongPassword!", "NewPass123!", ct);

        // Original password should still work
        var authenticated = await _sut.AuthenticateAsync("testuser", correctPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithNonExistentUser_ReturnsFalse()
    {
        var ct = TestContext.Current.CancellationToken;
        var result = await _sut.ChangePasswordAsync(Guid.NewGuid(), "any", "password", ct);
        Assert.False(result);
    }

    [Fact]
    public async Task ResetPasswordAsync_SetsNewPassword()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "ResetPassword789!";
        
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        await _sut.ResetPasswordAsync(user.Id, newPassword, ct);

        var authenticated = await _sut.AuthenticateAsync("testuser", newPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task ResetPasswordAsync_WithNonExistentUser_ThrowsException()
    {
        var ct = TestContext.Current.CancellationToken;
        await Assert.ThrowsAsync<InvalidOperationException>(
            () => _sut.ResetPasswordAsync(Guid.NewGuid(), "password", ct));
    }
}
EOF

echo "      Done."

# =============================================================================
# Step 7: Generate README
# =============================================================================
echo "[7/7] Generating comprehensive README..."

cat << 'EOF' > "$SRC_DIR/../README.md"
# MyBlog

A lightweight, self-hosted blogging platform built with .NET 10 and Blazor Server.

## Features

- **Markdown-based content**: Write posts in Markdown with live preview
- **Image management**: Upload and manage images stored in the database
- **Admin dashboard**: Manage posts, images, and settings
- **OpenTelemetry**: Built-in observability with file-based telemetry export
- **Cross-platform**: Runs on Windows, Linux, and macOS
- **CI/CD ready**: GitHub Actions workflow for automated testing and deployment

## Quick Start

### Prerequisites

- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0) or later

### Running Locally

```bash
# Clone the repository
git clone https://github.com/yourusername/dotnetcms.git
cd dotnetcms/src

# Restore and run
dotnet restore MyBlog.slnx
cd MyBlog.Web
dotnet run
```

The application will start at `http://localhost:5000` (or the next available port).

### Default Credentials

- **Username**: `admin`
- **Password**: `ChangeMe123!` (or value of `MYBLOG_ADMIN_PASSWORD` environment variable)

> **Important**: The default password is only used when creating the initial admin user. Once the user exists, you must change the password through the website.

## Configuration

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `MYBLOG_ADMIN_PASSWORD` | Initial admin password (only used on first run) | `ChangeMe123!` |
| `ASPNETCORE_ENVIRONMENT` | Runtime environment | `Production` |

### appsettings.json

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=myblog.db"
  },
  "Authentication": {
    "SessionTimeoutMinutes": 30,
    "DefaultAdminPassword": "ChangeMe123!"
  },
  "Application": {
    "Title": "MyBlog"
  }
}
```

### Database Location

The SQLite database is stored in a platform-specific location:

| Platform | Path |
|----------|------|
| Linux | `~/.local/share/MyBlog/myblog.db` |
| macOS | `~/Library/Application Support/MyBlog/myblog.db` |
| Windows | `%LOCALAPPDATA%\MyBlog\myblog.db` |

## Admin Features

### Dashboard (`/admin`)

The admin dashboard provides an overview of your blog with quick access to all management features.

### Managing Posts

- **Create Post** (`/admin/posts/new`): Write a new blog post in Markdown
- **Edit Post** (`/admin/posts/edit/{id}`): Modify existing posts
- **Post List** (`/admin/posts`): View and manage all posts

### Managing Images

- **Upload Images** (`/admin/images`): Upload images to use in posts
- **Image Library**: Browse and delete uploaded images
- **Usage**: Reference images in Markdown using `/api/images/{id}`

### Changing Your Password

Navigate to `/admin/change-password` to change your admin password:

1. Enter your current password
2. Enter your new password (minimum 8 characters)
3. Confirm the new password
4. Click "Change Password"

> **Note**: The `MYBLOG_ADMIN_PASSWORD` environment variable only affects the initial password when the admin user is first created. It does not override existing passwords.

## Deployment

### GitHub Actions (Automated)

The repository includes a GitHub Actions workflow that:

1. Builds and tests on Windows, Linux, and macOS
2. Deploys to your server via WebDeploy (on main/master/develop branches)

#### Required Secrets

Set these in your repository settings under **Settings > Secrets and variables > Actions**:

| Secret | Description | Example |
|--------|-------------|---------|
| `WEBSITE_NAME` | IIS site name | `MyBlog` |
| `SERVER_COMPUTER_NAME` | Server hostname | `myserver.example.com` |
| `SERVER_USERNAME` | WebDeploy username | `deploy-user` |
| `SERVER_PASSWORD` | WebDeploy password | (your password) |

#### Repository Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `MYBLOG_ADMIN_PASSWORD` | Initial admin password | (strong password) |

> **Note**: `MYBLOG_ADMIN_PASSWORD` should be set as a **secret**, not a variable, if you want it to remain hidden in logs.

### Manual Deployment

```bash
# Publish for Windows
dotnet publish src/MyBlog.Web/MyBlog.Web.csproj -c Release -o ./publish -r win-x64

# Publish for Linux
dotnet publish src/MyBlog.Web/MyBlog.Web.csproj -c Release -o ./publish -r linux-x64
```

Copy the contents of `./publish` to your server.

### IIS Configuration

1. Install the [.NET 10 Hosting Bundle](https://dotnet.microsoft.com/download/dotnet/10.0)
2. Create a new IIS site pointing to your publish folder
3. Set the Application Pool to "No Managed Code"
4. Ensure the Application Pool identity has write access to the database directory

## Troubleshooting

### ERROR_FILE_IN_USE During Deployment

This occurs when the application is running and DLLs are locked.

**Solution**: The workflow now includes `-enableRule:AppOffline` which automatically:
1. Creates `app_offline.htm` to stop the application
2. Waits for the app to release file locks
3. Deploys the new files
4. Removes `app_offline.htm` to restart the app

### Password Not Changing After Setting MYBLOG_ADMIN_PASSWORD

The environment variable only works when **no users exist** in the database.

**To reset with a new password**:

1. Stop the application
2. Delete the database file (see Database Location above)
3. Set `MYBLOG_ADMIN_PASSWORD` to your desired password
4. Start the application

Or, log in with the current password and use `/admin/change-password`.

### Database Locked Errors

SQLite can have locking issues with concurrent access.

**Solutions**:
- Ensure only one instance of the application is running
- Check that no database tools have the file open
- Verify file permissions on the database directory

## Development

### Running Tests

```bash
cd src
dotnet test MyBlog.slnx
```

### Project Structure

```
src/
├── MyBlog.Core/           # Domain models and interfaces
├── MyBlog.Infrastructure/ # Data access, services
├── MyBlog.Web/           # Blazor Server application
└── MyBlog.Tests/         # xUnit test project
```

### Adding New Features

1. Define interfaces in `MyBlog.Core/Interfaces`
2. Implement in `MyBlog.Infrastructure/Services`
3. Add UI in `MyBlog.Web/Components/Pages`
4. Write tests in `MyBlog.Tests`

## API Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/images/{id}` | GET | Retrieve an image by ID |

## License

MIT License - see [LICENSE](LICENSE) for details.

## Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request
EOF

echo "      Done."

# =============================================================================
# Complete!
# =============================================================================
echo ""
echo "=============================================="
echo "  Upgrade Complete!"
echo "=============================================="
echo ""
echo "Changes made:"
echo "  ✓ Added ChangePasswordAsync to IAuthService"
echo "  ✓ Added UpdateAsync to IUserRepository"
echo "  ✓ Created /admin/change-password page"
echo "  ✓ Fixed deployment with AppOffline rule"
echo "  ✓ Generated password change test cases"
echo "  ✓ Created comprehensive README.md"
echo ""
echo "Next steps:"
echo ""
echo "  1. Rebuild the solution:"
echo "     cd $SRC_DIR && dotnet build MyBlog.slnx"
echo ""
echo "  2. Run tests:"
echo "     dotnet test MyBlog.slnx"
echo ""
echo "  3. Commit and push changes"
echo ""
echo "  4. After deployment, log in and visit:"
echo "     /admin/change-password"
echo ""
echo "=============================================="


===============================================================================
EXPORT COMPLETED: Sun Dec 28 01:12:20 PM CST 2025
Total Files Found: 63
Files Exported: 63
Files Skipped: 0 (binary or large files)
Output File: /home/kushal/src/dotnet/MyBlog/docs/llm/dump.txt
===============================================================================
