PROJECT STRUCTURE MAP:
src/MyBlog.Core/Constants/AppConstants.cs
src/MyBlog.Core/Interfaces/IAuthService.cs
src/MyBlog.Core/Interfaces/IImageRepository.cs
src/MyBlog.Core/Interfaces/IMarkdownService.cs
src/MyBlog.Core/Interfaces/IPasswordService.cs
src/MyBlog.Core/Interfaces/IPostRepository.cs
src/MyBlog.Core/Interfaces/ISlugService.cs
src/MyBlog.Core/Interfaces/ITelemetryLogRepository.cs
src/MyBlog.Core/Interfaces/IUserRepository.cs
src/MyBlog.Core/Interfaces/IReaderTrackingService.cs
src/MyBlog.Core/Models/Image.cs
src/MyBlog.Core/Models/Post.cs
src/MyBlog.Core/Models/PostDto.cs
src/MyBlog.Core/Models/TelemetryLog.cs
src/MyBlog.Core/Models/User.cs
src/MyBlog.Core/Services/MarkdownService.cs
src/MyBlog.Core/Services/SlugService.cs
src/MyBlog.Infrastructure/Data/BlogDbContext.cs
src/MyBlog.Infrastructure/Data/DatabasePathResolver.cs
src/MyBlog.Infrastructure/Repositories/ImageRepository.cs
src/MyBlog.Infrastructure/Repositories/PostRepository.cs
src/MyBlog.Infrastructure/Repositories/TelemetryLogRepository.cs
src/MyBlog.Infrastructure/Repositories/UserRepository.cs
src/MyBlog.Infrastructure/Services/AuthService.cs
src/MyBlog.Infrastructure/Services/PasswordService.cs
src/MyBlog.Infrastructure/Services/TelemetryCleanupService.cs
src/MyBlog.Infrastructure/Services/ReaderTrackingService.cs
src/MyBlog.Infrastructure/Telemetry/DatabaseLogExporter.cs
src/MyBlog.Infrastructure/Telemetry/FileLogExporter.cs
src/MyBlog.Infrastructure/Telemetry/TelemetryPathResolver.cs
src/MyBlog.Infrastructure/ServiceCollectionExtensions.cs
src/MyBlog.Tests/Integration/AuthServiceTests.cs
src/MyBlog.Tests/Integration/PasswordChangeTests.cs
src/MyBlog.Tests/Integration/PostRepositoryTests.cs
src/MyBlog.Tests/Integration/TelemetryCleanupTests.cs
src/MyBlog.Tests/Integration/AuthServiceLongPasswordTests.cs
src/MyBlog.Tests/Unit/LoginRateLimitMiddlewareTests.cs
src/MyBlog.Tests/Unit/MarkdownServiceTests.cs
src/MyBlog.Tests/Unit/PasswordServiceTests.cs
src/MyBlog.Tests/Unit/SlugServiceTests.cs
src/MyBlog.Web/Components/Layout/MainLayout.razor
src/MyBlog.Web/Components/Pages/AccessDenied.razor
src/MyBlog.Web/Components/Pages/Admin/ImageManager.razor
src/MyBlog.Web/Components/Pages/Admin/PostList.razor
src/MyBlog.Web/Components/Pages/Admin/PostEditor.razor
src/MyBlog.Web/Components/Pages/Admin/UserEditor.razor
src/MyBlog.Web/Components/Pages/Admin/UserList.razor
src/MyBlog.Web/Components/Pages/Admin/ChangePassword.razor
src/MyBlog.Web/Components/Pages/Admin/Dashboard.razor
src/MyBlog.Web/Components/Pages/Home.razor
src/MyBlog.Web/Components/Pages/Login.razor
src/MyBlog.Web/Components/Pages/PostDetail.razor
src/MyBlog.Web/Components/Pages/About.razor
src/MyBlog.Web/Components/Routes.razor
src/MyBlog.Web/Components/Shared/MarkdownRenderer.razor
src/MyBlog.Web/Components/Shared/Pagination.razor
src/MyBlog.Web/Components/Shared/PostCard.razor
src/MyBlog.Web/Components/Shared/RedirectToLogin.razor
src/MyBlog.Web/Components/Shared/Footer.razor
src/MyBlog.Web/Components/Shared/ReaderBadge.razor
src/MyBlog.Web/Components/_Imports.razor
src/MyBlog.Web/Components/App.razor
src/MyBlog.Web/Middleware/LoginRateLimitMiddleware.cs
src/MyBlog.Web/Program.cs



================================================================================
FILE PATH: src/MyBlog.Core/Constants/AppConstants.cs
================================================================================
namespace MyBlog.Core.Constants;

/// <summary>
/// Application-wide constants.
/// </summary>
public static class AppConstants
{
    /// <summary>The name of the authentication cookie.</summary>
    public const string AuthCookieName = "MyBlog.Auth";

    /// <summary>The admin role claim value.</summary>
    public const string AdminRole = "Admin";

    /// <summary>Default page size for listings.</summary>
    public const int DefaultPageSize = 10;

    /// <summary>Maximum image size in bytes (5MB).</summary>
    public const int MaxImageSizeBytes = 5 * 1024 * 1024;

    /// <summary>Allowed image content types.</summary>
    public static readonly string[] AllowedImageTypes =
        ["image/jpeg", "image/png", "image/gif", "image/webp"];
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Interfaces/IAuthService.cs
================================================================================
using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for authentication operations.
/// </summary>
public interface IAuthService
{
    /// <summary>Attempts to authenticate a user.</summary>
    Task<User?> AuthenticateAsync(
        string username, string password, CancellationToken cancellationToken = default);

    /// <summary>Ensures the default admin user exists.</summary>
    Task EnsureAdminUserAsync(CancellationToken cancellationToken = default);

    /// <summary>Changes a user's password.</summary>
    /// <returns>True if password was changed, false if current password was incorrect.</returns>
    Task<bool> ChangePasswordAsync(
        Guid userId,
        string currentPassword,
        string newPassword,
        CancellationToken cancellationToken = default);

    /// <summary>Resets a user's password without requiring the current password (admin function).</summary>
    Task ResetPasswordAsync(
        Guid userId,
        string newPassword,
        CancellationToken cancellationToken = default);
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Interfaces/IImageRepository.cs
================================================================================
using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for image operations.
/// </summary>
public interface IImageRepository
{
    /// <summary>Gets all images.</summary>
    Task<IReadOnlyList<Image>> GetAllAsync(CancellationToken cancellationToken = default);

    /// <summary>Gets an image by ID.</summary>
    Task<Image?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Creates a new image.</summary>
    Task<Image> CreateAsync(Image image, CancellationToken cancellationToken = default);

    /// <summary>Deletes an image by ID.</summary>
    Task DeleteAsync(Guid id, CancellationToken cancellationToken = default);
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Interfaces/IMarkdownService.cs
================================================================================
namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for rendering Markdown to HTML.
/// </summary>
public interface IMarkdownService
{
    /// <summary>Converts Markdown text to HTML.</summary>
    string ToHtml(string markdown);
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Interfaces/IPasswordService.cs
================================================================================
namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for password hashing and verification.
/// </summary>
public interface IPasswordService
{
    /// <summary>Hashes a plain text password.</summary>
    string HashPassword(string password);

    /// <summary>Verifies a password against a hash.</summary>
    bool VerifyPassword(string hashedPassword, string providedPassword);
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Interfaces/IPostRepository.cs
================================================================================
using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for post operations.
/// </summary>
public interface IPostRepository
{
    /// <summary>Gets a paginated list of published posts.</summary>
    Task<(IReadOnlyList<PostListItemDto> Posts, int TotalCount)> GetPublishedPostsAsync(
        int page, int pageSize, CancellationToken cancellationToken = default);

    /// <summary>Gets all posts for admin view.</summary>
    Task<IReadOnlyList<PostListItemDto>> GetAllPostsAsync(
        CancellationToken cancellationToken = default);

    /// <summary>Gets a post by its slug.</summary>
    Task<PostDetailDto?> GetBySlugAsync(string slug, CancellationToken cancellationToken = default);

    /// <summary>Gets a post by its ID.</summary>
    Task<Post?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Creates a new post.</summary>
    Task<Post> CreateAsync(Post post, CancellationToken cancellationToken = default);

    /// <summary>Updates an existing post.</summary>
    Task UpdateAsync(Post post, CancellationToken cancellationToken = default);

    /// <summary>Deletes a post by ID.</summary>
    Task DeleteAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Gets the total count of posts.</summary>
    Task<int> GetCountAsync(CancellationToken cancellationToken = default);

    /// <summary>Gets recent posts for dashboard.</summary>
    Task<IReadOnlyList<PostListItemDto>> GetRecentPostsAsync(
        int count, CancellationToken cancellationToken = default);

    /// <summary>Checks if a slug is already in use by another post.</summary>
    Task<bool> IsSlugTakenAsync(string slug, Guid? excludePostId = null, CancellationToken cancellationToken = default);
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Interfaces/ISlugService.cs
================================================================================
namespace MyBlog.Core.Interfaces;

/// <summary>
/// Service interface for generating URL-friendly slugs.
/// </summary>
public interface ISlugService
{
    /// <summary>Generates a slug from a title.</summary>
    string GenerateSlug(string title);
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Interfaces/ITelemetryLogRepository.cs
================================================================================
using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for telemetry log operations.
/// </summary>
public interface ITelemetryLogRepository
{
    /// <summary>Writes a log entry to the database.</summary>
    Task WriteAsync(TelemetryLog log, CancellationToken cancellationToken = default);

    /// <summary>Deletes logs older than the specified date.</summary>
    Task<int> DeleteOlderThanAsync(DateTime cutoffUtc, CancellationToken cancellationToken = default);

    /// <summary>Gets recent logs for viewing.</summary>
    Task<IReadOnlyList<TelemetryLog>> GetRecentAsync(
        int count, CancellationToken cancellationToken = default);
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Interfaces/IUserRepository.cs
================================================================================
using MyBlog.Core.Models;

namespace MyBlog.Core.Interfaces;

/// <summary>
/// Repository interface for user data access.
/// </summary>
public interface IUserRepository
{
    /// <summary>Gets a user by ID.</summary>
    Task<User?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>Gets a user by username.</summary>
    Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default);

    /// <summary>Gets all users.</summary>
    Task<IReadOnlyList<User>> GetAllAsync(CancellationToken cancellationToken = default);

    /// <summary>Checks if any users exist.</summary>
    Task<bool> AnyUsersExistAsync(CancellationToken cancellationToken = default);

    /// <summary>Creates a new user.</summary>
    Task CreateAsync(User user, CancellationToken cancellationToken = default);

    /// <summary>Updates an existing user.</summary>
    Task UpdateAsync(User user, CancellationToken cancellationToken = default);

    /// <summary>Deletes a user by ID.</summary>
    Task DeleteAsync(Guid id, CancellationToken cancellationToken = default);
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Interfaces/IReaderTrackingService.cs
================================================================================
namespace MyBlog.Core.Interfaces;

public interface IReaderTrackingService
{
    // Called when a user opens a post
    void JoinPost(string slug);

    // Called when a user leaves (closes tab/navigates away)
    void LeavePost(string slug);

    // Gets the current count
    int GetReaderCount(string slug);

    // Event that fires when the count changes
    event Action<string, int>? OnCountChanged;
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Models/Image.cs
================================================================================
namespace MyBlog.Core.Models;

/// <summary>
/// Represents an image stored as a BLOB in the database.
/// </summary>
public sealed class Image
{
    /// <summary>Gets or sets the unique identifier for the image.</summary>
    public Guid Id { get; set; }

    /// <summary>Gets or sets the original file name.</summary>
    public required string FileName { get; set; }

    /// <summary>Gets or sets the MIME content type.</summary>
    public required string ContentType { get; set; }

    /// <summary>Gets or sets the binary image data.</summary>
    public required byte[] Data { get; set; }

    /// <summary>Gets or sets the associated post ID (optional).</summary>
    public Guid? PostId { get; set; }

    /// <summary>Gets or sets when the image was uploaded.</summary>
    public DateTime UploadedAtUtc { get; set; }

    /// <summary>Gets or sets the ID of the user who uploaded the image.</summary>
    public Guid UploadedByUserId { get; set; }

    /// <summary>Navigation property for the associated post.</summary>
    public Post? Post { get; set; }

    /// <summary>Navigation property for the uploader.</summary>
    public User? UploadedBy { get; set; }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Models/Post.cs
================================================================================
namespace MyBlog.Core.Models;

/// <summary>
/// Represents a blog post with Markdown content.
/// </summary>
public sealed class Post
{
    /// <summary>Gets or sets the unique identifier for the post.</summary>
    public Guid Id { get; set; }

    /// <summary>Gets or sets the post title.</summary>
    public required string Title { get; set; }

    /// <summary>Gets or sets the URL-friendly slug.</summary>
    public required string Slug { get; set; }

    /// <summary>Gets or sets the Markdown content of the post.</summary>
    public required string Content { get; set; }

    /// <summary>Gets or sets a brief summary for listings.</summary>
    public required string Summary { get; set; }

    /// <summary>Gets or sets the author's user ID.</summary>
    public Guid AuthorId { get; set; }

    /// <summary>Gets or sets when the post was created.</summary>
    public DateTime CreatedAtUtc { get; set; }

    /// <summary>Gets or sets when the post was last updated.</summary>
    public DateTime UpdatedAtUtc { get; set; }

    /// <summary>Gets or sets when the post was published (null if draft).</summary>
    public DateTime? PublishedAtUtc { get; set; }

    /// <summary>Gets or sets whether the post is publicly visible.</summary>
    public bool IsPublished { get; set; }

    /// <summary>Navigation property for the author.</summary>
    public User? Author { get; set; }

    /// <summary>Navigation property for attached images.</summary>
    public ICollection<Image> Images { get; set; } = [];
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Models/PostDto.cs
================================================================================
namespace MyBlog.Core.Models;

/// <summary>Data transfer object for post listings.</summary>
public sealed record PostListItemDto(
    Guid Id,
    string Title,
    string Slug,
    string Summary,
    string AuthorDisplayName,
    DateTime? PublishedAtUtc,
    bool IsPublished);

/// <summary>Data transfer object for creating a new post.</summary>
public sealed record CreatePostDto(
    string Title,
    string Content,
    string Summary,
    bool IsPublished);

/// <summary>Data transfer object for updating a post.</summary>
public sealed record UpdatePostDto(
    string Title,
    string Content,
    string Summary,
    bool IsPublished);

/// <summary>Data transfer object for post details.</summary>
public sealed record PostDetailDto(
    Guid Id,
    string Title,
    string Slug,
    string Content,
    string Summary,
    string AuthorDisplayName,
    DateTime CreatedAtUtc,
    DateTime UpdatedAtUtc,
    DateTime? PublishedAtUtc,
    bool IsPublished);


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Models/TelemetryLog.cs
================================================================================
namespace MyBlog.Core.Models;

/// <summary>
/// Represents a telemetry log entry stored in the database.
/// </summary>
public sealed class TelemetryLog
{
    /// <summary>Gets or sets the auto-increment primary key.</summary>
    public int Id { get; set; }

    /// <summary>Gets or sets the UTC timestamp of the log entry.</summary>
    public DateTime TimestampUtc { get; set; }

    /// <summary>Gets or sets the log level (Information, Warning, Error, etc.).</summary>
    public required string Level { get; set; }

    /// <summary>Gets or sets the category/source of the log.</summary>
    public required string Category { get; set; }

    /// <summary>Gets or sets the log message.</summary>
    public required string Message { get; set; }

    /// <summary>Gets or sets the exception details if any.</summary>
    public string? Exception { get; set; }

    /// <summary>Gets or sets the distributed trace ID.</summary>
    public string? TraceId { get; set; }

    /// <summary>Gets or sets the span ID within the trace.</summary>
    public string? SpanId { get; set; }

    /// <summary>Gets or sets additional properties as JSON.</summary>
    public string? Properties { get; set; }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Models/User.cs
================================================================================
namespace MyBlog.Core.Models;

/// <summary>
/// Represents a user who can create and manage blog posts.
/// </summary>
public sealed class User
{
    /// <summary>Gets or sets the unique identifier for the user.</summary>
    public Guid Id { get; set; }

    /// <summary>Gets or sets the unique username for authentication.</summary>
    public required string Username { get; set; }

    /// <summary>Gets or sets the hashed password.</summary>
    public required string PasswordHash { get; set; }

    /// <summary>Gets or sets the user's email address.</summary>
    public required string Email { get; set; }

    /// <summary>Gets or sets the display name shown on posts.</summary>
    public required string DisplayName { get; set; }

    /// <summary>Gets or sets when the user account was created.</summary>
    public DateTime CreatedAtUtc { get; set; }

    /// <summary>Navigation property for posts authored by this user.</summary>
    public ICollection<Post> Posts { get; set; } = [];

    /// <summary>Navigation property for images uploaded by this user.</summary>
    public ICollection<Image> UploadedImages { get; set; } = [];
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Services/MarkdownService.cs
================================================================================
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using MyBlog.Core.Interfaces;

namespace MyBlog.Core.Services;

/// <summary>
/// Custom Markdown to HTML renderer.
/// Supports: headings, bold, italic, links, images, code blocks, blockquotes,
/// unordered lists, ordered lists, horizontal rules.
/// </summary>
public sealed partial class MarkdownService : IMarkdownService
{
    private enum ListType { None, Unordered, Ordered }

    /// <inheritdoc />
    public string ToHtml(string markdown)
    {
        if (string.IsNullOrWhiteSpace(markdown))
        {
            return string.Empty;
        }

        var lines = markdown.Replace("\r\n", "\n").Split('\n');
        var result = new StringBuilder();
        var inCodeBlock = false;
        var currentListType = ListType.None;
        var codeBlockContent = new StringBuilder();

        foreach (var rawLine in lines)
        {
            var line = rawLine;

            // Handle fenced code blocks
            if (line.StartsWith("```"))
            {
                if (inCodeBlock)
                {
                    result.Append("<pre><code>");
                    result.Append(HttpUtility.HtmlEncode(codeBlockContent.ToString().TrimEnd()));
                    result.AppendLine("</code></pre>");
                    codeBlockContent.Clear();
                    inCodeBlock = false;
                }
                else
                {
                    result.Append(CloseList(ref currentListType));
                    inCodeBlock = true;
                }
                continue;
            }

            if (inCodeBlock)
            {
                codeBlockContent.AppendLine(line);
                continue;
            }

            // Handle horizontal rules
            if (HorizontalRulePattern().IsMatch(line))
            {
                result.Append(CloseList(ref currentListType));
                result.AppendLine("<hr />");
                continue;
            }

            // Handle headings
            var headingMatch = HeadingPattern().Match(line);
            if (headingMatch.Success)
            {
                result.Append(CloseList(ref currentListType));
                var level = headingMatch.Groups[1].Value.Length;
                var headingText = ProcessInline(headingMatch.Groups[2].Value);
                result.AppendLine($"<h{level}>{headingText}</h{level}>");
                continue;
            }

            // Handle blockquotes
            if (line.StartsWith("> "))
            {
                result.Append(CloseList(ref currentListType));
                var quoteText = ProcessInline(line[2..]);
                result.AppendLine($"<blockquote><p>{quoteText}</p></blockquote>");
                continue;
            }

            // Handle unordered list items (- or *)
            var unorderedMatch = UnorderedListPattern().Match(line);
            if (unorderedMatch.Success)
            {
                if (currentListType != ListType.Unordered)
                {
                    result.Append(CloseList(ref currentListType));
                    result.AppendLine("<ul>");
                    currentListType = ListType.Unordered;
                }
                var itemText = ProcessInline(unorderedMatch.Groups[1].Value);
                result.AppendLine($"<li>{itemText}</li>");
                continue;
            }

            // Handle ordered list items (1. 2. 3. etc.)
            var orderedMatch = OrderedListPattern().Match(line);
            if (orderedMatch.Success)
            {
                if (currentListType != ListType.Ordered)
                {
                    result.Append(CloseList(ref currentListType));
                    result.AppendLine("<ol>");
                    currentListType = ListType.Ordered;
                }
                var itemText = ProcessInline(orderedMatch.Groups[1].Value);
                result.AppendLine($"<li>{itemText}</li>");
                continue;
            }

            // Close list if no longer in list item
            if (currentListType != ListType.None && !string.IsNullOrWhiteSpace(line))
            {
                result.Append(CloseList(ref currentListType));
            }

            // Handle empty lines
            if (string.IsNullOrWhiteSpace(line))
            {
                result.Append(CloseList(ref currentListType));
                continue;
            }

            // Regular paragraph
            var paragraphText = ProcessInline(line);
            result.AppendLine($"<p>{paragraphText}</p>");
        }

        // Close any open list
        result.Append(CloseList(ref currentListType));

        // Close any unclosed code block
        if (inCodeBlock)
        {
            result.Append("<pre><code>");
            result.Append(HttpUtility.HtmlEncode(codeBlockContent.ToString().TrimEnd()));
            result.AppendLine("</code></pre>");
        }

        return result.ToString();
    }

    private static string CloseList(ref ListType listType)
    {
        var result = listType switch
        {
            ListType.Unordered => "</ul>\n",
            ListType.Ordered => "</ol>\n",
            _ => ""
        };
        listType = ListType.None;
        return result;
    }

    private static string ProcessInline(string text)
    {
        // Escape HTML first
        text = HttpUtility.HtmlEncode(text);

        // Process inline code (must be before bold/italic to avoid conflicts)
        text = InlineCodePattern().Replace(text, "<code>$1</code>");

        // Process images ![alt](url)
        text = ImagePattern().Replace(text, "<img src=\"$2\" alt=\"$1\" />");

        // Process links [text](url)
        text = LinkPattern().Replace(text, "<a href=\"$2\">$1</a>");

        // Process bold **text** or __text__
        text = BoldPattern().Replace(text, "<strong>$1</strong>");

        // Process italic *text* or _text_
        text = ItalicPattern().Replace(text, "<em>$1</em>");

        return text;
    }

    [GeneratedRegex(@"^(#{1,6})\s+(.+)$")]
    private static partial Regex HeadingPattern();

    [GeneratedRegex(@"^[-*]\s+(.+)$")]
    private static partial Regex UnorderedListPattern();

    [GeneratedRegex(@"^\d+\.\s+(.+)$")]
    private static partial Regex OrderedListPattern();

    [GeneratedRegex(@"^[-*_]{3,}\s*$")]
    private static partial Regex HorizontalRulePattern();

    [GeneratedRegex(@"`([^`]+)`")]
    private static partial Regex InlineCodePattern();

    [GeneratedRegex(@"!\[([^\]]*)\]\(([^)]+)\)")]
    private static partial Regex ImagePattern();

    [GeneratedRegex(@"\[([^\]]+)\]\(([^)]+)\)")]
    private static partial Regex LinkPattern();

    [GeneratedRegex(@"\*\*([^*]+)\*\*|__([^_]+)__")]
    private static partial Regex BoldPattern();

    [GeneratedRegex(@"(?<!\*)\*(?!\*)([^*]+)(?<!\*)\*(?!\*)|(?<!_)_(?!_)([^_]+)(?<!_)_(?!_)")]
    private static partial Regex ItalicPattern();
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Core/Services/SlugService.cs
================================================================================
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using MyBlog.Core.Interfaces;

namespace MyBlog.Core.Services;

/// <summary>
/// Generates URL-friendly slugs from text.
/// </summary>
public sealed partial class SlugService : ISlugService
{
    /// <inheritdoc />
    public string GenerateSlug(string title)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(title);

        // Normalize unicode and convert to lowercase
        var normalized = title.Normalize(NormalizationForm.FormD);
        var sb = new StringBuilder();

        foreach (var c in normalized)
        {
            var category = CharUnicodeInfo.GetUnicodeCategory(c);
            if (category != UnicodeCategory.NonSpacingMark)
            {
                sb.Append(c);
            }
        }

        var result = sb.ToString().Normalize(NormalizationForm.FormC).ToLowerInvariant();

        // Replace spaces and underscores with hyphens
        result = SpacePattern().Replace(result, "-");

        // Remove all non-alphanumeric characters except hyphens
        result = NonAlphanumericPattern().Replace(result, "");

        // Replace multiple hyphens with single hyphen
        result = MultipleHyphenPattern().Replace(result, "-");

        // Trim hyphens from ends
        result = result.Trim('-');

        return result;
    }

    [GeneratedRegex(@"[\s_]+")]
    private static partial Regex SpacePattern();

    [GeneratedRegex(@"[^a-z0-9\-]")]
    private static partial Regex NonAlphanumericPattern();

    [GeneratedRegex(@"-+")]
    private static partial Regex MultipleHyphenPattern();
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Data/BlogDbContext.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Data;

/// <summary>
/// Entity Framework Core database context for the blog.
/// </summary>
public sealed class BlogDbContext : DbContext
{
    /// <summary>Initializes a new instance of the BlogDbContext.</summary>
    public BlogDbContext(DbContextOptions<BlogDbContext> options) : base(options)
    {
    }

    /// <summary>Gets or sets the Users table.</summary>
    public DbSet<User> Users => Set<User>();

    /// <summary>Gets or sets the Posts table.</summary>
    public DbSet<Post> Posts => Set<Post>();

    /// <summary>Gets or sets the Images table.</summary>
    public DbSet<Image> Images => Set<Image>();

    /// <summary>Gets or sets the TelemetryLogs table.</summary>
    public DbSet<TelemetryLog> TelemetryLogs => Set<TelemetryLog>();

    /// <inheritdoc />
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // User configuration
        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Username).HasMaxLength(50).IsRequired();
            entity.HasIndex(e => e.Username).IsUnique();
            entity.Property(e => e.PasswordHash).HasMaxLength(256).IsRequired();
            entity.Property(e => e.Email).HasMaxLength(256).IsRequired();
            entity.Property(e => e.DisplayName).HasMaxLength(100).IsRequired();
        });

        // Post configuration
        modelBuilder.Entity<Post>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Title).HasMaxLength(200).IsRequired();
            entity.Property(e => e.Slug).HasMaxLength(200).IsRequired();
            entity.HasIndex(e => e.Slug).IsUnique();
            entity.Property(e => e.Summary).HasMaxLength(500).IsRequired();
            entity.HasOne(e => e.Author)
                .WithMany(u => u.Posts)
                .HasForeignKey(e => e.AuthorId)
                .OnDelete(DeleteBehavior.Restrict);
        });

        // Image configuration
        modelBuilder.Entity<Image>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.FileName).HasMaxLength(256).IsRequired();
            entity.Property(e => e.ContentType).HasMaxLength(100).IsRequired();
            entity.HasOne(e => e.Post)
                .WithMany(p => p.Images)
                .HasForeignKey(e => e.PostId)
                .OnDelete(DeleteBehavior.SetNull);
            entity.HasOne(e => e.UploadedBy)
                .WithMany(u => u.UploadedImages)
                .HasForeignKey(e => e.UploadedByUserId)
                .OnDelete(DeleteBehavior.Restrict);
        });

        // TelemetryLog configuration
        modelBuilder.Entity<TelemetryLog>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Id).ValueGeneratedOnAdd();
            entity.Property(e => e.Level).HasMaxLength(20).IsRequired();
            entity.Property(e => e.Category).HasMaxLength(256).IsRequired();
            entity.HasIndex(e => e.TimestampUtc);
        });
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Data/DatabasePathResolver.cs
================================================================================
namespace MyBlog.Infrastructure.Data;

/// <summary>
/// Resolves the database file path following XDG conventions.
/// </summary>
public static class DatabasePathResolver
{
    /// <summary>
    /// Gets the path for the SQLite database file.
    /// Priority: XDG_DATA_HOME > Platform-specific > Local fallback
    /// </summary>
    public static string GetDatabasePath()
    {
        var dataDir = GetDataDirectory();
        Directory.CreateDirectory(dataDir);
        return Path.Combine(dataDir, "myblog.db");
    }

    /// <summary>
    /// Gets the data directory following platform conventions.
    /// </summary>
    public static string GetDataDirectory()
    {
        string baseDir;

        if (OperatingSystem.IsWindows())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        }
        else if (OperatingSystem.IsMacOS())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        }
        else
        {
            // Linux/Unix: Use XDG_DATA_HOME or fallback
            var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
            baseDir = !string.IsNullOrEmpty(xdgDataHome)
                ? xdgDataHome
                : Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".local", "share");
        }

        // If we can't write to the preferred location, use local directory
        var preferredDir = Path.Combine(baseDir, "MyBlog");
        try
        {
            Directory.CreateDirectory(preferredDir);
            var testFile = Path.Combine(preferredDir, ".write-test");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return preferredDir;
        }
        catch
        {
            // Fallback to local directory
            return Path.Combine(AppContext.BaseDirectory, "data");
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Repositories/ImageRepository.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the image repository.
/// </summary>
public sealed class ImageRepository : IImageRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of ImageRepository.</summary>
    public ImageRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<Image>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _context.Images
            .AsNoTracking()
            .OrderByDescending(i => i.UploadedAtUtc)
            .ToListAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Image?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.Images.FindAsync([id], cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Image> CreateAsync(Image image, CancellationToken cancellationToken = default)
    {
        _context.Images.Add(image);
        await _context.SaveChangesAsync(cancellationToken);
        return image;
    }

    /// <inheritdoc />
    public async Task DeleteAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var image = await _context.Images.FindAsync([id], cancellationToken);
        if (image is not null)
        {
            _context.Images.Remove(image);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Repositories/PostRepository.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the post repository.
/// </summary>
public sealed class PostRepository : IPostRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of PostRepository.</summary>
    public PostRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task<(IReadOnlyList<PostListItemDto> Posts, int TotalCount)> GetPublishedPostsAsync(
        int page, int pageSize, CancellationToken cancellationToken = default)
    {
        var query = _context.Posts
            .AsNoTracking()
            .Where(p => p.IsPublished)
            .OrderByDescending(p => p.PublishedAtUtc);

        var totalCount = await query.CountAsync(cancellationToken);

        var posts = await query
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .Include(p => p.Author)
            .Select(p => new PostListItemDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Summary,
                p.Author!.DisplayName,
                p.PublishedAtUtc,
                p.IsPublished))
            .ToListAsync(cancellationToken);

        return (posts, totalCount);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<PostListItemDto>> GetAllPostsAsync(
        CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .AsNoTracking()
            .OrderByDescending(p => p.UpdatedAtUtc)
            .Include(p => p.Author)
            .Select(p => new PostListItemDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Summary,
                p.Author!.DisplayName,
                p.PublishedAtUtc,
                p.IsPublished))
            .ToListAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<PostDetailDto?> GetBySlugAsync(
        string slug, CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .AsNoTracking()
            .Where(p => p.Slug == slug)
            .Include(p => p.Author)
            .Select(p => new PostDetailDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Content,
                p.Summary,
                p.Author!.DisplayName,
                p.CreatedAtUtc,
                p.UpdatedAtUtc,
                p.PublishedAtUtc,
                p.IsPublished))
            .FirstOrDefaultAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Post?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .Include(p => p.Author)
            .FirstOrDefaultAsync(p => p.Id == id, cancellationToken);
    }

    /// <inheritdoc />
    public async Task<Post> CreateAsync(Post post, CancellationToken cancellationToken = default)
    {
        _context.Posts.Add(post);
        await _context.SaveChangesAsync(cancellationToken);
        return post;
    }

    /// <inheritdoc />
    public async Task UpdateAsync(Post post, CancellationToken cancellationToken = default)
    {
        _context.Posts.Update(post);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task DeleteAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var post = await _context.Posts.FindAsync([id], cancellationToken);
        if (post is not null)
        {
            _context.Posts.Remove(post);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }

    /// <inheritdoc />
    public async Task<int> GetCountAsync(CancellationToken cancellationToken = default)
    {
        return await _context.Posts.CountAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<PostListItemDto>> GetRecentPostsAsync(
        int count, CancellationToken cancellationToken = default)
    {
        return await _context.Posts
            .AsNoTracking()
            .OrderByDescending(p => p.UpdatedAtUtc)
            .Take(count)
            .Include(p => p.Author)
            .Select(p => new PostListItemDto(
                p.Id,
                p.Title,
                p.Slug,
                p.Summary,
                p.Author!.DisplayName,
                p.PublishedAtUtc,
                p.IsPublished))
            .ToListAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<bool> IsSlugTakenAsync(string slug, Guid? excludePostId = null, CancellationToken cancellationToken = default)
    {
        if (excludePostId.HasValue)
        {
            return await _context.Posts
                .AnyAsync(p => p.Slug == slug && p.Id != excludePostId.Value, cancellationToken);
        }

        return await _context.Posts
            .AnyAsync(p => p.Slug == slug, cancellationToken);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Repositories/TelemetryLogRepository.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// EF Core implementation of the telemetry log repository.
/// </summary>
public sealed class TelemetryLogRepository : ITelemetryLogRepository
{
    private readonly BlogDbContext _context;

    /// <summary>Initializes a new instance of TelemetryLogRepository.</summary>
    public TelemetryLogRepository(BlogDbContext context)
    {
        _context = context;
    }

    /// <inheritdoc />
    public async Task WriteAsync(TelemetryLog log, CancellationToken cancellationToken = default)
    {
        _context.TelemetryLogs.Add(log);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<int> DeleteOlderThanAsync(
        DateTime cutoffUtc, CancellationToken cancellationToken = default)
    {
        return await _context.TelemetryLogs
            .Where(l => l.TimestampUtc < cutoffUtc)
            .ExecuteDeleteAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<TelemetryLog>> GetRecentAsync(
        int count, CancellationToken cancellationToken = default)
    {
        return await _context.TelemetryLogs
            .AsNoTracking()
            .OrderByDescending(l => l.TimestampUtc)
            .Take(count)
            .ToListAsync(cancellationToken);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Repositories/UserRepository.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;

namespace MyBlog.Infrastructure.Repositories;

/// <summary>
/// SQLite implementation of the user repository.
/// </summary>
public sealed class UserRepository : IUserRepository
{
    private readonly BlogDbContext _context;

    public UserRepository(BlogDbContext context) => _context = context;

    /// <inheritdoc />
    public async Task<User?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
        => await _context.Users.FirstOrDefaultAsync(u => u.Id == id, cancellationToken);

    /// <inheritdoc />
    public async Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default)
        => await _context.Users.FirstOrDefaultAsync(
            u => u.Username.ToLower() == username.ToLower(), cancellationToken);

    /// <inheritdoc />
    public async Task<IReadOnlyList<User>> GetAllAsync(CancellationToken cancellationToken = default)
        => await _context.Users.OrderBy(u => u.Username).ToListAsync(cancellationToken);

    /// <inheritdoc />
    public async Task<bool> AnyUsersExistAsync(CancellationToken cancellationToken = default)
        => await _context.Users.AnyAsync(cancellationToken);

    /// <inheritdoc />
    public async Task CreateAsync(User user, CancellationToken cancellationToken = default)
    {
        _context.Users.Add(user);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task UpdateAsync(User user, CancellationToken cancellationToken = default)
    {
        _context.Users.Update(user);
        await _context.SaveChangesAsync(cancellationToken);
    }

    /// <inheritdoc />
    public async Task DeleteAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var user = await _context.Users.FindAsync([id], cancellationToken);
        if (user is not null)
        {
            _context.Users.Remove(user);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Services/AuthService.cs
================================================================================
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Authentication service implementation.
/// </summary>
public sealed class AuthService : IAuthService
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordService _passwordService;
    private readonly IConfiguration _configuration;

    /// <summary>Initializes a new instance of AuthService.</summary>
    public AuthService(
        IUserRepository userRepository,
        IPasswordService passwordService,
        IConfiguration configuration)
    {
        _userRepository = userRepository;
        _passwordService = passwordService;
        _configuration = configuration;
    }

    /// <inheritdoc />
    public async Task<User?> AuthenticateAsync(
        string username, string password, CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByUsernameAsync(username, cancellationToken);
        if (user is null)
        {
            return null;
        }

        return _passwordService.VerifyPassword(user.PasswordHash, password) ? user : null;
    }

    /// <inheritdoc />
    public async Task EnsureAdminUserAsync(CancellationToken cancellationToken = default)
    {
        if (await _userRepository.AnyUsersExistAsync(cancellationToken))
        {
            return;
        }

        var defaultPassword = Environment.GetEnvironmentVariable("MYBLOG_ADMIN_PASSWORD")
            ?? _configuration["Authentication:DefaultAdminPassword"]
            ?? "ChangeMe123!";

        var admin = new User
        {
            Id = Guid.NewGuid(),
            Username = "admin",
            PasswordHash = _passwordService.HashPassword(defaultPassword),
            Email = "admin@localhost",
            DisplayName = "Administrator",
            CreatedAtUtc = DateTime.UtcNow
        };

        await _userRepository.CreateAsync(admin, cancellationToken);
    }

    /// <inheritdoc />
    public async Task<bool> ChangePasswordAsync(
        Guid userId,
        string currentPassword,
        string newPassword,
        CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
        if (user is null)
        {
            return false;
        }

        // Verify current password
        if (!_passwordService.VerifyPassword(user.PasswordHash, currentPassword))
        {
            return false;
        }

        // Update to new password
        user.PasswordHash = _passwordService.HashPassword(newPassword);
        await _userRepository.UpdateAsync(user, cancellationToken);

        return true;
    }

    /// <inheritdoc />
    public async Task ResetPasswordAsync(
        Guid userId,
        string newPassword,
        CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
        if (user is null)
        {
            throw new InvalidOperationException($"User with ID {userId} not found.");
        }

        user.PasswordHash = _passwordService.HashPassword(newPassword);
        await _userRepository.UpdateAsync(user, cancellationToken);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Services/PasswordService.cs
================================================================================
using Microsoft.AspNetCore.Identity;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Models;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Password hashing service using ASP.NET Core Identity's PasswordHasher.
/// </summary>
public sealed class PasswordService : IPasswordService
{
    private readonly PasswordHasher<User> _hasher = new();

    /// <inheritdoc />
    public string HashPassword(string password)
    {
        return _hasher.HashPassword(null!, password);
    }

    /// <inheritdoc />
    public bool VerifyPassword(string hashedPassword, string providedPassword)
    {
        var result = _hasher.VerifyHashedPassword(null!, hashedPassword, providedPassword);
        return result == PasswordVerificationResult.Success ||
               result == PasswordVerificationResult.SuccessRehashNeeded;
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Services/TelemetryCleanupService.cs
================================================================================
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using MyBlog.Core.Interfaces;

namespace MyBlog.Infrastructure.Services;

/// <summary>
/// Background service that cleans up old telemetry logs.
/// </summary>
public sealed class TelemetryCleanupService : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<TelemetryCleanupService> _logger;
    private readonly int _retentionDays;

    /// <summary>Initializes a new instance of TelemetryCleanupService.</summary>
    public TelemetryCleanupService(
        IServiceScopeFactory scopeFactory,
        IConfiguration configuration,
        ILogger<TelemetryCleanupService> logger)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
        _retentionDays = configuration.GetValue("Telemetry:RetentionDays", 30);
    }

    /// <inheritdoc />
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Run cleanup immediately on startup
        await CleanupAsync(stoppingToken);

        // Then run daily
        using var timer = new PeriodicTimer(TimeSpan.FromDays(1));
        while (await timer.WaitForNextTickAsync(stoppingToken))
        {
            await CleanupAsync(stoppingToken);
        }
    }

    private async Task CleanupAsync(CancellationToken cancellationToken)
    {
        try
        {
            using var scope = _scopeFactory.CreateScope();
            var repository = scope.ServiceProvider.GetRequiredService<ITelemetryLogRepository>();

            var cutoff = DateTime.UtcNow.AddDays(-_retentionDays);
            var deleted = await repository.DeleteOlderThanAsync(cutoff, cancellationToken);

            if (deleted > 0)
            {
                _logger.LogInformation(
                    "Telemetry cleanup: deleted {Count} logs older than {Days} days",
                    deleted, _retentionDays);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during telemetry cleanup");
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Services/ReaderTrackingService.cs
================================================================================
using System.Collections.Concurrent;
using MyBlog.Core.Interfaces;

namespace MyBlog.Infrastructure.Services;

public class ReaderTrackingService : IReaderTrackingService
{
    // Thread-safe dictionary to store counts: Slug -> Count
    private readonly ConcurrentDictionary<string, int> _activeReaders = new();

    public event Action<string, int>? OnCountChanged;

    public void JoinPost(string slug)
    {
        // Atomically increment the count
        var newCount = _activeReaders.AddOrUpdate(slug, 1, (_, count) => count + 1);

        // Notify subscribers
        OnCountChanged?.Invoke(slug, newCount);
    }

    public void LeavePost(string slug)
    {
        // Atomically decrement the count
        var newCount = _activeReaders.AddOrUpdate(slug, 0, (_, count) => count > 0 ? count - 1 : 0);

        // If count is 0, we could remove the key, but keeping it is harmless for small blogs
        if (newCount == 0)
        {
            _activeReaders.TryRemove(slug, out _);
        }

        // Notify subscribers
        OnCountChanged?.Invoke(slug, newCount);
    }

    public int GetReaderCount(string slug)
    {
        return _activeReaders.TryGetValue(slug, out var count) ? count : 0;
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Telemetry/DatabaseLogExporter.cs
================================================================================
using System.Text.Json;
using Microsoft.Extensions.DependencyInjection;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyBlog.Infrastructure.Telemetry;

/// <summary>
/// OpenTelemetry log exporter that writes to SQLite database.
/// </summary>
public sealed class DatabaseLogExporter : BaseExporter<LogRecord>
{
    private readonly IServiceScopeFactory _scopeFactory;

    /// <summary>Initializes a new instance of DatabaseLogExporter.</summary>
    public DatabaseLogExporter(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }

    /// <inheritdoc />
    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        try
        {
            using var scope = _scopeFactory.CreateScope();
            var context = scope.ServiceProvider.GetRequiredService<BlogDbContext>();

            foreach (var record in batch)
            {
                var log = new TelemetryLog
                {
                    TimestampUtc = record.Timestamp.ToUniversalTime(),
                    Level = record.LogLevel.ToString(),
                    Category = record.CategoryName ?? "Unknown",
                    Message = record.FormattedMessage ?? record.Body ?? "",
                    Exception = record.Exception?.ToString(),
                    TraceId = record.TraceId.ToString(),
                    SpanId = record.SpanId.ToString(),
                    Properties = SerializeAttributes(record)
                };

                context.TelemetryLogs.Add(log);
            }

            context.SaveChanges();
            return ExportResult.Success;
        }
        catch
        {
            return ExportResult.Failure;
        }
    }

    private static string? SerializeAttributes(LogRecord record)
    {
        if (record.Attributes is null)
        {
            return null;
        }

        var dict = new Dictionary<string, object?>();
        foreach (var attr in record.Attributes)
        {
            dict[attr.Key] = attr.Value;
        }

        return dict.Count > 0 ? JsonSerializer.Serialize(dict) : null;
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Telemetry/FileLogExporter.cs
================================================================================
using System.Text;
using System.Text.Json;
using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyBlog.Infrastructure.Telemetry;

/// <summary>
/// OpenTelemetry log exporter that writes to JSON files.
/// </summary>
public sealed class FileLogExporter : BaseExporter<LogRecord>
{
    private readonly string _directory;
    private readonly string _runId;
    private readonly long _maxFileSizeBytes;
    private readonly object _lock = new();
    private StreamWriter? _writer;
    private long _currentFileSize;
    private int _fileNumber;
    private bool _isFirstRecord = true;
    private readonly JsonSerializerOptions _jsonOptions = new() { WriteIndented = true };

    /// <summary>Initializes a new instance of FileLogExporter.</summary>
    public FileLogExporter(string directory, long maxFileSizeBytes = 25 * 1024 * 1024)
    {
        _directory = directory;
        _maxFileSizeBytes = maxFileSizeBytes;
        _runId = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
        Directory.CreateDirectory(_directory);
    }

    /// <inheritdoc />
    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        try
        {
            lock (_lock)
            {
                EnsureWriter();

                foreach (var record in batch)
                {
                    var obj = new
                    {
                        Timestamp = record.Timestamp.ToString("O"),
                        Level = record.LogLevel.ToString(),
                        Category = record.CategoryName,
                        Message = record.FormattedMessage ?? record.Body,
                        TraceId = record.TraceId.ToString(),
                        SpanId = record.SpanId.ToString(),
                        Exception = record.Exception?.ToString()
                    };

                    var json = JsonSerializer.Serialize(obj, _jsonOptions);
                    var bytes = Encoding.UTF8.GetByteCount(json) + 2;

                    if (_currentFileSize + bytes > _maxFileSizeBytes)
                    {
                        RotateFile();
                    }

                    if (!_isFirstRecord)
                    {
                        _writer!.WriteLine(",");
                    }
                    else
                    {
                        _isFirstRecord = false;
                    }

                    _writer!.Write(json);
                    _currentFileSize += bytes;
                }

                _writer!.Flush();
            }

            return ExportResult.Success;
        }
        catch
        {
            return ExportResult.Failure;
        }
    }

    private void EnsureWriter()
    {
        if (_writer is null)
        {
            OpenNewFile();
        }
    }

    private void OpenNewFile()
    {
        var fileName = _fileNumber == 0
            ? $"logs_{_runId}.json"
            : $"logs_{_runId}_{_fileNumber:D3}.json";

        _writer = new StreamWriter(Path.Combine(_directory, fileName), false, Encoding.UTF8);
        _writer.WriteLine("[");
        _currentFileSize = 2;
        _isFirstRecord = true;
    }

    private void RotateFile()
    {
        CloseWriter();
        _fileNumber++;
        OpenNewFile();
    }

    private void CloseWriter()
    {
        if (_writer is not null)
        {
            _writer.WriteLine();
            _writer.WriteLine("]");
            _writer.Flush();
            _writer.Dispose();
            _writer = null;
        }
    }

    /// <inheritdoc />
    protected override bool OnShutdown(int timeoutMilliseconds)
    {
        lock (_lock)
        {
            CloseWriter();
        }
        return true;
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/Telemetry/TelemetryPathResolver.cs
================================================================================
namespace MyBlog.Infrastructure.Telemetry;

/// <summary>
/// Resolves the telemetry directory path following XDG conventions.
/// </summary>
public static class TelemetryPathResolver
{
    /// <summary>
    /// Attempts to get a writable telemetry directory.
    /// Returns null if no writable directory can be found.
    /// </summary>
    public static string? GetTelemetryDirectory()
    {
        // Try XDG/platform-specific location first
        var preferredDir = GetPreferredDirectory();
        if (TryCreateAndVerify(preferredDir))
        {
            return preferredDir;
        }

        // Fallback to local directory
        var localDir = Path.Combine(AppContext.BaseDirectory, "telemetry");
        if (TryCreateAndVerify(localDir))
        {
            return localDir;
        }

        // No writable directory available
        return null;
    }

    private static string GetPreferredDirectory()
    {
        string baseDir;

        if (OperatingSystem.IsWindows())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        }
        else if (OperatingSystem.IsMacOS())
        {
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        }
        else
        {
            var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
            baseDir = !string.IsNullOrEmpty(xdgDataHome)
                ? xdgDataHome
                : Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".local", "share");
        }

        return Path.Combine(baseDir, "MyBlog", "telemetry");
    }

    private static bool TryCreateAndVerify(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid()}");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return true;
        }
        catch
        {
            return false;
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Infrastructure/ServiceCollectionExtensions.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using MyBlog.Core.Interfaces;
using MyBlog.Core.Services;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;

namespace MyBlog.Infrastructure;

/// <summary>
/// Extension methods for registering infrastructure services.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Adds infrastructure services to the DI container.
    /// </summary>
    public static IServiceCollection AddInfrastructure(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Database
        var connectionString = configuration.GetConnectionString("DefaultConnection");
        if (string.IsNullOrEmpty(connectionString) || connectionString == "Data Source=myblog.db")
        {
            // Use XDG-compliant path
            var dbPath = DatabasePathResolver.GetDatabasePath();
            connectionString = $"Data Source={dbPath}";
        }

        services.AddDbContext<BlogDbContext>(options =>
            options.UseSqlite(connectionString));

        // Repositories
        services.AddScoped<IPostRepository, PostRepository>();
        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IImageRepository, ImageRepository>();
        services.AddScoped<ITelemetryLogRepository, TelemetryLogRepository>();

        // Services
        services.AddSingleton<IPasswordService, PasswordService>();
        services.AddSingleton<ISlugService, SlugService>();
        services.AddSingleton<IMarkdownService, MarkdownService>();
        services.AddScoped<IAuthService, AuthService>();

        services.AddSingleton<IReaderTrackingService, ReaderTrackingService>();

        // Background services
        services.AddHostedService<TelemetryCleanupService>();

        return services;
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Tests/Integration/AuthServiceTests.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Integration;

public class AuthServiceTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly AuthService _sut;
    private readonly PasswordService _passwordService = new();

    public AuthServiceTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        var userRepository = new UserRepository(_context);
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Authentication:DefaultAdminPassword"] = "TestAdmin123!"
            })
            .Build();

        _sut = new AuthService(userRepository, _passwordService, configuration);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task AuthenticateAsync_WithValidCredentials_ReturnsUser()
    {
        var ct = TestContext.Current.CancellationToken;
        var password = "TestPassword123";
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(password),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("testuser", password, ct);

        Assert.NotNull(result);
        Assert.Equal("testuser", result.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_WithInvalidPassword_ReturnsNull()
    {
        var ct = TestContext.Current.CancellationToken;
        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword("CorrectPassword"),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("testuser", "WrongPassword", ct);

        Assert.Null(result);
    }

    [Fact]
    public async Task AuthenticateAsync_WithNonExistentUser_ReturnsNull()
    {
        var ct = TestContext.Current.CancellationToken;
        var result = await _sut.AuthenticateAsync("nonexistent", "password", ct);
        Assert.Null(result);
    }

    [Fact]
    public async Task EnsureAdminUserAsync_WhenNoUsersExist_CreatesAdmin()
    {
        var ct = TestContext.Current.CancellationToken;
        await _sut.EnsureAdminUserAsync(ct);

        var admin = await _context.Users.FirstOrDefaultAsync(u => u.Username == "admin", ct);
        Assert.NotNull(admin);
    }

    [Fact]
    public async Task EnsureAdminUserAsync_WhenUsersExist_DoesNotCreateAnother()
    {
        var ct = TestContext.Current.CancellationToken;
        var existingUser = new User
        {
            Id = Guid.NewGuid(),
            Username = "existing",
            PasswordHash = "hash",
            Email = "existing@example.com",
            DisplayName = "Existing",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(existingUser);
        await _context.SaveChangesAsync(ct);

        await _sut.EnsureAdminUserAsync(ct);

        var userCount = await _context.Users.CountAsync(ct);
        Assert.Equal(1, userCount);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Tests/Integration/PasswordChangeTests.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Integration;

public class PasswordChangeTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly AuthService _sut;
    private readonly PasswordService _passwordService = new();
    private readonly UserRepository _userRepository;

    public PasswordChangeTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _userRepository = new UserRepository(_context);
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Authentication:DefaultAdminPassword"] = "TestAdmin123!"
            })
            .Build();

        _sut = new AuthService(_userRepository, _passwordService, configuration);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task ChangePasswordAsync_WithCorrectCurrentPassword_ReturnsTrue()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "NewPassword456!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.ChangePasswordAsync(user.Id, originalPassword, newPassword, ct);

        Assert.True(result);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithCorrectPassword_AllowsLoginWithNewPassword()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "NewPassword456!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        await _sut.ChangePasswordAsync(user.Id, originalPassword, newPassword, ct);

        // Should authenticate with new password
        var authenticated = await _sut.AuthenticateAsync("testuser", newPassword, ct);
        Assert.NotNull(authenticated);

        // Should NOT authenticate with old password
        var oldAuth = await _sut.AuthenticateAsync("testuser", originalPassword, ct);
        Assert.Null(oldAuth);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithWrongCurrentPassword_ReturnsFalse()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPass123!";
        var wrongPassword = "WrongPassword!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.ChangePasswordAsync(user.Id, wrongPassword, "NewPass123!", ct);

        Assert.False(result);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithWrongPassword_DoesNotChangePassword()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPass123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        await _sut.ChangePasswordAsync(user.Id, "WrongPassword!", "NewPass123!", ct);

        // Original password should still work
        var authenticated = await _sut.AuthenticateAsync("testuser", correctPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task ChangePasswordAsync_WithNonExistentUser_ReturnsFalse()
    {
        var ct = TestContext.Current.CancellationToken;
        var result = await _sut.ChangePasswordAsync(Guid.NewGuid(), "any", "password", ct);
        Assert.False(result);
    }

    [Fact]
    public async Task ResetPasswordAsync_SetsNewPassword()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "ResetPassword789!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        await _sut.ResetPasswordAsync(user.Id, newPassword, ct);

        var authenticated = await _sut.AuthenticateAsync("testuser", newPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task ResetPasswordAsync_WithNonExistentUser_ThrowsException()
    {
        var ct = TestContext.Current.CancellationToken;
        await Assert.ThrowsAsync<InvalidOperationException>(
            () => _sut.ResetPasswordAsync(Guid.NewGuid(), "password", ct));
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Tests/Integration/PostRepositoryTests.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using Xunit;

namespace MyBlog.Tests.Integration;

public class PostRepositoryTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly PostRepository _sut;
    private readonly User _testUser;

    public PostRepositoryTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _testUser = new User
        {
            Id = Guid.NewGuid(),
            Username = "testuser",
            PasswordHash = "hash",
            Email = "test@example.com",
            DisplayName = "Test User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(_testUser);
        _context.SaveChanges();

        _sut = new PostRepository(_context);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task CreateAsync_AddsPostToDatabase()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("Test Post");

        var result = await _sut.CreateAsync(post, ct);

        Assert.NotEqual(Guid.Empty, result.Id);
        var saved = await _context.Posts.FindAsync([result.Id], ct);
        Assert.NotNull(saved);
        Assert.Equal("Test Post", saved.Title);
    }

    [Fact]
    public async Task GetByIdAsync_WithExistingId_ReturnsPost()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("Test Post");
        await _sut.CreateAsync(post, ct);

        var result = await _sut.GetByIdAsync(post.Id, ct);

        Assert.NotNull(result);
        Assert.Equal("Test Post", result.Title);
    }

    [Fact]
    public async Task GetByIdAsync_WithNonExistingId_ReturnsNull()
    {
        var ct = TestContext.Current.CancellationToken;
        var result = await _sut.GetByIdAsync(Guid.NewGuid(), ct);
        Assert.Null(result);
    }

    [Fact]
    public async Task GetBySlugAsync_WithExistingSlug_ReturnsPost()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("Test Post", "test-post");
        await _sut.CreateAsync(post, ct);

        var result = await _sut.GetBySlugAsync("test-post", ct);

        Assert.NotNull(result);
        Assert.Equal("Test Post", result.Title);
    }

    [Fact]
    public async Task GetPublishedPostsAsync_ReturnsOnlyPublishedPosts()
    {
        var ct = TestContext.Current.CancellationToken;
        await _sut.CreateAsync(CreateTestPost("Published", isPublished: true), ct);
        await _sut.CreateAsync(CreateTestPost("Draft", isPublished: false), ct);

        var (posts, totalCount) = await _sut.GetPublishedPostsAsync(1, 10, ct);

        Assert.Single(posts);
        Assert.Equal("Published", posts.First().Title);
        Assert.Equal(1, totalCount);
    }

    [Fact]
    public async Task UpdateAsync_ModifiesPost()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("Original Title");
        await _sut.CreateAsync(post, ct);

        post.Title = "Updated Title";
        await _sut.UpdateAsync(post, ct);

        var result = await _sut.GetByIdAsync(post.Id, ct);
        Assert.Equal("Updated Title", result!.Title);
    }

    [Fact]
    public async Task DeleteAsync_RemovesPost()
    {
        var ct = TestContext.Current.CancellationToken;
        var post = CreateTestPost("To Delete");
        await _sut.CreateAsync(post, ct);

        await _sut.DeleteAsync(post.Id, ct);

        var result = await _sut.GetByIdAsync(post.Id, ct);
        Assert.Null(result);
    }

    [Fact]
    public async Task GetPublishedPostsAsync_ReturnsCorrectCount()
    {
        var ct = TestContext.Current.CancellationToken;
        await _sut.CreateAsync(CreateTestPost("Post 1", isPublished: true), ct);
        await _sut.CreateAsync(CreateTestPost("Post 2", isPublished: true), ct);
        await _sut.CreateAsync(CreateTestPost("Draft", isPublished: false), ct);

        var (_, totalCount) = await _sut.GetPublishedPostsAsync(1, 10, ct);

        Assert.Equal(2, totalCount);
    }

    private Post CreateTestPost(string title, string? slug = null, bool isPublished = true)
    {
        return new Post
        {
            Id = Guid.NewGuid(),
            Title = title,
            Slug = slug ?? title.ToLower().Replace(" ", "-"),
            Content = "Test content",
            Summary = "Test summary",
            AuthorId = _testUser.Id,
            CreatedAtUtc = DateTime.UtcNow,
            UpdatedAtUtc = DateTime.UtcNow,
            IsPublished = isPublished,
            PublishedAtUtc = isPublished ? DateTime.UtcNow : null
        };
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Tests/Integration/TelemetryCleanupTests.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using Xunit;

namespace MyBlog.Tests.Integration;

public class TelemetryCleanupTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly TelemetryLogRepository _sut;

    public TelemetryCleanupTests()
    {
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _sut = new TelemetryLogRepository(_context);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    [Fact]
    public async Task DeleteOlderThanAsync_RemovesOldLogs()
    {
        var ct = TestContext.Current.CancellationToken;

        // Add old logs
        var oldLog = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow.AddDays(-60),
            Level = "Information",
            Category = "Test",
            Message = "Old log"
        };
        _context.TelemetryLogs.Add(oldLog);

        // Add recent log
        var recentLog = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow.AddDays(-5),
            Level = "Information",
            Category = "Test",
            Message = "Recent log"
        };
        _context.TelemetryLogs.Add(recentLog);
        await _context.SaveChangesAsync(ct);

        var cutoff = DateTime.UtcNow.AddDays(-30);
        var deleted = await _sut.DeleteOlderThanAsync(cutoff, ct);

        Assert.Equal(1, deleted);
        var remaining = await _context.TelemetryLogs.CountAsync(ct);
        Assert.Equal(1, remaining);
    }

    [Fact]
    public async Task DeleteOlderThanAsync_WithNoOldLogs_ReturnsZero()
    {
        var ct = TestContext.Current.CancellationToken;

        var recentLog = new TelemetryLog
        {
            TimestampUtc = DateTime.UtcNow.AddDays(-5),
            Level = "Information",
            Category = "Test",
            Message = "Recent log"
        };
        _context.TelemetryLogs.Add(recentLog);
        await _context.SaveChangesAsync(ct);

        var cutoff = DateTime.UtcNow.AddDays(-30);
        var deleted = await _sut.DeleteOlderThanAsync(cutoff, ct);

        Assert.Equal(0, deleted);
    }

    [Fact]
    public async Task DeleteOlderThanAsync_WithEmptyTable_ReturnsZero()
    {
        var ct = TestContext.Current.CancellationToken;
        var cutoff = DateTime.UtcNow.AddDays(-30);
        var deleted = await _sut.DeleteOlderThanAsync(cutoff, ct);
        Assert.Equal(0, deleted);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Tests/Integration/AuthServiceLongPasswordTests.cs
================================================================================
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using MyBlog.Core.Models;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Repositories;
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Integration;

/// <summary>
/// Tests for long password support and account lockout behavior.
/// Uses in-memory SQLite for cross-platform compatibility (Windows/Linux/macOS).
/// </summary>
public sealed class AuthServiceLongPasswordTests : IAsyncDisposable
{
    private readonly BlogDbContext _context;
    private readonly AuthService _sut;
    private readonly PasswordService _passwordService;

    public AuthServiceLongPasswordTests()
    {
        // Use in-memory SQLite - works on all platforms without file locking issues
        var options = new DbContextOptionsBuilder<BlogDbContext>()
            .UseSqlite("Data Source=:memory:")
            .Options;

        _context = new BlogDbContext(options);
        _context.Database.OpenConnection();
        _context.Database.EnsureCreated();

        _passwordService = new PasswordService();
        var userRepository = new UserRepository(_context);
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Authentication:DefaultAdminPassword"] = "TestAdmin123!"
            })
            .Build();

        _sut = new AuthService(userRepository, _passwordService, configuration);
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    // =========================================================================
    // Long Password Tests (128+ characters)
    // =========================================================================

    [Fact]
    public async Task AuthenticateAsync_With128CharacterPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var longPassword = new string('a', 128);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "long-pass-user",
            PasswordHash = _passwordService.HashPassword(longPassword),
            Email = "longpass@example.com",
            DisplayName = "Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("long-pass-user", longPassword, ct);

        Assert.NotNull(result);
        Assert.Equal("long-pass-user", result.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_With256CharacterPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var longPassword = new string('x', 256);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "very-long-pass-user",
            PasswordHash = _passwordService.HashPassword(longPassword),
            Email = "very-long@example.com",
            DisplayName = "Very Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("very-long-pass-user", longPassword, ct);

        Assert.NotNull(result);
        Assert.Equal("very-long-pass-user", result.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_With512CharacterPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var longPassword = new string('P', 512);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "extralong-pass-user",
            PasswordHash = _passwordService.HashPassword(longPassword),
            Email = "extralong@example.com",
            DisplayName = "Extra Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("extralong-pass-user", longPassword, ct);

        Assert.NotNull(result);
        Assert.Equal("extralong-pass-user", result.Username);
    }

    [Fact]
    public async Task ChangePasswordAsync_With128CharacterNewPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "ShortPass123!";
        var newLongPassword = new string('N', 128);

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "change-pass-long-user",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "changelong@example.com",
            DisplayName = "Change Long Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.ChangePasswordAsync(user.Id, originalPassword, newLongPassword, ct);

        Assert.True(result);

        // Verify new password works
        var authenticated = await _sut.AuthenticateAsync("change-pass-long-user", newLongPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task AuthenticateAsync_WithComplexLongPassword_Succeeds()
    {
        var ct = TestContext.Current.CancellationToken;
        // Mix of characters, 200 chars long
        var complexPassword = string.Concat(
            new string('A', 50),
            new string('1', 50),
            new string('!', 50),
            new string('z', 50)
        );

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "complex-pass-user",
            PasswordHash = _passwordService.HashPassword(complexPassword),
            Email = "complex@example.com",
            DisplayName = "Complex Password User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        var result = await _sut.AuthenticateAsync("complex-pass-user", complexPassword, ct);

        Assert.NotNull(result);
    }

    // =========================================================================
    // No Account Lockout Tests
    // =========================================================================

    [Fact]
    public async Task AuthenticateAsync_After100FailedAttempts_StillAllowsLogin()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPassword123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "no-lockout-user",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "no-lockout@example.com",
            DisplayName = "No Lockout User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Attempt 100 failed logins
        for (var i = 0; i < 100; i++)
        {
            var failedResult = await _sut.AuthenticateAsync("no-lockout-user", "WrongPassword", ct);
            Assert.Null(failedResult);
        }

        // User should still be able to log in with correct password
        var successResult = await _sut.AuthenticateAsync("no-lockout-user", correctPassword, ct);
        Assert.NotNull(successResult);
        Assert.Equal("no-lockout-user", successResult.Username);
    }

    [Fact]
    public async Task AuthenticateAsync_After1000FailedAttempts_StillAllowsLogin()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPassword123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "no-lockout1000user",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "no-lockout1000@example.com",
            DisplayName = "No Lockout 1000 User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Attempt 1000 failed logins
        for (var i = 0; i < 1000; i++)
        {
            var failedResult = await _sut.AuthenticateAsync("no-lockout1000user", $"WrongPassword{i}", ct);
            Assert.Null(failedResult);
        }

        // User should still be able to log in with correct password
        var successResult = await _sut.AuthenticateAsync("no-lockout1000user", correctPassword, ct);
        Assert.NotNull(successResult);
        Assert.Equal("no-lockout1000user", successResult.Username);
    }

    [Fact]
    public async Task ChangePasswordAsync_AfterManyFailedAttempts_StillWorks()
    {
        var ct = TestContext.Current.CancellationToken;
        var originalPassword = "OriginalPass123!";
        var newPassword = "NewPassword456!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "change-pass-no-lockout",
            PasswordHash = _passwordService.HashPassword(originalPassword),
            Email = "change-pass-no-lockout@example.com",
            DisplayName = "Change Password No Lockout",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Attempt 50 failed password changes
        for (var i = 0; i < 50; i++)
        {
            var failedResult = await _sut.ChangePasswordAsync(user.Id, "WrongOldPassword", "NewPass", ct);
            Assert.False(failedResult);
        }

        // Should still be able to change password with correct current password
        var successResult = await _sut.ChangePasswordAsync(user.Id, originalPassword, newPassword, ct);
        Assert.True(successResult);

        // Verify new password works
        var authenticated = await _sut.AuthenticateAsync("change-pass-no-lockout", newPassword, ct);
        Assert.NotNull(authenticated);
    }

    [Fact]
    public async Task AuthenticateAsync_InterleavedFailuresAndSuccesses_NeverLocks()
    {
        var ct = TestContext.Current.CancellationToken;
        var correctPassword = "CorrectPassword123!";

        var user = new User
        {
            Id = Guid.NewGuid(),
            Username = "interleaved-user",
            PasswordHash = _passwordService.HashPassword(correctPassword),
            Email = "interleaved@example.com",
            DisplayName = "Interleaved User",
            CreatedAtUtc = DateTime.UtcNow
        };
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);

        // Interleave failed and successful attempts
        for (var i = 0; i < 20; i++)
        {
            // 5 failed attempts
            for (var j = 0; j < 5; j++)
            {
                var failedResult = await _sut.AuthenticateAsync("interleaved-user", "WrongPassword", ct);
                Assert.Null(failedResult);
            }

            // 1 successful attempt
            var successResult = await _sut.AuthenticateAsync("interleaved-user", correctPassword, ct);
            Assert.NotNull(successResult);
        }

        // Final successful login after 100 failed attempts total
        var finalResult = await _sut.AuthenticateAsync("interleaved-user", correctPassword, ct);
        Assert.NotNull(finalResult);
        Assert.Equal("interleaved-user", finalResult.Username);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Tests/Unit/LoginRateLimitMiddlewareTests.cs
================================================================================
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging.Abstractions;
using MyBlog.Web.Middleware;
using Xunit;

namespace MyBlog.Tests.Unit;

/// <summary>
/// Tests for LoginRateLimitMiddleware.
/// Verifies that the middleware slows down but never blocks requests.
/// </summary>
public sealed class LoginRateLimitMiddlewareTests : IDisposable
{
    private readonly LoginRateLimitMiddleware _sut;
    private int _nextCallCount;
    private readonly List<TimeSpan> _recordedDelays = [];

    public LoginRateLimitMiddlewareTests()
    {
        // Clear any state from previous tests
        LoginRateLimitMiddleware.ClearAttempts();

        _nextCallCount = 0;
        RequestDelegate next = _ =>
        {
            _nextCallCount++;
            return Task.CompletedTask;
        };

        // Use a no-op delay function that just records the delay
        // This makes tests fast while still verifying delay logic
        Task NoOpDelay(TimeSpan delay, CancellationToken ct)
        {
            _recordedDelays.Add(delay);
            return Task.CompletedTask;
        }

        _sut = new LoginRateLimitMiddleware(
            next,
            NullLogger<LoginRateLimitMiddleware>.Instance,
            NoOpDelay);
    }

    public void Dispose()
    {
        // Clean up after each test
        LoginRateLimitMiddleware.ClearAttempts();
    }

    [Fact]
    public async Task InvokeAsync_NonLoginRequest_PassesThroughImmediately()
    {
        var context = CreateHttpContext("/api/posts", "GET");

        await _sut.InvokeAsync(context);

        Assert.Equal(1, _nextCallCount);
        Assert.Empty(_recordedDelays);
    }

    [Fact]
    public async Task InvokeAsync_GetLoginRequest_PassesThroughImmediately()
    {
        var context = CreateHttpContext("/login", "GET");

        await _sut.InvokeAsync(context);

        Assert.Equal(1, _nextCallCount);
        Assert.Empty(_recordedDelays);
    }

    [Fact]
    public async Task InvokeAsync_FirstFiveAttempts_NoDelay()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // First 5 attempts should have no delay
        for (var i = 0; i < 5; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(5, _nextCallCount);
        Assert.Empty(_recordedDelays); // No delays for first 5 attempts
    }

    [Fact]
    public async Task InvokeAsync_SixthAttempt_HasOneSecondDelay()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make 6 attempts
        for (var i = 0; i < 6; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(6, _nextCallCount);
        Assert.Single(_recordedDelays);
        Assert.Equal(TimeSpan.FromSeconds(1), _recordedDelays[0]);
    }

    [Fact]
    public async Task InvokeAsync_ProgressiveDelays_IncreaseExponentially()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make 10 attempts: 5 no-delay + 5 with delays
        for (var i = 0; i < 10; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(10, _nextCallCount);
        Assert.Equal(5, _recordedDelays.Count); // Delays start after attempt 5

        // Verify exponential progression: 1s, 2s, 4s, 8s, 16s
        Assert.Equal(TimeSpan.FromSeconds(1), _recordedDelays[0]);
        Assert.Equal(TimeSpan.FromSeconds(2), _recordedDelays[1]);
        Assert.Equal(TimeSpan.FromSeconds(4), _recordedDelays[2]);
        Assert.Equal(TimeSpan.FromSeconds(8), _recordedDelays[3]);
        Assert.Equal(TimeSpan.FromSeconds(16), _recordedDelays[4]);
    }

    [Fact]
    public async Task InvokeAsync_DelayCappedAt30Seconds()
    {
        var uniqueIp = $"192.168.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make enough attempts to hit the cap (5 no-delay + enough to exceed 30s)
        // After attempt 5: 1, 2, 4, 8, 16, 30, 30, 30...
        for (var i = 0; i < 15; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        Assert.Equal(15, _nextCallCount);

        // Verify cap at 30 seconds (attempts 11+ should all be 30s)
        var maxDelays = _recordedDelays.Where(d => d == TimeSpan.FromSeconds(30)).ToList();
        Assert.True(maxDelays.Count >= 4, "Should have multiple 30-second delays");
        Assert.True(_recordedDelays.All(d => d <= TimeSpan.FromSeconds(30)), "No delay should exceed 30 seconds");
    }

    [Fact]
    public async Task InvokeAsync_AfterManyAttempts_NeverBlocks()
    {
        var uniqueIp = $"10.0.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // Make 100 attempts - should all pass through (with delays, but never blocked)
        for (var i = 0; i < 100; i++)
        {
            var context = CreateHttpContext("/login", "POST", uniqueIp);
            await _sut.InvokeAsync(context);
        }

        // Key assertion: ALL requests passed through, none were blocked
        Assert.Equal(100, _nextCallCount);
    }

    [Fact]
    public async Task InvokeAsync_DifferentIPs_IndependentTracking()
    {
        var ip1 = $"10.1.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";
        var ip2 = $"10.2.{Random.Shared.Next(1, 255)}.{Random.Shared.Next(1, 255)}";

        // 6 attempts from IP1 (should trigger delay on 6th)
        for (var i = 0; i < 6; i++)
        {
            var context = CreateHttpContext("/login", "POST", ip1);
            await _sut.InvokeAsync(context);
        }

        var ip1Delays = _recordedDelays.Count;
        Assert.Equal(1, ip1Delays); // One delay after 5th attempt

        // First attempt from IP2 should have no delay
        var context2 = CreateHttpContext("/login", "POST", ip2);
        await _sut.InvokeAsync(context2);

        // No new delays should have been added for IP2
        Assert.Equal(ip1Delays, _recordedDelays.Count);
    }

    [Fact]
    public void CalculateDelay_UnknownIP_ReturnsZero()
    {
        var delay = LoginRateLimitMiddleware.CalculateDelay("unknown-ip-never-seen");
        Assert.Equal(TimeSpan.Zero, delay);
    }

    private static DefaultHttpContext CreateHttpContext(string path, string method, string? remoteIp = null)
    {
        var context = new DefaultHttpContext();
        context.Request.Path = path;
        context.Request.Method = method;

        if (remoteIp != null)
        {
            context.Connection.RemoteIpAddress = System.Net.IPAddress.Parse(remoteIp);
        }

        return context;
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Tests/Unit/MarkdownServiceTests.cs
================================================================================
using MyBlog.Core.Services;
using Xunit;

namespace MyBlog.Tests.Unit;

public class MarkdownServiceTests
{
    private readonly MarkdownService _sut = new();

    [Fact]
    public void ToHtml_WithHeading1_ReturnsH1Tag()
    {
        var result = _sut.ToHtml("# Hello");
        Assert.Contains("<h1>Hello</h1>", result);
    }

    [Fact]
    public void ToHtml_WithHeading2_ReturnsH2Tag()
    {
        var result = _sut.ToHtml("## Hello");
        Assert.Contains("<h2>Hello</h2>", result);
    }

    [Fact]
    public void ToHtml_WithHeading6_ReturnsH6Tag()
    {
        var result = _sut.ToHtml("###### Hello");
        Assert.Contains("<h6>Hello</h6>", result);
    }

    [Fact]
    public void ToHtml_WithBoldText_ReturnsStrongTag()
    {
        var result = _sut.ToHtml("This is **bold** text");
        Assert.Contains("<strong>bold</strong>", result);
    }

    [Fact]
    public void ToHtml_WithItalicText_ReturnsEmTag()
    {
        var result = _sut.ToHtml("This is *italic* text");
        Assert.Contains("<em>italic</em>", result);
    }

    [Fact]
    public void ToHtml_WithLink_ReturnsAnchorTag()
    {
        var result = _sut.ToHtml("Check [this link](https://example.com)");
        Assert.Contains("<a href=\"https://example.com\">this link</a>", result);
    }

    [Fact]
    public void ToHtml_WithImage_ReturnsImgTag()
    {
        var result = _sut.ToHtml("![alt text](https://example.com/image.png)");
        Assert.Contains("<img src=\"https://example.com/image.png\" alt=\"alt text\" />", result);
    }

    [Fact]
    public void ToHtml_WithInlineCode_ReturnsCodeTag()
    {
        var result = _sut.ToHtml("Use `code` here");
        Assert.Contains("<code>code</code>", result);
    }

    [Fact]
    public void ToHtml_WithCodeBlock_ReturnsPreCodeTags()
    {
        var markdown = "```\nvar x = 1;\n```";
        var result = _sut.ToHtml(markdown);
        Assert.Contains("<pre><code>", result);
        Assert.Contains("var x = 1;", result);
        Assert.Contains("</code></pre>", result);
    }

    [Fact]
    public void ToHtml_WithBlockquote_ReturnsBlockquoteTag()
    {
        var result = _sut.ToHtml("> This is a quote");
        Assert.Contains("<blockquote><p>This is a quote</p></blockquote>", result);
    }

    [Fact]
    public void ToHtml_WithUnorderedList_ReturnsUlLiTags()
    {
        var markdown = "- Item 1\n- Item 2";
        var result = _sut.ToHtml(markdown);
        Assert.Contains("<ul>", result);
        Assert.Contains("<li>Item 1</li>", result);
        Assert.Contains("<li>Item 2</li>", result);
        Assert.Contains("</ul>", result);
    }

    [Fact]
    public void ToHtml_WithHorizontalRule_ReturnsHrTag()
    {
        var result = _sut.ToHtml("---");
        Assert.Contains("<hr />", result);
    }

    [Fact]
    public void ToHtml_WithEmptyString_ReturnsEmptyString()
    {
        var result = _sut.ToHtml("");
        Assert.Equal(string.Empty, result);
    }

    [Fact]
    public void ToHtml_WithPlainText_ReturnsParagraph()
    {
        var result = _sut.ToHtml("Hello world");
        Assert.Contains("<p>Hello world</p>", result);
    }

    [Fact]
    public void ToHtml_WithHtmlCharacters_EscapesThem()
    {
        var result = _sut.ToHtml("Use <script> tags");
        Assert.Contains("&lt;script&gt;", result);
        Assert.DoesNotContain("<script>", result);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Tests/Unit/PasswordServiceTests.cs
================================================================================
using MyBlog.Infrastructure.Services;
using Xunit;

namespace MyBlog.Tests.Unit;

public class PasswordServiceTests
{
    private readonly PasswordService _sut = new();

    [Fact]
    public void HashPassword_ReturnsNonEmptyHash()
    {
        var hash = _sut.HashPassword("TestPassword123");
        Assert.False(string.IsNullOrEmpty(hash));
    }

    [Fact]
    public void HashPassword_ReturnsDifferentHashForSamePassword()
    {
        var hash1 = _sut.HashPassword("TestPassword123");
        var hash2 = _sut.HashPassword("TestPassword123");
        Assert.NotEqual(hash1, hash2);
    }

    [Fact]
    public void VerifyPassword_WithCorrectPassword_ReturnsTrue()
    {
        var password = "TestPassword123";
        var hash = _sut.HashPassword(password);

        var result = _sut.VerifyPassword(hash, password);

        Assert.True(result);
    }

    [Fact]
    public void VerifyPassword_WithWrongPassword_ReturnsFalse()
    {
        var hash = _sut.HashPassword("TestPassword123");

        var result = _sut.VerifyPassword(hash, "WrongPassword");

        Assert.False(result);
    }

    [Fact]
    public void VerifyPassword_WithEmptyPassword_ReturnsFalse()
    {
        var hash = _sut.HashPassword("TestPassword123");

        var result = _sut.VerifyPassword(hash, "");

        Assert.False(result);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Tests/Unit/SlugServiceTests.cs
================================================================================
using MyBlog.Core.Services;
using Xunit;

namespace MyBlog.Tests.Unit;

public class SlugServiceTests
{
    private readonly SlugService _sut = new();

    [Fact]
    public void GenerateSlug_WithSimpleTitle_ReturnsLowercaseWithHyphens()
    {
        var result = _sut.GenerateSlugOrUuid("Hello World");
        Assert.Equal("hello-world", result);
    }

    [Fact]
    public void GenerateSlug_WithSpecialCharacters_RemovesThem()
    {
        var result = _sut.GenerateSlugOrUuid("Hello, World! How's it going?");
        Assert.Equal("hello-world-hows-it-going", result);
    }

    [Fact]
    public void GenerateSlug_WithMultipleSpaces_CollapsesToSingleHyphen()
    {
        var result = _sut.GenerateSlugOrUuid("Hello    World");
        Assert.Equal("hello-world", result);
    }

    [Fact]
    public void GenerateSlug_WithUnicode_RemovesDiacritics()
    {
        var result = _sut.GenerateSlugOrUuid("Caf rsum");
        Assert.Equal("cafe-resume", result);
    }

    [Fact]
    public void GenerateSlug_WithLeadingTrailingSpaces_TrimsHyphens()
    {
        var result = _sut.GenerateSlugOrUuid("  Hello World  ");
        Assert.Equal("hello-world", result);
    }

    [Fact]
    public void GenerateSlug_WithNumbers_PreservesNumbers()
    {
        var result = _sut.GenerateSlugOrUuid("Top 10 Tips for 2024");
        Assert.Equal("top-10-tips-for-2024", result);
    }

    [Fact]
    public void GenerateSlug_WithUnderscores_ConvertsToHyphens()
    {
        var result = _sut.GenerateSlugOrUuid("hello_world_test");
        Assert.Equal("hello-world-test", result);
    }

    [Fact]
    public void GenerateSlug_WithEmptyString_ThrowsArgumentException()
    {
        Assert.Throws<ArgumentException>(() => _sut.GenerateSlugOrUuid(""));
    }

    [Fact]
    public void GenerateSlug_WithWhitespaceOnly_ThrowsArgumentException()
    {
        Assert.Throws<ArgumentException>(() => _sut.GenerateSlugOrUuid("   "));
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Layout/MainLayout.razor
================================================================================
@inherits LayoutComponentBase
@inject IConfiguration Configuration
@inject NavigationManager Navigation

<div class="layout">
    <header class="header">
        <div class="container">
            <a href="/" class="logo">@(Configuration["Application:Title"] ?? "MyBlog")</a>
            <nav class="nav">
                <a href="/">Home</a>
                <a href="/about">About</a>
                <AuthorizeView>
                    <Authorized>
                        <a href="/admin">Dashboard</a>
                        <a href="/admin/users">Users</a>
                        <form method="post" action="/logout" class="logout-form">
                            <AntiforgeryToken />
                            <button type="submit">Logout</button>
                        </form>
                    </Authorized>
                    <NotAuthorized>
                        <a href="/login">Login</a>
                    </NotAuthorized>
                </AuthorizeView>
            </nav>
        </div>
    </header>

    <main class="main">
        <div class="container">
            @Body
        </div>
    </main>

    <Footer />
</div>


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Pages/AccessDenied.razor
================================================================================
@page "/access-denied"

<PageTitle>Access Denied</PageTitle>

<div class="container" style="max-width: 600px; margin-top: 50px; text-align: center;">
    <h1 style="color: var(--color-danger);">Access Denied</h1>
    <p>You do not have permission to view this resource.</p>
    <div style="margin-top: 20px;">
        <a href="/" class="btn btn-primary">Return Home</a>
        <form action="/logout" method="post" style="display: inline;">
            <AntiforgeryToken />
            <button type="submit" class="btn btn-link">Logout</button>
        </form>
    </div>
</div>

--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Pages/Admin/ImageManager.razor
================================================================================
@page "/admin/images"
@rendermode InteractiveServer
@attribute [Authorize]
@inject IImageRepository ImageRepository
@inject AuthenticationStateProvider AuthStateProvider
@using System.Security.Claims

<PageTitle>Manage Images</PageTitle>

<h1>Manage Images</h1>

<div class="image-upload">
    <h3>Upload New Image</h3>
    <InputFile OnChange="HandleFileUpload" accept="image/*" disabled="@_uploading" />
    @if (_uploading)
    {
        <p>Uploading...</p>
    }
    @if (!string.IsNullOrEmpty(_uploadStatus))
    {
        <p class="@(_uploadError ? "error" : "success")">@_uploadStatus</p>
    }
</div>

<h3>Uploaded Images</h3>
@if (_images is null)
{
    <p>Loading...</p>
}
else if (_images.Count == 0)
{
    <p>No images uploaded yet.</p>
}
else
{
    <div class="image-grid">
        @foreach (var image in _images)
        {
            <div class="image-card">
                <img src="/api/images/@image.Id" alt="@image.FileName" />
                <div class="image-info">
                    <p>@image.FileName</p>
                    <code>/api/images/@image.Id</code>
                    <button @onclick="() => DeleteImage(image.Id)" class="btn-link danger" disabled="@_deleting">Delete</button>
                </div>
            </div>
        }
    </div>
}

@code {
    private IReadOnlyList<Image>? _images;
    private string? _uploadStatus;
    private bool _uploadError;
    private bool _uploading;
    private bool _deleting;

    protected override async Task OnInitializedAsync()
    {
        await LoadImages();
    }

    private async Task LoadImages()
    {
        _images = await ImageRepository.GetAllAsync();
    }

    private async Task HandleFileUpload(InputFileChangeEventArgs e)
    {
        _uploadStatus = null;
        _uploadError = false;
        _uploading = true;

        try
        {
            var file = e.File;
            if (file.Size > AppConstants.MaxImageSizeBytes)
            {
                _uploadStatus = "File too large. Maximum size is 5MB.";
                _uploadError = true;
                return;
            }

            if (!AppConstants.AllowedImageTypes.Contains(file.ContentType))
            {
                _uploadStatus = "Invalid file type. Only JPEG, PNG, GIF, and WebP are allowed.";
                _uploadError = true;
                return;
            }

            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var userIdClaim = authState.User.FindFirst(ClaimTypes.NameIdentifier);

            if (userIdClaim is null || !Guid.TryParse(userIdClaim.Value, out var userId))
            {
                _uploadStatus = "Unable to identify current user. Please log in again.";
                _uploadError = true;
                return;
            }

            using var stream = file.OpenReadStream(AppConstants.MaxImageSizeBytes);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);

            var image = new Image
            {
                Id = Guid.NewGuid(),
                FileName = file.Name,
                ContentType = file.ContentType,
                Data = ms.ToArray(),
                UploadedAtUtc = DateTime.UtcNow,
                UploadedByUserId = userId
            };

            await ImageRepository.CreateAsync(image);
            _uploadStatus = "Image uploaded successfully!";
            await LoadImages();
        }
        catch (Exception ex)
        {
            _uploadStatus = $"Upload failed: {ex.Message}";
            _uploadError = true;
        }
        finally
        {
            _uploading = false;
        }
    }

    private async Task DeleteImage(Guid id)
    {
        _deleting = true;
        try
        {
            await ImageRepository.DeleteAsync(id);
            await LoadImages();
        }
        finally
        {
            _deleting = false;
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Pages/Admin/PostList.razor
================================================================================
@page "/admin/posts"
@rendermode InteractiveServer
@attribute [Authorize]
@inject IPostRepository PostRepository
@inject NavigationManager Navigation

<PageTitle>Manage Posts</PageTitle>

<h1>Manage Posts</h1>

<p><a href="/admin/posts/new" class="btn btn-primary">Create New Post</a></p>

@if (_posts is null)
{
    <p>Loading...</p>
}
else if (_posts.Count == 0)
{
    <p>No posts yet.</p>
}
else
{
    <table class="admin-table">
        <thead>
            <tr>
                <th>Title</th>
                <th>Author</th>
                <th>Status</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var post in _posts)
            {
                <tr>
                    <td>@post.Title</td>
                    <td>@post.AuthorDisplayName</td>
                    <td>@(post.IsPublished ? "Published" : "Draft")</td>
                    <td>
                        <a href="/admin/posts/edit/@post.Id">Edit</a>
                        <button @onclick="() => DeletePost(post.Id)" class="btn-link danger" disabled="@_deleting">Delete</button>
                    </td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private IReadOnlyList<PostListItemDto>? _posts;
    private bool _deleting;

    protected override async Task OnInitializedAsync()
    {
        await LoadPosts();
    }

    private async Task LoadPosts()
    {
        _posts = await PostRepository.GetAllPostsAsync();
    }

    private async Task DeletePost(Guid id)
    {
        _deleting = true;
        try
        {
            await PostRepository.DeleteAsync(id);
            await LoadPosts();
        }
        finally
        {
            _deleting = false;
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Pages/Admin/PostEditor.razor
================================================================================
@page "/admin/posts/new"
@page "/admin/posts/edit/{Id:guid}"
@rendermode InteractiveServer
@attribute [Authorize]
@inject IPostRepository PostRepository
@inject ISlugService SlugService
@inject NavigationManager Navigation
@inject AuthenticationStateProvider AuthStateProvider
@using System.Security.Claims

<PageTitle>@(IsEdit ? "Edit Post" : "New Post")</PageTitle>

<h1>@(IsEdit ? "Edit Post" : "New Post")</h1>

@if (_loading)
{
    <p>Loading...</p>
}
else if (IsEdit && _existingPost is null)
{
    <p>Post not found.</p>
    <a href="/admin/posts">Back to Posts</a>
}
else
{
    <div class="post-editor">
        <div class="editor-form">
            <div class="form-group">
                <label for="title">Title</label>
                <input type="text" id="title" @bind="_title" @bind:event="oninput" />
            </div>

            <div class="form-group">
                <label for="summary">Summary</label>
                <textarea id="summary" @bind="_summary" rows="2"></textarea>
            </div>

            <div class="form-group">
                <label for="content">Content (Markdown)</label>
                <textarea id="content" @bind="_content" @bind:event="oninput" rows="20"></textarea>
            </div>

            <div class="form-group checkbox">
                <label>
                    <input type="checkbox" @bind="_isPublished" />
                    Published
                </label>
            </div>

            @if (!string.IsNullOrEmpty(_error))
            {
                <div class="error-message">@_error</div>
            }

            <div class="form-actions">
                <button @onclick="Save" class="btn btn-primary" disabled="@_saving">
                    @(_saving ? "Saving..." : "Save")
                </button>
                <a href="/admin/posts" class="btn">Cancel</a>
            </div>
        </div>

        <div class="editor-preview">
            <h3>Preview</h3>
            <div class="preview-content">
                <MarkdownRenderer Content="@_content" />
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public Guid? Id { get; set; }

    private bool IsEdit => Id.HasValue;
    private bool _loading = true;
    private bool _saving;
    private string _title = "";
    private string _summary = "";
    private string _content = "";
    private bool _isPublished;
    private string? _error;
    private Post? _existingPost;

    protected override async Task OnInitializedAsync()
    {
        if (IsEdit)
        {
            _existingPost = await PostRepository.GetByIdAsync(Id!.Value);
            if (_existingPost is not null)
            {
                _title = _existingPost.Title;
                _summary = _existingPost.Summary;
                _content = _existingPost.Content;
                _isPublished = _existingPost.IsPublished;
            }
        }
        _loading = false;
    }

    private async Task Save()
    {
        if (string.IsNullOrWhiteSpace(_title))
        {
            _error = "Title is required.";
            return;
        }

        _saving = true;
        _error = null;

        try
        {
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var userIdClaim = authState.User.FindFirst(ClaimTypes.NameIdentifier);

            if (userIdClaim is null || !Guid.TryParse(userIdClaim.Value, out var userId))
            {
                _error = "Unable to identify current user. Please log in again.";
                _saving = false;
                return;
            }

            // Generate unique slug
            var baseSlug = SlugService.GenerateSlugOrUuid(_title);
            var finalSlug = baseSlug;
            var counter = 1;

            // Loop until we find a slug that isn't taken (excluding current post if editing)
            while (await PostRepository.IsSlugTakenAsync(finalSlug, IsEdit ? Id : null))
            {
                finalSlug = $"{baseSlug}-{counter}";
                counter++;
            }

            if (IsEdit && _existingPost is not null)
            {
                _existingPost.Title = _title;
                _existingPost.Slug = finalSlug; // Update slug with unique version
                _existingPost.Summary = _summary;
                _existingPost.Content = _content;
                _existingPost.IsPublished = _isPublished;
                _existingPost.UpdatedAtUtc = DateTime.UtcNow;
                if (_isPublished && !_existingPost.PublishedAtUtc.HasValue)
                {
                    _existingPost.PublishedAtUtc = DateTime.UtcNow;
                }

                await PostRepository.UpdateAsync(_existingPost);
            }
            else
            {
                var post = new Post
                {
                    Id = Guid.NewGuid(),
                    Title = _title,
                    Slug = finalSlug, // Use unique slug
                    Summary = _summary,
                    Content = _content,
                    AuthorId = userId,
                    CreatedAtUtc = DateTime.UtcNow,
                    UpdatedAtUtc = DateTime.UtcNow,
                    IsPublished = _isPublished,
                    PublishedAtUtc = _isPublished ? DateTime.UtcNow : null
                };
                await PostRepository.CreateAsync(post);
            }

            Navigation.NavigateTo("/admin/posts");
        }
        catch (Exception ex)
        {
            _error = $"Failed to save: {ex.Message}";
        }
        finally
        {
            _saving = false;
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Pages/Admin/UserEditor.razor
================================================================================
@page "/admin/users/new"
@page "/admin/users/edit/{Id:guid}"
@attribute [Authorize(Roles = AppConstants.AdminRole)]
@rendermode InteractiveServer
@inject IUserRepository UserRepository
@inject IPasswordService PasswordService
@inject NavigationManager Navigation

<PageTitle>@(IsEdit ? "Edit User" : "New User")</PageTitle>

<h1>@(IsEdit ? "Edit User" : "New User")</h1>

<div class="user-editor" style="max-width: 600px;">
    @if (!string.IsNullOrEmpty(_error))
    {
        <div class="error-message">@_error</div>
    }

    <div class="form-group">
        <label for="username">Username</label>
        <input type="text" id="username" @bind="_username" required />
    </div>

    <div class="form-group">
        <label for="displayName">Display Name</label>
        <input type="text" id="displayName" @bind="_displayName" required />
    </div>

    <div class="form-group">
        <label for="email">Email</label>
        <input type="email" id="email" @bind="_email" required />
    </div>

    <div class="form-group">
        <label for="password">Password @(IsEdit ? "(Leave blank to keep current)" : "")</label>
        <input type="password" id="password" @bind="_password" required="@(!IsEdit)" />
        @if (!IsEdit)
        {
            <small>Required for new users.</small>
        }
    </div>

    <div class="form-actions">
        <button @onclick="Save" class="btn btn-primary" disabled="@_saving">
            @(_saving ? "Saving..." : "Save User")
        </button>
        <a href="/admin/users" class="btn btn-secondary">Cancel</a>
    </div>
</div>

@code {
    [Parameter]
    public Guid? Id { get; set; }

    private bool IsEdit => Id.HasValue;
    private bool _saving;
    private string? _error;

    // Form fields
    private string _username = "";
    private string _displayName = "";
    private string _email = "";
    private string _password = "";

    private User? _existingUser;

    protected override async Task OnParametersSetAsync()
    {
        if (IsEdit)
        {
            _existingUser = await UserRepository.GetByIdAsync(Id!.Value);
            if (_existingUser is null)
            {
                Navigation.NavigateTo("/admin/users");
                return;
            }

            _username = _existingUser.Username;
            _displayName = _existingUser.DisplayName;
            _email = _existingUser.Email;
        }
    }

    private async Task Save()
    {
        _error = null;
        _saving = true;

        try
        {
            if (string.IsNullOrWhiteSpace(_username) || string.IsNullOrWhiteSpace(_displayName) || string.IsNullOrWhiteSpace(_email))
            {
                _error = "All fields are required.";
                return;
            }

            // Check if username is taken (by another user)
            var duplicate = await UserRepository.GetByUsernameAsync(_username);
            if (duplicate is not null && duplicate.Id != Id)
            {
                _error = "Username is already taken.";
                return;
            }

            if (IsEdit && _existingUser is not null)
            {
                // Update existing
                _existingUser.Username = _username;
                _existingUser.DisplayName = _displayName;
                _existingUser.Email = _email;

                // Only update password if provided
                if (!string.IsNullOrWhiteSpace(_password))
                {
                     if (_password.Length < 8)
                     {
                         _error = "Password must be at least 8 characters.";
                         return;
                     }
                    _existingUser.PasswordHash = PasswordService.HashPassword(_password);
                }

                await UserRepository.UpdateAsync(_existingUser);
            }
            else
            {
                // Create new
                if (string.IsNullOrWhiteSpace(_password) || _password.Length < 8)
                {
                    _error = "Password is required (min 8 chars) for new users.";
                    return;
                }

                var newUser = new User
                {
                    Id = Guid.NewGuid(),
                    Username = _username,
                    DisplayName = _displayName,
                    Email = _email,
                    PasswordHash = PasswordService.HashPassword(_password),
                    CreatedAtUtc = DateTime.UtcNow
                };

                await UserRepository.CreateAsync(newUser);
            }

            Navigation.NavigateTo("/admin/users");
        }
        catch (Exception ex)
        {
            _error = $"Error saving user: {ex.Message}";
        }
        finally
        {
            _saving = false;
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Pages/Admin/UserList.razor
================================================================================
@page "/admin/users"
@attribute [Authorize(Roles = AppConstants.AdminRole)]
@rendermode InteractiveServer
@inject IUserRepository UserRepository
@inject AuthenticationStateProvider AuthStateProvider
@inject IJSRuntime JsRuntime
@using System.Security.Claims
@using MyBlog.Core.Models

<PageTitle>Manage Users</PageTitle>

<div class="admin-container">
    <div class="admin-header">
        <h1>Manage Users</h1>
        <a href="/admin/users/new" class="btn btn-primary">Create New User</a>
    </div>

    @if (_users is null)
    {
        <p>Loading...</p>
    }
    else
    {
        <div class="responsive-user-list">
            @* Header - Hidden on mobile *@
            <div class="list-header d-none-mobile">
                <div class="col">Username</div>
                <div class="col">Display Name</div>
                <div class="col">Email</div>
                <div class="col actions">Actions</div>
            </div>

            @foreach (var user in _users)
            {
                <div class="list-row">
                    <div class="list-item">
                        <span class="mobile-label">Username:</span>
                        <a href="/admin/users/edit/@user.Id">@user.Username</a>
                    </div>
                    <div class="list-item">
                        <span class="mobile-label">Name:</span>
                        @user.DisplayName
                    </div>
                    <div class="list-item email-cell">
                        <span class="mobile-label">Email:</span>
                        @user.Email
                    </div>
                    <div class="list-item actions">
                        <a href="/admin/users/edit/@user.Id" class="btn btn-sm">Edit</a>
                        @if (user.Id != _currentUserId)
                        {
                            <button @onclick="() => DeleteUser(user.Id)" class="btn btn-sm btn-danger">Delete</button>
                        }
                        else
                        {
                            <span class="current-user-badge">(Current)</span>
                        }
                    </div>
                </div>
            }
        </div>
    }
</div>

@code {
    private IReadOnlyList<User>? _users;
    private Guid _currentUserId;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var idClaim = authState.User.FindFirst(ClaimTypes.NameIdentifier);
        if (idClaim != null && Guid.TryParse(idClaim.Value, out var id))
        {
            _currentUserId = id;
        }

        await LoadUsers();
    }

    private async Task LoadUsers()
    {
        _users = await UserRepository.GetAllAsync();
    }

    private async Task DeleteUser(Guid id)
    {
        if (id == _currentUserId) return;

        var confirm = await JsRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to delete this user?");

        if (confirm)
        {
            await UserRepository.DeleteAsync(id);
            await LoadUsers();
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Pages/Admin/ChangePassword.razor
================================================================================
@page "/admin/change-password"
@attribute [Authorize]
@inject IAuthService AuthService
@inject IHttpContextAccessor HttpContextAccessor
@inject NavigationManager Navigation
@using System.Security.Claims
@rendermode InteractiveServer

<PageTitle>Change Password</PageTitle>

<h1>Change Password</h1>

<div class="change-password-form">
    @if (!string.IsNullOrEmpty(_successMessage))
    {
        <div class="success-message">@_successMessage</div>
    }

    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="error-message">@_errorMessage</div>
    }

    <form method="post" @onsubmit="HandleSubmit" @formname="changepassword">
        <AntiforgeryToken />

        <div class="form-group">
            <label for="currentPassword">Current Password</label>
            <input type="password" id="currentPassword" name="currentPassword" @bind="_currentPassword" required />
        </div>

        <div class="form-group">
            <label for="newPassword">New Password</label>
            <input type="password" id="newPassword" name="newPassword" @bind="_newPassword" required minlength="8" />
            <small>Minimum 8 characters</small>
        </div>

        <div class="form-group">
            <label for="confirmPassword">Confirm New Password</label>
            <input type="password" id="confirmPassword" name="confirmPassword" @bind="_confirmPassword" required />
        </div>

        <div class="form-actions">
            <button type="submit" class="btn btn-primary">Change Password</button>
            <a href="/admin" class="btn btn-secondary">Cancel</a>
        </div>
    </form>
</div>

@code {
    private string _currentPassword = "";
    private string _newPassword = "";
    private string _confirmPassword = "";
    private string? _successMessage;
    private string? _errorMessage;

    [SupplyParameterFromForm(Name = "currentPassword")]
    public string? FormCurrentPassword { get; set; }

    [SupplyParameterFromForm(Name = "newPassword")]
    public string? FormNewPassword { get; set; }

    [SupplyParameterFromForm(Name = "confirmPassword")]
    public string? FormConfirmPassword { get; set; }

    private async Task HandleSubmit()
    {
        _successMessage = null;
        _errorMessage = null;

        // Use form values if available (SSR form post), otherwise use bound values
        var currentPassword = FormCurrentPassword ?? _currentPassword;
        var newPassword = FormNewPassword ?? _newPassword;
        var confirmPassword = FormConfirmPassword ?? _confirmPassword;

        // Validation
        if (string.IsNullOrWhiteSpace(newPassword) || newPassword.Length < 8)
        {
            _errorMessage = "New password must be at least 8 characters.";
            return;
        }

        if (newPassword != confirmPassword)
        {
            _errorMessage = "New password and confirmation do not match.";
            return;
        }

        if (currentPassword == newPassword)
        {
            _errorMessage = "New password must be different from current password.";
            return;
        }

        // Get current user ID
        var context = HttpContextAccessor.HttpContext;
        var userIdClaim = context?.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;

        if (string.IsNullOrEmpty(userIdClaim) || !Guid.TryParse(userIdClaim, out var userId))
        {
            _errorMessage = "Unable to identify current user. Please log in again.";
            return;
        }

        // Attempt password change
        var success = await AuthService.ChangePasswordAsync(userId, currentPassword, newPassword);

        if (success)
        {
            _successMessage = "Password changed successfully!";
            _currentPassword = "";
            _newPassword = "";
            _confirmPassword = "";
            // Clear form values as well
            FormCurrentPassword = null;
            FormNewPassword = null;
            FormConfirmPassword = null;
        }
        else
        {
            _errorMessage = "Current password is incorrect.";
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Pages/Admin/Dashboard.razor
================================================================================
@page "/admin"
@attribute [Authorize]
@inject IPostRepository PostRepository
@rendermode InteractiveServer

<PageTitle>Admin Dashboard</PageTitle>

<h1>Admin Dashboard</h1>

<div class="dashboard-stats">
    <div class="stat-card">
        <h3>Total Posts</h3>
        <p class="stat-value">@_postCount</p>
    </div>
</div>

<div class="admin-nav">
    <a href="/admin/posts" class="btn">Manage Posts</a>
    <a href="/admin/posts/new" class="btn">New Post</a>
    <a href="/admin/images" class="btn">Manage Images</a>
</div>

<h2>Recent Posts</h2>
@if (_recentPosts is null)
{
    <p>Loading...</p>
}
else if (_recentPosts.Count == 0)
{
    <p>No posts yet.</p>
}
else
{
    <table class="admin-table">
        <thead>
            <tr>
                <th>Title</th>
                <th>Status</th>
                <th>Updated</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var post in _recentPosts)
            {
                <tr>
                    <td><a href="/admin/posts/edit/@post.Id">@post.Title</a></td>
                    <td>@(post.IsPublished ? "Published" : "Draft")</td>
                    <td>@(post.PublishedAtUtc?.ToString("MMM d, yyyy") ?? "")</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private int _postCount;
    private IReadOnlyList<PostListItemDto>? _recentPosts;

    protected override async Task OnInitializedAsync()
    {
        _postCount = await PostRepository.GetCountAsync();
        _recentPosts = await PostRepository.GetRecentPostsAsync(5);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Pages/Home.razor
================================================================================
@page "/"
@inject IPostRepository PostRepository
@inject IConfiguration Configuration

<PageTitle>@(Configuration["Application:Title"] ?? "MyBlog")</PageTitle>

<h1>Welcome to @(Configuration["Application:Title"] ?? "MyBlog")</h1>

@if (_posts is null)
{
    <p>Loading...</p>
}
else if (_posts.Count == 0)
{
    <p>No posts yet. Check back soon!</p>
}
else
{
    <div class="post-list">
        @foreach (var post in _posts)
        {
            <PostCard Post="post" />
        }
    </div>

    <Pagination CurrentPage="_currentPage" TotalPages="_totalPages" BaseUrl="/" />
}

@code {
    private IReadOnlyList<PostListItemDto>? _posts;
    private int _currentPage = 1;
    private int _totalPages = 1;

    [SupplyParameterFromQuery(Name = "page")]
    public int? Page { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        _currentPage = Page ?? 1;
        if (_currentPage < 1) _currentPage = 1;

        var pageSize = Configuration.GetValue("Application:PostsPerPage", 10);
        var (posts, totalCount) = await PostRepository.GetPublishedPostsAsync(_currentPage, pageSize);

        _posts = posts;
        _totalPages = (int)Math.Ceiling(totalCount / (double)pageSize);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Pages/Login.razor
================================================================================
@page "/login"
@inject IAuthService AuthService
@inject NavigationManager Navigation
@inject IHttpContextAccessor HttpContextAccessor
@using System.Security.Claims
@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Authentication.Cookies

<PageTitle>Login</PageTitle>

<div class="login-page">
    <h1>Login</h1>

    @if (!string.IsNullOrEmpty(_error))
    {
        <div class="error-message">@_error</div>
    }

    <form method="post" @onsubmit="HandleLogin" @formname="login">
        <AntiforgeryToken />

        <div class="form-group">
            <label for="username">Username</label>
            <input type="text" id="username" name="username" @bind="_username" required />
        </div>

        <div class="form-group">
            <label for="password">Password</label>
            <input type="password" id="password" name="password" @bind="_password" required />
        </div>

        <button type="submit" class="btn btn-primary">Login</button>
    </form>
</div>

@code {
    private string _username = "";
    private string _password = "";
    private string? _error;

    [SupplyParameterFromQuery]
    public string? ReturnUrl { get; set; }

    [SupplyParameterFromForm(Name = "username")]
    public string? FormUsername { get; set; }

    [SupplyParameterFromForm(Name = "password")]
    public string? FormPassword { get; set; }

    private async Task HandleLogin()
    {
        var username = FormUsername ?? _username;
        var password = FormPassword ?? _password;

        if (string.IsNullOrWhiteSpace(username) || string.IsNullOrWhiteSpace(password))
        {
            _error = "Username and password are required";
            return;
        }

        var user = await AuthService.AuthenticateAsync(username, password);
        if (user is null)
        {
            _error = "Invalid username or password";
            return;
        }

        // FIX: Added the Role claim here so [Authorize(Roles="Admin")] works
        var claims = new List<Claim>
        {
            new(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new(ClaimTypes.Name, user.Username),
            new("DisplayName", user.DisplayName),
            new(ClaimTypes.Role, AppConstants.AdminRole)
        };

        var identity = new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme);
        var principal = new ClaimsPrincipal(identity);

        var context = HttpContextAccessor.HttpContext!;
        await context.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, principal);

        Navigation.NavigateTo(ReturnUrl ?? "/admin", forceLoad: true);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Pages/PostDetail.razor
================================================================================
@page "/post/{Slug}"
@inject IPostRepository PostRepository
@inject NavigationManager Navigation
@using MyBlog.Web.Components.Shared

@if (_post is null)
{
    @if (_notFound)
    {
        <PageTitle>Not Found</PageTitle>
        <h1>Post Not Found</h1>
        <p>The post you're looking for doesn't exist.</p>
        <a href="/"> Back to Home</a>
    }
    else
    {
        <p>Loading...</p>
    }
}
else
{
    <PageTitle>@_post.Title</PageTitle>

    <article class="post-detail">
        <header class="post-header">
            <h1>@_post.Title</h1>
            <div class="post-meta">
                <span class="author">By @_post.AuthorDisplayName</span>
                @if (_post.PublishedAtUtc.HasValue)
                {
                    <span class="date">Published @_post.PublishedAtUtc.Value.ToString("MMMM d, yyyy")</span>
                }

                @* This isolates the interactivity to JUST the badge *@
                <ReaderBadge Slug="@_post.Slug" @rendermode="InteractiveServer" />

                @* This uses the standard JS function we added *@
                <button type="button" class="btn-link share-btn" data-title="@_post.Title" onclick="sharePost(this.dataset.title)">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="18" cy="5" r="3"></circle>
                        <circle cx="6" cy="12" r="3"></circle>
                        <circle cx="18" cy="19" r="3"></circle>
                        <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                        <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                    </svg>
                    Share
                </button>
            </div>
        </header>

        <div class="post-content">
            <MarkdownRenderer Content="@_post.Content" />
        </div>
    </article>

    <a href="/" class="back-link"> Back to Home</a>
}

@code {
    [Parameter]
    public string Slug { get; set; } = "";
    private PostDetailDto? _post;
    private bool _notFound;

    protected override async Task OnParametersSetAsync()
    {
        _post = await PostRepository.GetBySlugAsync(Slug);
        _notFound = _post is null;

        if (_post is not null && !_post.IsPublished)
        {
            _post = null;
            _notFound = true;
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Pages/About.razor
================================================================================
@page "/about"
@rendermode InteractiveServer
@implements IDisposable
@inject IConfiguration Configuration
@inject IReaderTrackingService ReaderTrackingService
@inject IPostRepository PostRepository

<PageTitle>About - @(Configuration["Application:Title"] ?? "MyBlog")</PageTitle>

<article class="about-page">
    <header class="about-header">
        <h1>About @(Configuration["Application:Title"] ?? "MyBlog")</h1>
        <p class="about-tagline">A lightweight, self-hosted blogging platform built with modern .NET technologies</p>
        <div class="reader-info">
            <ReaderBadge Slug="@_trackingSlug" />
        </div>
    </header>

    <section class="about-section">
        <h2>Overview</h2>
        <p>
            Welcome to <strong>@(Configuration["Application:Title"] ?? "MyBlog")</strong>, a powerful yet lightweight
            content management system and blogging platform built entirely with <strong>.NET 10</strong> and
            <strong>Blazor Server</strong>. This application represents a modern approach to self-hosted blogging,
            combining the performance and type-safety of C# with the interactive capabilities of Blazor's
            component-based architecture.
        </p>
        <p>
            MyBlog follows <strong>Clean Architecture</strong> principles, ensuring a clear separation of concerns
            between the domain logic, infrastructure, and presentation layers. This architectural approach makes
            the codebase maintainable, testable, and extensible for future enhancements.
        </p>
    </section>

    <section class="about-section">
        <h2>Architecture</h2>
        <p>
            The application is organized into a multi-project solution structure that follows industry best practices
            for enterprise-grade .NET applications:
        </p>

        <div class="architecture-grid">
            <div class="arch-card">
                <h3>MyBlog.Core</h3>
                <p class="arch-subtitle">Domain Layer</p>
                <p>
                    Contains the heart of the application: domain models, interfaces, and business logic services.
                    This layer has zero dependencies on external frameworks or infrastructure concerns, ensuring
                    that the core business rules remain portable and testable in isolation.
                </p>
                <div class="arch-contents">
                    <strong>Contains:</strong>
                    <ul>
                        <li><code>Models/</code>  Post, User, Image, TelemetryLog, DTOs</li>
                        <li><code>Interfaces/</code>  Repository and service contracts</li>
                        <li><code>Services/</code>  MarkdownService, SlugService</li>
                        <li><code>Constants/</code>  AppConstants (auth cookie name, roles, limits)</li>
                    </ul>
                </div>
            </div>

            <div class="arch-card">
                <h3>MyBlog.Infrastructure</h3>
                <p class="arch-subtitle">Data Access Layer</p>
                <p>
                    Implements the repository interfaces defined in Core using Entity Framework Core with SQLite.
                    This layer handles all database operations, authentication services, and external integrations.
                </p>
                <div class="arch-contents">
                    <strong>Contains:</strong>
                    <ul>
                        <li><code>Data/</code>  BlogDbContext, DatabasePathResolver</li>
                        <li><code>Repositories/</code>  EF Core implementations</li>
                        <li><code>Services/</code>  AuthService, PasswordService, ReaderTrackingService</li>
                        <li><code>Telemetry/</code>  OpenTelemetry exporters</li>
                    </ul>
                </div>
            </div>

            <div class="arch-card">
                <h3>MyBlog.Web</h3>
                <p class="arch-subtitle">Presentation Layer</p>
                <p>
                    The Blazor Server application containing all UI components, pages, layouts, and middleware.
                    Uses a hybrid rendering approach with both Server-Side Rendering (SSR) for public pages
                    and Interactive Server mode for admin functionality.
                </p>
                <div class="arch-contents">
                    <strong>Contains:</strong>
                    <ul>
                        <li><code>Components/Pages/</code>  Razor pages (Home, PostDetail, About, Login)</li>
                        <li><code>Components/Pages/Admin/</code>  Dashboard, PostEditor, UserEditor, ImageManager</li>
                        <li><code>Components/Shared/</code>  Reusable components (PostCard, Pagination, ReaderBadge)</li>
                        <li><code>Middleware/</code>  LoginRateLimitMiddleware</li>
                    </ul>
                </div>
            </div>

            <div class="arch-card">
                <h3>MyBlog.Tests</h3>
                <p class="arch-subtitle">Testing Layer</p>
                <p>
                    Comprehensive test suite using <strong>xUnit v3</strong> with both unit and integration tests.
                    The tests cover core services, repositories, and middleware functionality with high code coverage.
                </p>
                <div class="arch-contents">
                    <strong>Contains:</strong>
                    <ul>
                        <li><code>Unit/</code>  MarkdownServiceTests, SlugServiceTests, PasswordServiceTests</li>
                        <li><code>Integration/</code>  AuthServiceTests, PostRepositoryTests, TelemetryCleanupTests</li>
                        <li>LoginRateLimitMiddlewareTests with injectable delay functions</li>
                    </ul>
                </div>
            </div>
        </div>
    </section>

    <section class="about-section">
        <h2>Technology Stack</h2>
        <div class="tech-grid">
            <div class="tech-category">
                <h3>Backend Framework</h3>
                <ul>
                    <li><strong>.NET 10</strong>  Latest LTS runtime with performance improvements</li>
                    <li><strong>Blazor Server</strong>  Component-based UI with real-time SignalR connectivity</li>
                    <li><strong>ASP.NET Core</strong>  Web framework with middleware pipeline</li>
                    <li><strong>Entity Framework Core</strong>  ORM with code-first migrations</li>
                </ul>
            </div>

            <div class="tech-category">
                <h3>Database</h3>
                <ul>
                    <li><strong>SQLite</strong>  Lightweight, serverless database engine</li>
                    <li><strong>XDG-Compliant Paths</strong>  Platform-specific data directories</li>
                    <li><strong>Image Storage</strong>  Binary data stored directly in database</li>
                    <li><strong>Telemetry Logs</strong>  Structured logging with retention policies</li>
                </ul>
            </div>

            <div class="tech-category">
                <h3>Authentication & Security</h3>
                <ul>
                    <li><strong>Cookie Authentication</strong>  Secure session management</li>
                    <li><strong>ASP.NET Identity PasswordHasher</strong>  Industry-standard hashing</li>
                    <li><strong>Rate Limiting Middleware</strong>  Progressive delays, never blocks</li>
                    <li><strong>Slug Collision Prevention</strong>  Automatic unique slug generation</li>
                </ul>
            </div>

            <div class="tech-category">
                <h3>Observability</h3>
                <ul>
                    <li><strong>OpenTelemetry</strong>  Distributed tracing and metrics</li>
                    <li><strong>File Log Exporter</strong>  JSON-formatted log files with rotation</li>
                    <li><strong>Database Log Exporter</strong>  Queryable telemetry storage</li>
                    <li><strong>Console Exporter</strong>  Development-time debugging</li>
                </ul>
            </div>

            <div class="tech-category">
                <h3>Testing</h3>
                <ul>
                    <li><strong>xUnit v3</strong>  Modern testing framework</li>
                    <li><strong>In-Memory Database</strong>  Fast integration tests</li>
                    <li><strong>Dependency Injection</strong>  Testable delay functions</li>
                    <li><strong>Cross-Platform CI</strong>  Windows, Linux, macOS matrix</li>
                </ul>
            </div>

            <div class="tech-category">
                <h3>DevOps & Deployment</h3>
                <ul>
                    <li><strong>GitHub Actions</strong>  Automated CI/CD pipeline</li>
                    <li><strong>WebDeploy</strong>  IIS deployment with AppOffline rule</li>
                    <li><strong>PowerShell Scripts</strong>  No third-party deployment actions</li>
                    <li><strong>Cross-Platform Publishing</strong>  win-x86, win-x64, linux-x64</li>
                </ul>
            </div>
        </div>
    </section>

    <section class="about-section">
        <h2>Core Features</h2>

        <div class="feature-grid">
            <div class="feature-card">
                <div class="feature-icon"></div>
                <h3>Markdown-Based Content</h3>
                <p>
                    Write posts in Markdown with a custom-built renderer that supports headings (h1-h6),
                    <strong>bold</strong> and <em>italic</em> text, links, images, fenced code blocks with
                    syntax preservation, blockquotes, horizontal rules, and both unordered and ordered lists.
                </p>
                <div class="feature-details">
                    <strong>Supported Syntax:</strong>
                    <code># Headings</code>, <code>**bold**</code>, <code>*italic*</code>,
                    <code>[links](url)</code>, <code>![images](url)</code>, <code>`inline code`</code>,
                    <code>```code blocks```</code>, <code>> blockquotes</code>, <code>- unordered lists</code>,
                    <code>1. ordered lists</code>, <code>---</code> horizontal rules
                </div>
            </div>

            <div class="feature-card">
                <div class="feature-icon"></div>
                <h3>Image Management</h3>
                <p>
                    Upload and manage images directly through the admin interface. Images are stored as binary
                    data in the SQLite database, eliminating file system dependencies and simplifying backups.
                </p>
                <div class="feature-details">
                    <strong>Specifications:</strong>
                    Max size: 5MB per image. Supported formats: JPEG, PNG, GIF, WebP.
                    Reference in Markdown: <code>/api/images/{'{'}id{'}'}</code>
                </div>
            </div>

            <div class="feature-card">
                <div class="feature-icon"></div>
                <h3>Multi-User Support</h3>
                <p>
                    Create, edit, and manage multiple user accounts with display names and email addresses.
                    Each post tracks its author, and administrators can reset passwords for other users.
                </p>
                <div class="feature-details">
                    <strong>User Management:</strong>
                    User list at <code>/admin/users</code>, create new users, edit profiles, reset passwords,
                    change your own password at <code>/admin/change-password</code>
                </div>
            </div>

            <div class="feature-card">
                <div class="feature-icon"></div>
                <h3>Real-Time Reader Tracking</h3>
                <p>
                    See how many people are currently reading each post with live-updating reader counts.
                    Uses a thread-safe <code>ConcurrentDictionary</code> and event-driven updates via
                    SignalR for instant UI refresh.
                </p>
                <div class="feature-details">
                    <strong>Implementation:</strong>
                    <code>IReaderTrackingService</code> with JoinPost/LeavePost lifecycle,
                    <code>OnCountChanged</code> event for reactive updates
                </div>
            </div>

            <div class="feature-card">
                <div class="feature-icon"></div>
                <h3>Security Features</h3>
                <p>
                    Enterprise-grade security with rate limiting that progressively delays login attempts
                    (1s, 2s, 4s... up to 30s) but never completely blocks users. Passwords are hashed using
                    ASP.NET Identity's PasswordHasher with automatic rehashing support.
                </p>
                <div class="feature-details">
                    <strong>Rate Limiting:</strong>
                    15-minute window, delays after 5 attempts, exponential backoff formula:
                    <code>2^(attempts-5)</code> seconds, capped at 30s
                </div>
            </div>

            <div class="feature-card">
                <div class="feature-icon"></div>
                <h3>Smart Slug Generation</h3>
                <p>
                    Automatically generates URL-friendly slugs from post titles with Unicode normalization,
                    special character removal, and automatic collision prevention by appending numbers
                    (<code>my-post</code>, <code>my-post-1</code>, <code>my-post-2</code>).
                </p>
                <div class="feature-details">
                    <strong>Algorithm:</strong>
                    Normalize Unicode  lowercase  replace spaces/underscores with hyphens 
                    remove non-alphanumeric  collapse multiple hyphens  trim edges
                </div>
            </div>
        </div>
    </section>

    <section class="about-section">
        <h2>Admin Dashboard</h2>
        <p>
            The administrative interface provides comprehensive content management capabilities:
        </p>

        <div class="admin-features">
            <div class="admin-feature">
                <h3> Dashboard (<code>/admin</code>)</h3>
                <p>
                    Overview of your blog with total post count and the 5 most recently updated posts.
                    Quick links to all management areas with status indicators.
                </p>
            </div>

            <div class="admin-feature">
                <h3> Post Management (<code>/admin/posts</code>)</h3>
                <p>
                    View all posts with title, author, and publish status. Create new posts with
                    a live Markdown preview, edit existing content, toggle publish/draft status,
                    and delete posts with confirmation.
                </p>
            </div>

            <div class="admin-feature">
                <h3> User Management (<code>/admin/users</code>)</h3>
                <p>
                    List all registered users, create new accounts with usernames, emails, and display names.
                    Edit user profiles and reset passwords for other administrators.
                </p>
            </div>

            <div class="admin-feature">
                <h3> Image Library (<code>/admin/images</code>)</h3>
                <p>
                    Upload new images with drag-and-drop support, browse existing images with
                    preview thumbnails, copy image URLs for use in Markdown, and delete unused images.
                </p>
            </div>

            <div class="admin-feature">
                <h3> Password Change (<code>/admin/change-password</code>)</h3>
                <p>
                    Securely update your password with current password verification.
                    Minimum 8 characters required, with confirmation field to prevent typos.
                </p>
            </div>
        </div>
    </section>

    <section class="about-section">
        <h2>Configuration</h2>
        <p>
            MyBlog is highly configurable through <code>appsettings.json</code> and environment variables:
        </p>

        <div class="config-section">
            <h3>Application Settings</h3>
            <div class="config-table">
                <div class="config-row">
                    <code>Application:Title</code>
                    <span>Blog title displayed in header and page titles</span>
                    <em>Default: "MyBlog"</em>
                </div>
                <div class="config-row">
                    <code>Application:PostsPerPage</code>
                    <span>Number of posts per page on the homepage</span>
                    <em>Default: 10</em>
                </div>
                <div class="config-row">
                    <code>Application:RequireHttps</code>
                    <span>Force HTTPS for authentication cookies</span>
                    <em>Default: false</em>
                </div>
                <div class="config-row">
                    <code>Application:GitForgeUrl</code>
                    <span>Link to source code repository in footer</span>
                    <em>Default: GitHub URL</em>
                </div>
            </div>
        </div>

        <div class="config-section">
            <h3>Authentication Settings</h3>
            <div class="config-table">
                <div class="config-row">
                    <code>Authentication:SessionTimeoutMinutes</code>
                    <span>How long before the session expires</span>
                    <em>Default: 30</em>
                </div>
                <div class="config-row">
                    <code>Authentication:DefaultAdminPassword</code>
                    <span>Initial password for first admin user</span>
                    <em>Default: "ChangeMe123!"</em>
                </div>
                <div class="config-row">
                    <code>MYBLOG_ADMIN_PASSWORD</code>
                    <span>Environment variable override (only on first run)</span>
                    <em>Takes precedence over config file</em>
                </div>
            </div>
        </div>

        <div class="config-section">
            <h3>Telemetry Settings</h3>
            <div class="config-table">
                <div class="config-row">
                    <code>Telemetry:RetentionDays</code>
                    <span>Days to keep telemetry logs before cleanup</span>
                    <em>Default: 30</em>
                </div>
                <div class="config-row">
                    <code>Telemetry:EnableFileLogging</code>
                    <span>Write logs to JSON files</span>
                    <em>Default: true</em>
                </div>
                <div class="config-row">
                    <code>Telemetry:EnableDatabaseLogging</code>
                    <span>Store logs in SQLite database</span>
                    <em>Default: true</em>
                </div>
            </div>
        </div>

        <div class="config-section">
            <h3>Database Locations (XDG-Compliant)</h3>
            <div class="config-table">
                <div class="config-row">
                    <code>Linux</code>
                    <span><code>~/.local/share/MyBlog/myblog.db</code></span>
                    <em>Follows XDG_DATA_HOME</em>
                </div>
                <div class="config-row">
                    <code>macOS</code>
                    <span><code>~/Library/Application Support/MyBlog/myblog.db</code></span>
                    <em>Standard macOS location</em>
                </div>
                <div class="config-row">
                    <code>Windows</code>
                    <span><code>%LOCALAPPDATA%\MyBlog\myblog.db</code></span>
                    <em>Per-user application data</em>
                </div>
            </div>
        </div>
    </section>

    <section class="about-section">
        <h2>Deployment</h2>
        <p>
            MyBlog includes a complete CI/CD pipeline with GitHub Actions for automated testing and deployment:
        </p>

        <div class="deployment-section">
            <h3>GitHub Actions Workflow</h3>
            <ol>
                <li><strong>Build & Test</strong>  Runs on Windows, Linux, and macOS simultaneously</li>
                <li><strong>Restore</strong>  <code>dotnet restore src/MyBlog.slnx</code></li>
                <li><strong>Build</strong>  <code>dotnet build -c Release</code></li>
                <li><strong>Test</strong>  <code>dotnet test</code> with TRX output</li>
                <li><strong>Publish</strong>  Self-contained deployment for win-x86</li>
                <li><strong>Deploy</strong>  WebDeploy to IIS with AppOffline rule</li>
            </ol>
        </div>

        <div class="deployment-section">
            <h3>Required GitHub Secrets</h3>
            <div class="config-table">
                <div class="config-row">
                    <code>WEBSITE_NAME</code>
                    <span>IIS site name for WebDeploy</span>
                    <em>e.g., "MyBlog"</em>
                </div>
                <div class="config-row">
                    <code>SERVER_COMPUTER_NAME</code>
                    <span>Server hostname</span>
                    <em>e.g., "myserver.example.com"</em>
                </div>
                <div class="config-row">
                    <code>SERVER_USERNAME</code>
                    <span>WebDeploy authentication user</span>
                    <em>Deploy account username</em>
                </div>
                <div class="config-row">
                    <code>SERVER_PASSWORD</code>
                    <span>WebDeploy authentication password</span>
                    <em>Stored as secret</em>
                </div>
            </div>
        </div>

        <div class="deployment-section">
            <h3>WebDeploy Configuration</h3>
            <p>
                The deployment uses key features to ensure zero-downtime deployments:
            </p>
            <ul>
                <li><strong>AppOffline Rule</strong>  Creates <code>app_offline.htm</code> to gracefully stop the application</li>
                <li><strong>DoNotDeleteRule</strong>  Preserves existing files not in the deployment package</li>
                <li><strong>Retry Logic</strong>  3 retry attempts with 3-second intervals for transient failures</li>
                <li><strong>File Locking Prevention</strong>  Solves ERROR_FILE_IN_USE during active deployments</li>
            </ul>
        </div>
    </section>

    <section class="about-section">
        <h2>Design Principles</h2>
        <div class="principles-grid">
            <div class="principle">
                <h3> Zero External Dependencies</h3>
                <p>
                    No npm, no Node.js, no CSS frameworks. All styling is custom CSS using CSS variables
                    for theming. The only JavaScript is Blazor's <code>blazor.web.js</code> runtime.
                </p>
            </div>

            <div class="principle">
                <h3> Self-Contained</h3>
                <p>
                    Everything needed runs from a single deployable unit. SQLite eliminates the need
                    for external database servers. Images are stored in the database, not the filesystem.
                </p>
            </div>

            <div class="principle">
                <h3> Centralized Package Management</h3>
                <p>
                    Uses <code>Directory.Packages.props</code> for consistent NuGet package versions
                    across all projects. The modern <code>.slnx</code> solution format keeps things clean.
                </p>
            </div>

            <div class="principle">
                <h3> Performance First</h3>
                <p>
                    Public pages use Server-Side Rendering (SSR) for fast initial loads. Interactive
                    features are scoped to admin pages where they're needed. AsNoTracking queries
                    minimize EF Core overhead for read operations.
                </p>
            </div>

            <div class="principle">
                <h3> Testability</h3>
                <p>
                    All services use interface-based dependency injection. The rate limiting middleware
                    accepts an injectable delay function for instant test execution instead of real waits.
                </p>
            </div>

            <div class="principle">
                <h3> Cross-Platform</h3>
                <p>
                    Runs identically on Windows, Linux, and macOS. XDG-compliant paths ensure data
                    is stored in appropriate locations for each operating system.
                </p>
            </div>
        </div>
    </section>

    <section class="about-section">
        <h2>Data Models</h2>
        <p>
            The core domain models represent the fundamental entities in the blogging system:
        </p>

        <div class="model-grid">
            <div class="model-card">
                <h3>Post</h3>
                <p>A blog post with full content management capabilities.</p>
                <div class="model-fields">
                    <code>Id</code> (Guid), <code>Title</code>, <code>Slug</code>, <code>Content</code>,
                    <code>Summary</code>, <code>AuthorId</code>, <code>CreatedAtUtc</code>,
                    <code>UpdatedAtUtc</code>, <code>PublishedAtUtc</code>, <code>IsPublished</code>
                </div>
            </div>

            <div class="model-card">
                <h3>User</h3>
                <p>An authenticated user who can create and manage content.</p>
                <div class="model-fields">
                    <code>Id</code> (Guid), <code>Username</code>, <code>PasswordHash</code>,
                    <code>Email</code>, <code>DisplayName</code>, <code>CreatedAtUtc</code>
                </div>
            </div>

            <div class="model-card">
                <h3>Image</h3>
                <p>An uploaded image stored as binary data in the database.</p>
                <div class="model-fields">
                    <code>Id</code> (Guid), <code>FileName</code>, <code>ContentType</code>,
                    <code>Data</code> (byte[]), <code>UploadedByUserId</code>, <code>UploadedAtUtc</code>,
                    <code>PostId</code> (optional)
                </div>
            </div>

            <div class="model-card">
                <h3>TelemetryLog</h3>
                <p>Structured log entries for observability and debugging.</p>
                <div class="model-fields">
                    <code>Id</code> (int), <code>TimestampUtc</code>, <code>Level</code>,
                    <code>Category</code>, <code>Message</code>, <code>Exception</code>,
                    <code>TraceId</code>, <code>SpanId</code>, <code>Properties</code> (JSON)
                </div>
            </div>
        </div>
    </section>

    <section class="about-section">
        <h2>API Endpoints</h2>
        <p>
            While primarily a Blazor Server application, MyBlog exposes a few HTTP endpoints:
        </p>

        <div class="api-table">
            <div class="api-row">
                <code>GET /api/images/{'{'}id{'}'}</code>
                <span>Retrieve an image by its GUID for embedding in posts</span>
            </div>
            <div class="api-row">
                <code>POST /logout</code>
                <span>Sign out the current user (requires authorization)</span>
            </div>
            <div class="api-row">
                <code>POST /login</code>
                <span>Form-based authentication with rate limiting</span>
            </div>
        </div>
    </section>

    <section class="about-section">
        <h2>Quick Start</h2>
        <div class="quickstart">
            <h3>Prerequisites</h3>
            <p><a href="https://dotnet.microsoft.com/download/dotnet/10.0" target="_blank">.NET 10 SDK</a> or later</p>

            <h3>Running Locally</h3>
            <pre><code># Clone the repository
git clone https://github.com/kusl/dotnetcms.git
cd dotnetcms/src

# Restore and run
dotnet restore MyBlog.slnx
cd MyBlog.Web
dotnet run</code></pre>

            <h3>Default Credentials</h3>
            <p>
                <strong>Username:</strong> <code>admin</code><br />
                <strong>Password:</strong> <code>ChangeMe123!</code> (or set <code>MYBLOG_ADMIN_PASSWORD</code> environment variable before first run)
            </p>

            <div class="warning-box">
                <strong> Important:</strong> The default password is only used when creating the initial admin user.
                Once the user exists, you must change the password through the website at <code>/admin/change-password</code>.
            </div>
        </div>
    </section>

    <section class="about-section stats-section">
        <h2>Current Statistics</h2>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value">@_postCount</div>
                <div class="stat-label">Total Posts</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">@_publishedCount</div>
                <div class="stat-label">Published</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">@(_postCount - _publishedCount)</div>
                <div class="stat-label">Drafts</div>
            </div>
        </div>
    </section>

    <section class="about-section">
        <h2>Open Source</h2>
        <p>
            MyBlog is open source software. The complete source code, including this page, is available
            on GitHub. Contributions, bug reports, and feature requests are welcome!
        </p>
        <p>
            <a href="@(Configuration["Application:GitForgeUrl"] ?? "https://github.com/kusl/dotnetcms")"
               target="_blank"
               class="github-link">
                View on GitHub 
            </a>
        </p>
    </section>

    <footer class="about-footer">
        <p>
            Built with  using .NET 10 and Blazor Server
        </p>
        <p class="version-info">
            <small>
                Runtime: @System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription |
                OS: @System.Runtime.InteropServices.RuntimeInformation.OSDescription
            </small>
        </p>
    </footer>
</article>

@code {
    private const string _trackingSlug = "__about_page__";
    private int _postCount;
    private int _publishedCount;

    protected override async Task OnInitializedAsync()
    {
        ReaderTrackingService.JoinPost(_trackingSlug);
        ReaderTrackingService.OnCountChanged += HandleCountChanged;

        var (posts, totalCount) = await PostRepository.GetPublishedPostsAsync(1, int.MaxValue);
        _publishedCount = totalCount;
        _postCount = await PostRepository.GetCountAsync();
    }

    private void HandleCountChanged(string slug, int count)
    {
        if (slug == _trackingSlug)
        {
            InvokeAsync(StateHasChanged);
        }
    }

    public void Dispose()
    {
        ReaderTrackingService.OnCountChanged -= HandleCountChanged;
        ReaderTrackingService.LeavePost(_trackingSlug);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Routes.razor
================================================================================
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <AuthorizeRouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)">
            <NotAuthorized>
                <RedirectToLogin />
            </NotAuthorized>
        </AuthorizeRouteView>
        <FocusOnNavigate RouteData="routeData" Selector="h1" />
    </Found>
</Router>


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Shared/MarkdownRenderer.razor
================================================================================
@inject IMarkdownService MarkdownService

<div class="markdown-content">
    @((MarkupString)MarkdownService.ToHtml(Content ?? ""))
</div>

@code {
    [Parameter]
    public string? Content { get; set; }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Shared/Pagination.razor
================================================================================
@if (TotalPages > 1)
{
    <nav class="pagination" aria-label="Page navigation">
        @if (CurrentPage > 1)
        {
            <a href="@GetPageUrl(CurrentPage - 1)" class="page-link"> Previous</a>
        }

        <span class="page-info">Page @CurrentPage of @TotalPages</span>

        @if (CurrentPage < TotalPages)
        {
            <a href="@GetPageUrl(CurrentPage + 1)" class="page-link">Next </a>
        }
    </nav>
}

@code {
    [Parameter, EditorRequired]
    public int CurrentPage { get; set; }

    [Parameter, EditorRequired]
    public int TotalPages { get; set; }

    [Parameter]
    public string BaseUrl { get; set; } = "/";

    private string GetPageUrl(int page) =>
        page == 1 ? BaseUrl : $"{BaseUrl}?page={page}";
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Shared/PostCard.razor
================================================================================
<article class="post-card">
    <h2 class="post-card-title">
        <a href="/post/@Post.Slug">@Post.Title</a>
    </h2>
    <div class="post-card-meta">
        <span class="author">By @Post.AuthorDisplayName</span>
        @if (Post.PublishedAtUtc.HasValue)
        {
            <span class="date">@Post.PublishedAtUtc.Value.ToString("MMMM d, yyyy")</span>
        }
        @if (!Post.IsPublished)
        {
            <span class="draft-badge">Draft</span>
        }
    </div>
    <p class="post-card-summary">@Post.Summary</p>
    <a href="/post/@Post.Slug" class="read-more">Read more </a>
</article>

@code {
    [Parameter, EditorRequired]
    public PostListItemDto Post { get; set; } = default!;
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Shared/RedirectToLogin.razor
================================================================================
@inject NavigationManager Navigation

@code {
    protected override void OnInitialized()
    {
        Navigation.NavigateTo($"/login?returnUrl={Uri.EscapeDataString(Navigation.Uri)}", forceLoad: true);
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Shared/Footer.razor
================================================================================
@inject IConfiguration Configuration

<footer class="footer">
    <div class="container">
        <p>&copy; @DateTime.Now.Year @(Configuration["Application:Title"] ?? "MyBlog")</p>

        @{
            var gitUrl = Configuration["Application:GitForgeUrl"];
            if (!string.IsNullOrWhiteSpace(gitUrl) &&
                Uri.TryCreate(gitUrl, UriKind.Absolute, out var validatedUri) &&
                (validatedUri.Scheme == Uri.UriSchemeHttp || validatedUri.Scheme == Uri.UriSchemeHttps))
            {
                <a href="@gitUrl" target="_blank" rel="noopener noreferrer" class="footer-link">
                    <svg height="16" width="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true">
                        <path d="M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"></path>
                    </svg>
                    <span>Source Code</span>
                </a>
            }
        }
    </div>
</footer>


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/Shared/ReaderBadge.razor
================================================================================
@using MyBlog.Core.Interfaces
@inject IReaderTrackingService TrackingService
@implements IDisposable

@if (_count > 0)
{
    <span class="reader-badge" title="Live reader count">
        <span class="reader-dot"></span>
        @_count people reading
    </span>
}

@code {
    [Parameter]
    public string Slug { get; set; } = "";

    private int _count;

    protected override void OnInitialized()
    {
        if (string.IsNullOrEmpty(Slug)) return;

        // Join the group and get initial count
        TrackingService.JoinPost(Slug);
        _count = TrackingService.GetReaderCount(Slug);

        // Listen for updates
        TrackingService.OnCountChanged += HandleCountChanged;
    }

    private void HandleCountChanged(string slug, int count)
    {
        if (slug == Slug)
        {
            _count = count;
            InvokeAsync(StateHasChanged);
        }
    }

    public void Dispose()
    {
        if (!string.IsNullOrEmpty(Slug))
        {
            TrackingService.LeavePost(Slug);
            TrackingService.OnCountChanged -= HandleCountChanged;
        }
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/_Imports.razor
================================================================================
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using MyBlog.Core.Constants
@using MyBlog.Core.Interfaces
@using MyBlog.Core.Models
@using MyBlog.Web.Components
@using MyBlog.Web.Components.Layout
@using MyBlog.Web.Components.Shared


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Components/App.razor
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>@(Title ?? "MyBlog")</title>
    <base href="/" />
    <link rel="stylesheet" href="css/site.css" />
    <link rel="stylesheet" href="MyBlog.Web.styles.css" />
    <HeadOutlet />
</head>
<body>
<Routes />
<script src="js/site.js"></script>
<script src="_framework/blazor.web.js"></script>
</body>
</html>

@code {
    [CascadingParameter]
    private HttpContext? HttpContext { get; set; }

    private string? Title => HttpContext?.RequestServices
        .GetService<IConfiguration>()?["Application:Title"];
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Middleware/LoginRateLimitMiddleware.cs
================================================================================
using System.Collections.Concurrent;

namespace MyBlog.Web.Middleware;

/// <summary>
/// Rate limiting middleware for login attempts.
/// Slows down requests but NEVER blocks users completely.
/// </summary>
public sealed class LoginRateLimitMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<LoginRateLimitMiddleware> _logger;
    private readonly Func<TimeSpan, CancellationToken, Task>? _delayFunc;

    // Track attempts per IP: IP -> (attempt count, window start)
    private static readonly ConcurrentDictionary<string, (int Count, DateTime WindowStart)> Attempts = new();

    // Configuration
    private const int WindowMinutes = 15;
    private const int AttemptsBeforeDelay = 5;
    private const int MaxDelaySeconds = 30;

    // Use this for the standard DI activation
    [ActivatorUtilitiesConstructor]
    public LoginRateLimitMiddleware(RequestDelegate next, ILogger<LoginRateLimitMiddleware> logger)
        : this(next, logger, null)
    {
    }

    /// <summary>
    /// Constructor with injectable delay function for testing.
    /// </summary>
    public LoginRateLimitMiddleware(
        RequestDelegate next,
        ILogger<LoginRateLimitMiddleware> logger,
        Func<TimeSpan, CancellationToken, Task>? delayFunc)
    {
        _next = next;
        _logger = logger;
        _delayFunc = delayFunc;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Only rate limit POST requests to login endpoint
        if (!IsLoginPostRequest(context))
        {
            await _next(context);
            return;
        }

        var ip = GetClientIp(context);
        var delay = CalculateDelay(ip);

        if (delay > TimeSpan.Zero)
        {
            _logger.LogInformation(
                "Rate limiting login attempt from {IP}, delaying {Seconds}s",
                ip, delay.TotalSeconds);

            // Use injected delay function if available (for testing), otherwise real delay
            if (_delayFunc != null)
            {
                await _delayFunc(delay, context.RequestAborted);
            }
            else
            {
                await Task.Delay(delay, context.RequestAborted);
            }
        }

        // Always proceed - never block
        await _next(context);

        // Record the attempt after processing
        RecordAttempt(ip);
    }

    private static bool IsLoginPostRequest(HttpContext context)
    {
        return context.Request.Method == HttpMethods.Post &&
               context.Request.Path.StartsWithSegments("/login", StringComparison.OrdinalIgnoreCase);
    }

    private static string GetClientIp(HttpContext context)
    {
        // Check for forwarded IP (behind proxy/load balancer)
        var forwardedFor = context.Request.Headers["X-Forwarded-For"].FirstOrDefault();
        if (!string.IsNullOrEmpty(forwardedFor))
        {
            var ip = forwardedFor.Split(',')[0].Trim();
            if (!string.IsNullOrEmpty(ip))
            {
                return ip;
            }
        }

        return context.Connection.RemoteIpAddress?.ToString() ?? "unknown";
    }

    /// <summary>
    /// Calculates the delay for a given IP. Exposed for testing.
    /// </summary>
    public static TimeSpan CalculateDelay(string ip)
    {
        if (!Attempts.TryGetValue(ip, out var record))
        {
            return TimeSpan.Zero;
        }

        // Reset if window expired
        if (DateTime.UtcNow - record.WindowStart > TimeSpan.FromMinutes(WindowMinutes))
        {
            Attempts.TryRemove(ip, out _);
            return TimeSpan.Zero;
        }

        // No delay for first few attempts
        if (record.Count < AttemptsBeforeDelay)
        {
            return TimeSpan.Zero;
        }

        // Progressive delay: 1s, 2s, 4s, 8s, ... capped at MaxDelaySeconds
        var delayMultiplier = record.Count - AttemptsBeforeDelay;
        var delaySeconds = Math.Min(Math.Pow(2, delayMultiplier), MaxDelaySeconds);
        return TimeSpan.FromSeconds(delaySeconds);
    }

    /// <summary>
    /// Records a login attempt for the given IP. Exposed for testing.
    /// </summary>
    internal static void RecordAttempt(string ip)
    {
        var now = DateTime.UtcNow;

        Attempts.AddOrUpdate(
            ip,
            _ => (1, now),
            (_, existing) =>
            {
                // Reset window if expired
                if (now - existing.WindowStart > TimeSpan.FromMinutes(WindowMinutes))
                {
                    return (1, now);
                }
                return (existing.Count + 1, existing.WindowStart);
            });

        // Cleanup old entries periodically (every 100th request)
        if (Random.Shared.Next(100) == 0)
        {
            CleanupOldEntries();
        }
    }

    /// <summary>
    /// Clears all tracked attempts. For testing only.
    /// </summary>
    public static void ClearAttempts()
    {
        Attempts.Clear();
    }

    private static void CleanupOldEntries()
    {
        var cutoff = DateTime.UtcNow.AddMinutes(-WindowMinutes * 2);
        foreach (var kvp in Attempts)
        {
            if (kvp.Value.WindowStart < cutoff)
            {
                Attempts.TryRemove(kvp.Key, out _);
            }
        }
    }
}

/// <summary>
/// Extension methods for LoginRateLimitMiddleware.
/// </summary>
public static class LoginRateLimitMiddlewareExtensions
{
    /// <summary>
    /// Adds login rate limiting middleware that slows down repeated attempts
    /// but never completely blocks users.
    /// </summary>
    public static IApplicationBuilder UseLoginRateLimit(this IApplicationBuilder app)
    {
        return app.UseMiddleware<LoginRateLimitMiddleware>();
    }
}


--- END OF FILE ---

================================================================================
FILE PATH: src/MyBlog.Web/Program.cs
================================================================================
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.Cookies;
using Microsoft.EntityFrameworkCore;
using MyBlog.Core.Constants;
using MyBlog.Core.Interfaces;
using MyBlog.Infrastructure;
using MyBlog.Infrastructure.Data;
using MyBlog.Infrastructure.Services;
using MyBlog.Infrastructure.Telemetry;
using MyBlog.Web.Components;
using MyBlog.Web.Middleware;
using OpenTelemetry;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

builder.Services.AddInfrastructure(builder.Configuration);

// Register TelemetryCleanupService as a hosted service
builder.Services.AddHostedService<TelemetryCleanupService>();

// Configure authentication
var sessionTimeout = builder.Configuration.GetValue("Authentication:SessionTimeoutMinutes", 30);
builder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie(options =>
    {
        options.Cookie.Name = AppConstants.AuthCookieName;
        options.LoginPath = "/login";
        options.LogoutPath = "/logout";
        options.AccessDeniedPath = "/access-denied"; // FIX: Added explicit Access Denied path
        options.ExpireTimeSpan = TimeSpan.FromMinutes(sessionTimeout);
        options.SlidingExpiration = true;
        options.Cookie.HttpOnly = true;
        options.Cookie.SecurePolicy = builder.Configuration.GetValue("Application:RequireHttps", false)
            ? CookieSecurePolicy.Always
            : CookieSecurePolicy.SameAsRequest;
    });

builder.Services.AddAuthorization();
builder.Services.AddCascadingAuthenticationState();
builder.Services.AddHttpContextAccessor();
builder.Services.AddAntiforgery();

// OpenTelemetry configuration
var serviceName = "MyBlog.Web";
var serviceVersion = typeof(Program).Assembly.GetName().Version?.ToString() ?? "1.0.0";
builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService(serviceName: serviceName, serviceVersion: serviceVersion))
    .WithTracing(tracing => tracing
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddSource(serviceName)
        .AddConsoleExporter())
    .WithMetrics(metrics => metrics
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddConsoleExporter());

// Configure logging with OpenTelemetry
var telemetryDir = TelemetryPathResolver.GetTelemetryDirectory();
builder.Logging.AddOpenTelemetry(logging =>
{
    logging.IncludeFormattedMessage = true;
    logging.IncludeScopes = true;
    logging.AddConsoleExporter();

    if (telemetryDir is not null)
    {
        var logsPath = Path.Combine(telemetryDir, "logs");
        Directory.CreateDirectory(logsPath);
        logging.AddProcessor(new BatchLogRecordExportProcessor(new FileLogExporter(logsPath)));
    }
});

var app = builder.Build();

// Initialize database
using (var scope = app.Services.CreateScope())
{
    var db = scope.ServiceProvider.GetRequiredService<BlogDbContext>();
    await db.Database.MigrateAsync();

    var authService = scope.ServiceProvider.GetRequiredService<IAuthService>();
    await authService.EnsureAdminUserAsync();
}

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}

app.UseStaticFiles();
app.UseAntiforgery();

app.UseAuthentication();
app.UseAuthorization();

app.UseLoginRateLimit();

app.MapPost("/logout", async (HttpContext context) =>
{
    await context.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);
    return Results.Redirect("/");
}).RequireAuthorization();

app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();

app.Run();


--- END OF FILE ---

