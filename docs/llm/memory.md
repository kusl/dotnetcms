Purpose & context
Kushal is developing MyBlog, a .NET 10 Blazor Server CMS/blog application following clean architecture principles. The project serves as both a functional blogging platform and a learning sandbox for exploring modern .NET development practices. The application is deployed to kush.runasp.net via GitHub Actions and uses SQLite for data persistence, with a focus on cross-platform compatibility (Windows/Linux/Fedora).
The project emphasizes clean code practices with strict development standards: preserving existing coding styles, avoiding unnecessary modifications, ensuring comprehensive test coverage, and maintaining engineering best practices. Kushal values thorough analysis over quick fixes and prefers understanding root causes rather than accepting workarounds. The application features cookie-based authentication, custom Markdown parsing, image management with BLOB storage, OpenTelemetry observability, and a multi-theme system with WCAG AA compliance.
Key technical constraints include zero npm/node dependencies, custom CSS without frameworks, XDG-compliant file paths, and SELinux compatibility for containerized environments. The project uses centralized package management and maintains compatibility across development environments including Fedora with podman-compose.
Current state
The application is actively deployed and functional with comprehensive E2E testing using Playwright. Recent focus has been on debugging and fixing authentication flows, form handling issues in Blazor Server rendering modes, and cross-platform compatibility problems. The codebase includes 77+ unit and integration tests with xUnit v3, covering authentication, post management, markdown processing, and telemetry services.
Current architecture spans four projects: MyBlog.Core (domain), MyBlog.Infrastructure (data access), MyBlog.Web (Blazor UI), and MyBlog.Tests. The application successfully handles real-time reader tracking via SignalR, progressive login rate limiting, and automatic database schema updates for deployment scenarios.
Active development involves maintaining the balance between Blazor's interactive server rendering and static SSR modes, particularly for authentication forms and admin interfaces. The project demonstrates mature CI/CD practices with GitHub Actions handling multi-platform testing and WebDeploy deployment.
Key learnings & principles
Blazor Rendering Modes: Critical understanding that mixing interactive and static rendering modes requires careful form handling - interactive components need @rendermode InteractiveServer and SignalR connections, while SSR forms require name attributes and [SupplyParameterFromForm] properties. Authentication flows work best with traditional HTML forms posting to minimal API endpoints rather than interactive Blazor handlers.
Cross-Platform Development: Windows vs Linux differences manifest in newline characters (\r\n vs \n), test execution performance, and file system behaviors. SQLite file locking issues on Windows require using in-memory databases (Data Source=:memory:) for reliable testing.
E2E Testing Patterns: Playwright tests must account for Blazor's initialization timing, particularly waiting for antiforgery tokens and SignalR connections before form interactions. Modern Playwright patterns using WaitForURLAsync are preferred over obsolete RunAndWaitForNavigationAsync methods.
Database Migration Strategy: EnsureCreatedAsync() only works for fresh databases; existing deployments require custom schema update logic using CREATE TABLE IF NOT EXISTS patterns for incremental changes.
Security Philosophy: Implementing progressive delays for failed login attempts without ever completely blocking users, allowing unlimited attempts while potentially slowing down suspicious activity.
Approach & patterns
Development follows a methodical debugging approach: comprehensive code analysis, understanding root causes before implementing fixes, and maintaining existing architectural patterns. Problem-solving involves systematic investigation using project knowledge searches, analyzing error patterns across different environments, and implementing defense-in-depth error handling.
Testing strategy emphasizes comprehensive coverage with both unit tests and E2E scenarios, using in-memory databases for isolation and containerized environments for realistic deployment testing. Code changes follow strict guidelines: preserve coding style, make minimal necessary changes, ensure all tests pass, and maintain clean architecture boundaries.
Deployment workflow uses GitHub Actions with multi-platform testing, automated WebDeploy to production, and proper secret management. Database initialization handles both fresh deployments and incremental schema updates automatically during startup.
Tools & resources
Development Stack: .NET 10, Blazor Server, Entity Framework Core with SQLite, xUnit v3 for testing, OpenTelemetry for observability, SignalR for real-time features
Testing & Deployment: Playwright for E2E testing, GitHub Actions for CI/CD, WebDeploy for production deployment, podman-compose for containerized development on Fedora
Development Environment: Cross-platform development with Fedora Linux primary environment, Windows compatibility testing, SELinux-compliant containerization
Architecture Tools: Clean Architecture pattern with clear separation between Core, Infrastructure, and Web layers, centralized package management via Directory.Packages.props, custom CSS with CSS variables for theming
